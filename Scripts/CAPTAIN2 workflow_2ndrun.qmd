---
title: "CAPTAIN2 workflow"
author: "Th√©ophile L. Mouton"
date: "May 21, 2025"
format:
  html:
    toc: true
    toc-location: right
    css: custom.css
    output-file: "CAPTAIN2 workflow_2ndrun.html"
    self-contained: true
    code-fold: true
    code-tools: true
editor: visual
execute:
  warning: false
  message: false
  echo: true
---

## EDGE2 continental 0.1 budget

```{r}
library(here)
library(dplyr)
library(ggplot2)
library(sf)
library(rnaturalearth)
library(smoothr)
library(raster)
library(readr)
library(tidyr)

# Read the CAPTAIN2 EDGE2 RDS file
CAPTAIN2_EDGE2_data <- readRDS(here::here("Data/CAPTAIN2_EDGE_full_results_averaged_budget0.1_replicates50.rds"))

# Analyze non-zero cells in the prioritization output
cat("Analyzing cells with non-zero priority values in CAPTAIN2 EDGE2 output:\n")
total_cells <- nrow(CAPTAIN2_EDGE2_data)
nonzero_cells <- sum(CAPTAIN2_EDGE2_data$Priority > 0, na.rm = TRUE)
zero_cells <- sum(CAPTAIN2_EDGE2_data$Priority == 0, na.rm = TRUE)
na_cells <- sum(is.na(CAPTAIN2_EDGE2_data$Priority))

cat("Total cells in grid:", total_cells, "\n")
cat("Cells with non-zero priority:", nonzero_cells, " (", round(nonzero_cells/total_cells*100, 2), "%)\n", sep="")
cat("Cells with zero priority:", zero_cells, " (", round(zero_cells/total_cells*100, 2), "%)\n", sep="")
cat("Cells with NA priority:", na_cells, " (", round(na_cells/total_cells*100, 2), "%)\n", sep="")

# Summary statistics of priority values
priority_summary <- summary(CAPTAIN2_EDGE2_data$Priority)
cat("\nSummary statistics of priority values:\n")
print(priority_summary)

# Distribution of non-zero priority values
nonzero_priority <- CAPTAIN2_EDGE2_data$Priority[CAPTAIN2_EDGE2_data$Priority > 0]
cat("\nDistribution of non-zero priority values:\n")
priority_quantiles <- quantile(nonzero_priority, probs = seq(0, 1, 0.1), na.rm = TRUE)
print(priority_quantiles)

# Load one of your input raster files to extract the correct grid structure
raster_file <- here::here("Data", "tif files continental", "Psammobatis_parvacauda.tif")

# Check if the file exists
if (!file.exists(raster_file)) {
  stop("Raster file not found. Please provide a valid path to one of your input raster files.")
}

# Load the raster
r <- raster(raster_file)

# Get the dimensions of the raster
nrows <- nrow(r)
ncols <- ncol(r)

# Confirm dimensions match expected values
if (nrows != 323 || ncols != 720) {
  warning("Raster dimensions don't match expected values. Proceeding with actual dimensions.")
}

# Create a grid of coordinates for each cell
coords <- as.data.frame(coordinates(r))
names(coords) <- c("Longitude", "Latitude")

# Add cell IDs (PUID) to the coordinates
coords$PUID <- 1:nrow(coords)

# Now join with the CAPTAIN2 data based on PUID
CAPTAIN2_EDGE2_data_with_coords <- CAPTAIN2_EDGE2_data %>%
  left_join(coords, by = "PUID")

# Check if the join worked correctly
if (sum(is.na(CAPTAIN2_EDGE2_data_with_coords$Longitude)) > 0) {
  warning("Some PUIDs from CAPTAIN2 data couldn't be matched to coordinates.")
}

# Filter to keep only cells with non-zero priority for faster plotting
CAPTAIN2_EDGE2_data_nonzero <- CAPTAIN2_EDGE2_data_with_coords %>%
  filter(Priority > 0) %>%
  filter(!is.na(Longitude), !is.na(Latitude))  # Remove any rows with missing coords

# Get world map data
world <- ne_countries(scale = "medium", returnclass = "sf")

# Define the McBryde-Thomas 2 projection
mcbryde_thomas_2 <- "+proj=mbt_s"

# Transform the dataset to sf object and project
CAPTAIN2_EDGE2_sf <- st_as_sf(
  CAPTAIN2_EDGE2_data_nonzero, 
  coords = c("Longitude", "Latitude"), 
  crs = crs(r, asText = TRUE)  # Use the raster's CRS
) %>%
  st_transform(crs = mcbryde_thomas_2)

# Project the world map
world_projected_CAPTAIN2_EDGE2 <- st_transform(world, crs = mcbryde_thomas_2)

# Create the globe bounding box
globe_bbox <- rbind(c(-180, -90), c(-180, 90), 
                    c(180, 90), c(180, -90), c(-180, -90))

# Create the globe border
globe_border_CAPTAIN2_EDGE2 <- st_polygon(list(globe_bbox)) %>%
  st_sfc(crs = 4326) %>%
  st_sf(data.frame(rgn = 'globe', geom = .)) %>%
  smoothr::densify(max_distance = 0.5) %>%
  st_transform(crs = mcbryde_thomas_2)

# Create base theme
my_theme_CAPTAIN2_EDGE2 <- theme_minimal() +
  theme(
    legend.position = "bottom",
    legend.direction = "horizontal",
    legend.box = "vertical",
    legend.margin = margin(t = 20, r = 0, b = 0, l = 0),
    legend.title = element_text(margin = margin(b = 10)),
    panel.background = element_rect(fill = "white", color = NA),
    plot.background = element_rect(fill = "white", color = NA),
    panel.grid = element_blank(),
    axis.text = element_blank(),      # Add this line
    axis.ticks = element_blank()      # Add this line
  )

# Create the plot
CAPTAIN2_EDGE2_plot <- ggplot() +
  geom_sf(data = CAPTAIN2_EDGE2_sf, aes(color = Priority), size = 0.5, alpha = 0.7) +
  geom_sf(data = world_projected_CAPTAIN2_EDGE2, fill = "lightgrey", color = "lightgrey", size = 0.1) +
  geom_sf(data = globe_border_CAPTAIN2_EDGE2, fill = NA, color = "black", size = 0.5) +
  scale_color_gradientn(
    colors = c("white", "yellow", "darkblue"),
    values = c(0, 0.5, 1),
    name = "Priority",
    guide = guide_colorbar(barwidth = 20, barheight = 0.5, 
                         title.position = "top", title.hjust = 0.5)
  ) +
  labs(title = "Global Conservation Priorities",
       subtitle = "CAPTAIN2 - EDGE2 Index, Budget: 0.1, Replicates: 50",
       x = NULL, y = NULL) +
  my_theme_CAPTAIN2_EDGE2

# Display the plot
print(CAPTAIN2_EDGE2_plot)

# Save the plot
ggsave(
  filename = here::here("outputs", "CAPTAIN2_2ndrun_EDGE2_priorities_01_2.png"),
  plot = CAPTAIN2_EDGE2_plot,
  width = 10,
  height = 6,
  dpi = 300,
  bg = "white"
)
```

# FUSE continental 0.1 budget

```{r}
library(here)
library(dplyr)
library(ggplot2)
library(sf)
library(rnaturalearth)
library(smoothr)
library(raster)

# Read the CAPTAIN2 FUSE RDS file
CAPTAIN2_FUSE_data <- readRDS(here::here("Data/CAPTAIN2_FUSE_res_full_results_averaged_budget0.1_replicates50.rds"))

# Load one of your input raster files to extract the correct grid structure
# Use the same raster file for consistency
raster_file <- here::here("Data", "tif files continental", "Psammobatis_parvacauda.tif")

# Check if the file exists
if (!file.exists(raster_file)) {
  stop("Raster file not found. Please provide a valid path to one of your input raster files.")
}

# Load the raster
r <- raster(raster_file)

# Get the dimensions of the raster
nrows <- nrow(r)
ncols <- ncol(r)

# Confirm dimensions match expected values
if (nrows != 323 || ncols != 720) {
  warning("Raster dimensions don't match expected values. Proceeding with actual dimensions.")
}

# Create a grid of coordinates for each cell
# This gives us the center coordinates of each cell
coords <- as.data.frame(coordinates(r))
names(coords) <- c("Longitude", "Latitude")

# Add cell IDs (PUID) to the coordinates
coords$PUID <- 1:nrow(coords)

# Now join with the CAPTAIN2 FUSE data based on PUID
CAPTAIN2_FUSE_data_with_coords <- CAPTAIN2_FUSE_data %>%
  left_join(coords, by = "PUID")

# Check if the join worked correctly
if (sum(is.na(CAPTAIN2_FUSE_data_with_coords$Longitude)) > 0) {
  warning("Some PUIDs from CAPTAIN2 FUSE data couldn't be matched to coordinates.")
}

# Filter to keep only cells with non-zero priority for faster plotting
CAPTAIN2_FUSE_data_nonzero <- CAPTAIN2_FUSE_data_with_coords %>%
  filter(Priority > 0) %>%
  filter(!is.na(Longitude), !is.na(Latitude))  # Remove any rows with missing coords

# Get world map data
world <- ne_countries(scale = "medium", returnclass = "sf")

# Define the McBryde-Thomas 2 projection
mcbryde_thomas_2 <- "+proj=mbt_s"

# Transform the dataset to sf object and project
CAPTAIN2_FUSE_sf <- st_as_sf(
  CAPTAIN2_FUSE_data_nonzero, 
  coords = c("Longitude", "Latitude"), 
  crs = crs(r, asText = TRUE)  # Use the raster's CRS
) %>%
  st_transform(crs = mcbryde_thomas_2)

# Project the world map
world_projected_CAPTAIN2_FUSE <- st_transform(world, crs = mcbryde_thomas_2)

# Create the globe bounding box
globe_bbox <- rbind(c(-180, -90), c(-180, 90), 
                    c(180, 90), c(180, -90), c(-180, -90))

# Create the globe border
globe_border_CAPTAIN2_FUSE <- st_polygon(list(globe_bbox)) %>%
  st_sfc(crs = 4326) %>%
  st_sf(data.frame(rgn = 'globe', geom = .)) %>%
  smoothr::densify(max_distance = 0.5) %>%
  st_transform(crs = mcbryde_thomas_2)

# Create base theme
my_theme_CAPTAIN2_FUSE <- theme_minimal() +
  theme(
    legend.position = "bottom",
    legend.direction = "horizontal",
    legend.box = "vertical",
    legend.margin = margin(t = 20, r = 0, b = 0, l = 0),
    legend.title = element_text(margin = margin(b = 10)),
    panel.background = element_rect(fill = "white", color = NA),
    plot.background = element_rect(fill = "white", color = NA),
    panel.grid = element_blank(),
    axis.text = element_blank(),      # Add this line
    axis.ticks = element_blank())      # Add this line

# Create the plot
CAPTAIN2_FUSE_plot <- ggplot() +
  geom_sf(data = CAPTAIN2_FUSE_sf, aes(color = Priority), size = 0.5, alpha = 0.7) +
  geom_sf(data = world_projected_CAPTAIN2_FUSE, fill = "lightgrey", color = "lightgrey", size = 0.1) +
  geom_sf(data = globe_border_CAPTAIN2_FUSE, fill = NA, color = "black", size = 0.5) +
  scale_color_gradientn(
    colors = c("white", "yellow", "darkblue"),
    values = c(0, 0.5, 1),
    name = "Priority",
    guide = guide_colorbar(barwidth = 20, barheight = 0.5, 
                         title.position = "top", title.hjust = 0.5)
  ) +
  labs(title = "Global Conservation Priorities",
       subtitle = "CAPTAIN2 - FUSE Index, Budget: 0.1, Replicates: 50",
       x = NULL, y = NULL) +
  my_theme_CAPTAIN2_FUSE

# Display the plot
print(CAPTAIN2_FUSE_plot)

# Save the plot
ggsave(
  filename = here::here("outputs", "CAPTAIN2_FUSE_priorities_01_2.png"),
  plot = CAPTAIN2_FUSE_plot,
  width = 10,
  height = 6,
  dpi = 300,
  bg = "white"
)
```

# IUCN continental 0.1 budget

```{r}
library(here)
library(dplyr)
library(ggplot2)
library(sf)
library(rnaturalearth)
library(smoothr)
library(raster)

# Read the CAPTAIN2 IUCN RDS file
CAPTAIN2_IUCN_data <- readRDS(here::here("Data/CAPTAIN2_IUCN_full_results_averaged_budget0.1_replicates50.rds"))

# Load one of your input raster files to extract the correct grid structure
# Use the same raster file for consistency
raster_file <- here::here("Data", "tif files continental", "Psammobatis_parvacauda.tif")

# Check if the file exists
if (!file.exists(raster_file)) {
  stop("Raster file not found. Please provide a valid path to one of your input raster files.")
}

# Load the raster
r <- raster(raster_file)

# Get the dimensions of the raster
nrows <- nrow(r)
ncols <- ncol(r)

# Confirm dimensions match expected values
if (nrows != 323 || ncols != 720) {
  warning("Raster dimensions don't match expected values. Proceeding with actual dimensions.")
}

# Create a grid of coordinates for each cell
# This gives us the center coordinates of each cell
coords <- as.data.frame(coordinates(r))
names(coords) <- c("Longitude", "Latitude")

# Add cell IDs (PUID) to the coordinates
coords$PUID <- 1:nrow(coords)

# Now join with the CAPTAIN2 IUCN data based on PUID
CAPTAIN2_IUCN_data_with_coords <- CAPTAIN2_IUCN_data %>%
  left_join(coords, by = "PUID")

# Check if the join worked correctly
if (sum(is.na(CAPTAIN2_IUCN_data_with_coords$Longitude)) > 0) {
  warning("Some PUIDs from CAPTAIN2 IUCN data couldn't be matched to coordinates.")
}

# Filter to keep only cells with non-zero priority for faster plotting
CAPTAIN2_IUCN_data_nonzero <- CAPTAIN2_IUCN_data_with_coords %>%
  filter(Priority > 0) %>%
  filter(!is.na(Longitude), !is.na(Latitude))  # Remove any rows with missing coords

# Get world map data
world <- ne_countries(scale = "medium", returnclass = "sf")

# Define the McBryde-Thomas 2 projection
mcbryde_thomas_2 <- "+proj=mbt_s"

# Transform the dataset to sf object and project
CAPTAIN2_IUCN_sf <- st_as_sf(
  CAPTAIN2_IUCN_data_nonzero, 
  coords = c("Longitude", "Latitude"), 
  crs = crs(r, asText = TRUE)  # Use the raster's CRS
) %>%
  st_transform(crs = mcbryde_thomas_2)

# Project the world map
world_projected_CAPTAIN2_IUCN <- st_transform(world, crs = mcbryde_thomas_2)

# Create the globe bounding box
globe_bbox <- rbind(c(-180, -90), c(-180, 90), 
                    c(180, 90), c(180, -90), c(-180, -90))

# Create the globe border
globe_border_CAPTAIN2_IUCN <- st_polygon(list(globe_bbox)) %>%
  st_sfc(crs = 4326) %>%
  st_sf(data.frame(rgn = 'globe', geom = .)) %>%
  smoothr::densify(max_distance = 0.5) %>%
  st_transform(crs = mcbryde_thomas_2)

# Create base theme
my_theme_CAPTAIN2_IUCN <- theme_minimal() +
  theme(
    legend.position = "bottom",
    legend.direction = "horizontal",
    legend.box = "vertical",
    legend.margin = margin(t = 20, r = 0, b = 0, l = 0),
    legend.title = element_text(margin = margin(b = 10)),
    panel.background = element_rect(fill = "white", color = NA),
    plot.background = element_rect(fill = "white", color = NA),
    panel.grid = element_blank(),
    axis.text = element_blank(),      # Add this line
    axis.ticks = element_blank()      # Add this line
  )

# Create the plot
CAPTAIN2_IUCN_plot <- ggplot() +
  geom_sf(data = CAPTAIN2_IUCN_sf, aes(color = Priority), size = 0.5, alpha = 0.7) +
  geom_sf(data = world_projected_CAPTAIN2_IUCN, fill = "lightgrey", color = "lightgrey", size = 0.1) +
  geom_sf(data = globe_border_CAPTAIN2_IUCN, fill = NA, color = "black", size = 0.5) +
  scale_color_gradientn(
    colors = c("white", "yellow", "darkblue"),
    values = c(0, 0.5, 1),
    name = "Priority",
    guide = guide_colorbar(barwidth = 20, barheight = 0.5, 
                         title.position = "top", title.hjust = 0.5)
  ) +
  labs(title = "Global Conservation Priorities",
       subtitle = "CAPTAIN2 - IUCN Index, Budget: 0.1, Replicates: 50",
       x = NULL, y = NULL) +
  my_theme_CAPTAIN2_IUCN

# Display the plot
print(CAPTAIN2_IUCN_plot)

# Save the plot
ggsave(
  filename = here::here("outputs", "CAPTAIN2_IUCN_priorities_01_2.png"),
  plot = CAPTAIN2_IUCN_plot,
  width = 10,
  height = 6,
  dpi = 300,
  bg = "white"
)
```

# Difference maps

```{r}
library(here)
library(dplyr)
library(ggplot2)
library(sf)
library(rnaturalearth)
library(smoothr)
library(raster)

# Read all three index RDS files
CAPTAIN2_IUCN_data <- readRDS(here::here("Data/CAPTAIN2_IUCN_full_results_averaged_budget0.1_replicates50.rds"))
CAPTAIN2_EDGE2_data <- readRDS(here::here("Data/CAPTAIN2_EDGE_full_results_averaged_budget0.1_replicates50.rds"))
CAPTAIN2_FUSE_data <- readRDS(here::here("Data/CAPTAIN2_FUSE_res_full_results_averaged_budget0.1_replicates50.rds"))

# Load one of your input raster files to extract the correct grid structure
raster_file <- here::here("Data", "tif files continental", "Psammobatis_parvacauda.tif")

# Check if the file exists
if (!file.exists(raster_file)) {
  stop("Raster file not found. Please provide a valid path to one of your input raster files.")
}

# Load the raster
r <- raster(raster_file)

# Create a grid of coordinates for each cell
coords <- as.data.frame(coordinates(r))
names(coords) <- c("Longitude", "Latitude")

# Add cell IDs (PUID) to the coordinates
coords$PUID <- 1:nrow(coords)

# Join all three datasets with coordinates
IUCN_with_coords <- CAPTAIN2_IUCN_data %>%
  dplyr::select(PUID, IUCN = Priority) %>%
  left_join(coords, by = "PUID")

EDGE2_with_coords <- CAPTAIN2_EDGE2_data %>%
  dplyr::select(PUID, EDGE2 = Priority) %>%
  left_join(coords, by = "PUID") 

FUSE_with_coords <- CAPTAIN2_FUSE_data %>%
  dplyr::select(PUID, FUSE = Priority) %>%
  left_join(coords, by = "PUID")

# Combine all datasets
all_indices <- coords %>%
  left_join(CAPTAIN2_IUCN_data %>% dplyr::select(PUID, IUCN = Priority), by = "PUID") %>%
  left_join(CAPTAIN2_EDGE2_data %>% dplyr::select(PUID, EDGE2 = Priority), by = "PUID") %>%
  left_join(CAPTAIN2_FUSE_data %>% dplyr::select(PUID, FUSE = Priority), by = "PUID")

# Calculate differences
all_indices <- all_indices %>%
  mutate(
    # Replace NA with 0 for calculation purposes
    IUCN = ifelse(is.na(IUCN), 0, IUCN),
    EDGE2 = ifelse(is.na(EDGE2), 0, EDGE2),
    FUSE = ifelse(is.na(FUSE), 0, FUSE),
    
    # Calculate differences
    IUCN_minus_FUSE = IUCN - FUSE,
    IUCN_minus_EDGE2 = IUCN - EDGE2,
    EDGE2_minus_FUSE = EDGE2 - FUSE
  )

# Get world map data
world <- ne_countries(scale = "medium", returnclass = "sf")

# Define the McBryde-Thomas 2 projection
mcbryde_thomas_2 <- "+proj=mbt_s"

# Create the globe bounding box
globe_bbox <- rbind(c(-180, -90), c(-180, 90), 
                    c(180, 90), c(180, -90), c(-180, -90))

# Create the globe border
globe_border <- st_polygon(list(globe_bbox)) %>%
  st_sfc(crs = 4326) %>%
  st_sf(data.frame(rgn = 'globe', geom = .)) %>%
  smoothr::densify(max_distance = 0.5) %>%
  st_transform(crs = mcbryde_thomas_2)

# Project the world map
world_projected <- st_transform(world, crs = mcbryde_thomas_2)

# Create base theme
my_theme <- theme_minimal() +
  theme(
    legend.position = "bottom",
    legend.direction = "horizontal",
    legend.box = "vertical",
    legend.margin = margin(t = 20, r = 0, b = 0, l = 0),
    legend.title = element_text(margin = margin(b = 10)),
    panel.background = element_rect(fill = "white", color = NA),
    plot.background = element_rect(fill = "white", color = NA),
    panel.grid = element_blank()
  )

# Filter to non-zero differences for each comparison to reduce plot size
# IUCN - FUSE
IUCN_FUSE_diff <- all_indices %>%
  filter(IUCN_minus_FUSE != 0) %>%
  st_as_sf(coords = c("Longitude", "Latitude"), crs = crs(r, asText = TRUE)) %>%
  st_transform(crs = mcbryde_thomas_2)

# IUCN - EDGE2
IUCN_EDGE2_diff <- all_indices %>%
  filter(IUCN_minus_EDGE2 != 0) %>%
  st_as_sf(coords = c("Longitude", "Latitude"), crs = crs(r, asText = TRUE)) %>%
  st_transform(crs = mcbryde_thomas_2)

# EDGE2 - FUSE
EDGE2_FUSE_diff <- all_indices %>%
  filter(EDGE2_minus_FUSE != 0) %>%
  st_as_sf(coords = c("Longitude", "Latitude"), crs = crs(r, asText = TRUE)) %>%
  st_transform(crs = mcbryde_thomas_2)

# Create a diverging color palette for difference maps
# Blue for negative (first index lower), white for zero, red for positive (first index higher)
diff_colors <- c("#2166AC", "#4393C3", "#92C5DE", "#D1E5F0", "#FFFFFF", 
                "#FDDBC7", "#F4A582", "#D6604D", "#B2182B")

# 1. IUCN - FUSE Difference Map
IUCN_FUSE_plot <- ggplot() +
  geom_sf(data = globe_border, fill = "#F8F8F8", color = NA) +
  geom_sf(data = IUCN_FUSE_diff, aes(color = IUCN_minus_FUSE), size = 0.5) +
  geom_sf(data = world_projected, fill = "lightgrey", color = "darkgrey", size = 0.1) +
  geom_sf(data = globe_border, fill = NA, color = "black", size = 0.5) +
  scale_color_gradientn(
    colors = diff_colors,
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.25),
    labels = as.character(seq(-1, 1, by = 0.25)),
    name = "Difference in Priority (IUCN - FUSE)",
    guide = guide_colorbar(barwidth = 20, barheight = 0.5, 
                         title.position = "top", title.hjust = 0.5)
  ) +
  labs(title = "Difference in Conservation Priorities",
       subtitle = "IUCN Index minus FUSE Index",
       x = NULL, y = NULL) +
  my_theme

# 2. IUCN - EDGE2 Difference Map
IUCN_EDGE2_plot <- ggplot() +
  geom_sf(data = globe_border, fill = "#F8F8F8", color = NA) +
  geom_sf(data = IUCN_EDGE2_diff, aes(color = IUCN_minus_EDGE2), size = 0.5) +
  geom_sf(data = world_projected, fill = "lightgrey", color = "darkgrey", size = 0.1) +
  geom_sf(data = globe_border, fill = NA, color = "black", size = 0.5) +
  scale_color_gradientn(
    colors = diff_colors,
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.25),
    labels = as.character(seq(-1, 1, by = 0.25)),
    name = "Difference in Priority (IUCN - EDGE2)",
    guide = guide_colorbar(barwidth = 20, barheight = 0.5, 
                         title.position = "top", title.hjust = 0.5)
  ) +
  labs(title = "Difference in Conservation Priorities",
       subtitle = "IUCN Index minus EDGE2 Index",
       x = NULL, y = NULL) +
  my_theme

# 3. EDGE2 - FUSE Difference Map
EDGE2_FUSE_plot <- ggplot() +
  geom_sf(data = globe_border, fill = "#F8F8F8", color = NA) +
  geom_sf(data = EDGE2_FUSE_diff, aes(color = EDGE2_minus_FUSE), size = 0.5) +
  geom_sf(data = world_projected, fill = "lightgrey", color = "darkgrey", size = 0.1) +
  geom_sf(data = globe_border, fill = NA, color = "black", size = 0.5) +
  scale_color_gradientn(
    colors = diff_colors,
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.25),
    labels = as.character(seq(-1, 1, by = 0.25)),
    name = "Difference in Priority (EDGE2 - FUSE)",
    guide = guide_colorbar(barwidth = 20, barheight = 0.5, 
                         title.position = "top", title.hjust = 0.5)
  ) +
  labs(title = "Difference in Conservation Priorities",
       subtitle = "EDGE2 Index minus FUSE Index",
       x = NULL, y = NULL) +
  my_theme

# Display all plots
print(IUCN_FUSE_plot)
print(IUCN_EDGE2_plot)
print(EDGE2_FUSE_plot)

# Save all plots
ggsave(
  filename = here::here("outputs", "CAPTAIN2_IUCN_minus_FUSE_difference_2.png"),
  plot = IUCN_FUSE_plot,
  width = 10,
  height = 6,
  dpi = 300,
  bg = "white"
)

ggsave(
  filename = here::here("outputs", "CAPTAIN2_IUCN_minus_EDGE2_difference_2.png"),
  plot = IUCN_EDGE2_plot,
  width = 10,
  height = 6,
  dpi = 300,
  bg = "white"
)

ggsave(
  filename = here::here("outputs", "CAPTAIN2_EDGE2_minus_FUSE_difference_2.png"),
  plot = EDGE2_FUSE_plot,
  width = 10,
  height = 6,
  dpi = 300,
  bg = "white"
)

# Optionally, create a panel with all three difference maps
library(patchwork)

# Combine all plots
all_diffs_plot <- IUCN_FUSE_plot / IUCN_EDGE2_plot / EDGE2_FUSE_plot +
  plot_annotation(
    title = "Differences Between Conservation Priority Indices",
    subtitle = "Budget: 0.1, Replicates: 100",
    theme = theme(plot.title = element_text(hjust = 0.5),
                  plot.subtitle = element_text(hjust = 0.5))
  )

#all_diffs_plot

# Save the combined plot
#ggsave(
#  filename = here::here("outputs", "CAPTAIN2_all_differences.png"),
#  plot = all_diffs_plot,
#  width = 10,
#  height = 15,
#  dpi = 300,
#  bg = "white"
#)
```

# Species level priorities 

## Boxplots of biodiversity scores against protected fraction 

## Relationship Between Species Metrics and Protection Levels

To examine whether each prioritisation approach successfully targeted species based on its respective biodiversity metric, we analysed the relationship between species-level metric scores and the protection achieved under each approach.

For each prioritisation approach, we calculated Spearman rank correlations between species' metric scores and the fraction of their range protected under that approach. Specifically, we tested: (1) whether IUCN threat status correlated with protection under IUCN prioritisation, (2) whether FUSE scores correlated with protection under FUSE prioritisation, and (3) whether EDGE2 scores correlated with protection under EDGE2 prioritisation. Spearman correlations were used due to the ordinal nature of the metric scores (IUCN categories 1-5, FUSE scores 1-5, EDGE2 scores 1-5) and non-normal distributions of protection values.

To assess the specificity of each approach's targeting, we conducted cross-correlation analyses examining whether protection levels under one approach correlated with metric scores from the other approaches. For example, we tested whether IUCN-based protection correlated with FUSE and EDGE2 scores, in addition to IUCN threat status. This created a 3 √ó 3 correlation matrix with protection approaches as rows and metric types as columns. Strong correlations along the diagonal (e.g., IUCN protection vs IUCN status) combined with weak off-diagonal correlations (e.g., IUCN protection vs FUSE scores) would indicate that each approach specifically targeted its intended biodiversity dimension.

We visualised the relationships between metric scores and protection levels using boxplots showing the distribution of protection percentages across each metric category (LC, NT, VU, EN, CR for IUCN; scores 1-5 for FUSE and EDGE2). All statistical tests were performed at Œ± = 0.05 significance level using the cor.test function in R (version 4.4.2; R Core Team 2024). Visualisations were created using the ggplot2 package.

```{r}
# Load required packages
library(here)
library(readr)
library(dplyr)
library(tidyr)
library(ggplot2)

# Read the protected range fractions RDS file
protected_fractions <- readRDS(here::here("Data", "CAPTAIN2_protected_range_fractions_2ndrun.rds"))

# Read the continental shark conservation metrics CSV file
shark_metrics <- read_csv(here::here("Data", "continental_shark_conservation_metrics_10_harmonised_IUCN_categories.csv"))

# Rename column in shark_metrics to match better
shark_metrics <- shark_metrics %>%
  rename(Species = `Species name`)

# Order shark_metrics alphabetically by Species name
shark_metrics <- shark_metrics %>%
  arrange(Species)

# Add an original order ID to protected_fractions to maintain its original order
protected_fractions$original_order <- 1:nrow(protected_fractions)

# Add row number as IDs to both datasets
protected_fractions$protected_ID <- 1:nrow(protected_fractions)
shark_metrics$species_ID <- 1:nrow(shark_metrics)

# Check if the datasets have the same number of rows
if(nrow(protected_fractions) == nrow(shark_metrics)) {
  # Create index mapping - this maintains the original protection data ordering
  # while allowing us to associate with alphabetically ordered species names
  indices <- data.frame(
    protected_ID = 1:nrow(protected_fractions),
    species_ID = 1:nrow(shark_metrics)
  )
  
  # Join protected_fractions with indices
  protected_with_indices <- protected_fractions %>%
    left_join(indices, by = "protected_ID")
  
  # Join shark_metrics with indices
  shark_with_indices <- shark_metrics %>%
    left_join(indices, by = "species_ID")
  
  # Now join the datasets, matching on species_ID and protected_ID
  combined_data <- protected_with_indices %>%
    inner_join(
      shark_with_indices,
      by = c("species_ID", "protected_ID"),
      suffix = c("_captain", "_original")
    ) %>%
    # Sort by the original order of protected_fractions 
    arrange(original_order)
  
  cat("Successfully joined datasets with", nrow(combined_data), "species\n")
  cat("First few species in combined dataset:\n")
  print(head(combined_data[, c("Species_captain", "Species_original")]))
  
  # Define IUCN categories and order - using only the first 5 categories
  iucn_labels <- c(
    "1" = "LC", 
    "2" = "NT", 
    "3" = "VU", 
    "4" = "EN", 
    "5" = "CR"
  )
  
  iucn_order <- c("LC", "NT", "VU", "EN", "CR")
  
  # Define colors for IUCN categories
  iucn_colors <- c(
    "LC" = "#50C878",     # Green
    "NT" = "#FFFF00",     # Yellow
    "VU" = "#FFA500",     # Orange
    "EN" = "#FF8C00",     # Dark Orange
    "CR" = "#FF0000"      # Red
  )
  
  # 1. IUCN Boxplot
  iucn_boxplot <- combined_data %>%
    mutate(
      IUCN_status = factor(IUCN_original, levels = 1:5, labels = iucn_order),
      protection_percentage = IUCN_captain * 100
    ) %>%
    ggplot(aes(x = IUCN_status, y = protection_percentage)) +
  #  geom_violin(aes(fill = IUCN_status, color = IUCN_status), 
  #              trim = FALSE, 
  #              alpha = 0.5) +
    geom_jitter(width = 0.1, 
                size = 0.6, 
                alpha = 0.5, 
                color = "darkgray") +
    geom_boxplot(width = 0.1, 
                 fill = "white", 
                 color = "black", 
                 outlier.shape = NA, 
                 alpha = 0.8) +
    labs(title = "IUCN Priority Index: Range Protection by IUCN Status",
         x = "IUCN Red List threat status", 
         y = "Range protected (%)") +
    theme_minimal() +
    theme(
      plot.title = element_text(hjust = 0.5),
      legend.position = "none",
      panel.grid.major.x = element_blank()
    ) +
    scale_fill_manual(values = iucn_colors) +
    scale_color_manual(values = iucn_colors) +
    scale_y_continuous(limits = c(0, 100),
                      breaks = seq(0, 100, 25))
  
  # 2. FUSE Boxplot
  fuse_boxplot <- combined_data %>%
    mutate(
      FUSE_category = factor(FUSE_original),
      protection_percentage = FUSE_captain * 100
    ) %>%
    ggplot(aes(x = FUSE_category, y = protection_percentage)) +
  #  geom_violin(aes(fill = FUSE_category, color = FUSE_category), 
  #              trim = FALSE, 
  #              alpha = 0.5) +
    geom_jitter(width = 0.1, 
                size = 0.6, 
                alpha = 0.5, 
                color = "darkgray") +
    geom_boxplot(width = 0.1, 
                 fill = "white", 
                 color = "black", 
                 outlier.shape = NA, 
                 alpha = 0.8) +
    labs(title = "FUSE Priority Index: Range Protection by FUSE Score",
         x = "FUSE Score", 
         y = "Range protected (%)") +
    theme_minimal() +
    theme(
      plot.title = element_text(hjust = 0.5),
      legend.position = "none",
      panel.grid.major.x = element_blank()
    ) +
    scale_y_continuous(limits = c(0, 100),
                      breaks = seq(0, 100, 25))
  
  # 3. EDGE2 Boxplot
  edge2_boxplot <- combined_data %>%
    mutate(
      EDGE2_category = factor(EDGE2_original),
      protection_percentage = EDGE2_captain * 100
    ) %>%
    ggplot(aes(x = EDGE2_category, y = protection_percentage)) +
  #  geom_violin(aes(fill = EDGE2_category, color = EDGE2_category), 
  #              trim = FALSE, 
  #              alpha = 0.5) +
    geom_jitter(width = 0.1, 
                size = 0.6, 
                alpha = 0.5, 
                color = "darkgray") +
    geom_boxplot(width = 0.1, 
                 fill = "white", 
                 color = "black", 
                 outlier.shape = NA, 
                 alpha = 0.8) +
    labs(title = "EDGE2 Priority Index: Range Protection by EDGE2 Score",
         x = "EDGE2 Score", 
         y = "Range protected (%)") +
    theme_minimal() +
    theme(
      plot.title = element_text(hjust = 0.5),
      legend.position = "none",
      panel.grid.major.x = element_blank()
    ) +
    scale_y_continuous(limits = c(0, 100),
                      breaks = seq(0, 100, 25))
  
  # Display individual plots
  print(iucn_boxplot)
  print(fuse_boxplot)
  print(edge2_boxplot)
  
  # Save individual plots
  ggsave(here::here("outputs", "iucn_protection_boxplot.png"), 
         iucn_boxplot, width = 10, height = 6, dpi = 300)
  ggsave(here::here("outputs", "fuse_protection_boxplot.png"), 
         fuse_boxplot, width = 10, height = 6, dpi = 300)
  ggsave(here::here("outputs", "edge2_protection_boxplot.png"), 
         edge2_boxplot, width = 10, height = 6, dpi = 300)
  
# Install patchwork if needed
# install.packages("patchwork")
library(patchwork)

# Create the combined plot
combined_boxplots <- iucn_boxplot + fuse_boxplot + edge2_boxplot +
  plot_layout(ncol = 3) +
  plot_annotation(
    title = "Species Range Protection Across Prioritisation Approaches",
    theme = theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 16))
  )

print(combined_boxplots)

# Save the combined plot
ggsave(here::here("outputs", "combined_boxplots_grid.png"),
       combined_boxplots, width = 18, height = 6, dpi = 300)

# Load required packages
library(here)
library(dplyr)
library(ggplot2)
library(patchwork)

# Define IUCN categories and colors
iucn_order <- c("LC", "NT", "VU", "EN", "CR")
iucn_colors <- c(
  "LC" = "#50C878",  # Green
  "NT" = "#FFFF00",  # Yellow
  "VU" = "#FFA500",  # Orange
  "EN" = "#FF8C00",  # Dark Orange
  "CR" = "#FF0000"   # Red
)

# Calculate sample sizes for each group
iucn_n <- combined_data %>%
  group_by(IUCN_original) %>%
  summarise(n = n()) %>%
  arrange(IUCN_original)

fuse_n <- combined_data %>%
  group_by(FUSE_original) %>%
  summarise(n = n()) %>%
  arrange(FUSE_original)

edge2_n <- combined_data %>%
  group_by(EDGE2_original) %>%
  summarise(n = n()) %>%
  arrange(EDGE2_original)

# Create x-axis labels with sample sizes
iucn_labels <- paste0(iucn_order, "\n(n=", iucn_n$n, ")")
fuse_labels <- paste0(1:5, "\n(n=", fuse_n$n, ")")
edge2_labels <- paste0(1:5, "\n(n=", edge2_n$n, ")")

# 1. IUCN plot
iucn_plot <- combined_data %>%
  mutate(
    IUCN_status = factor(IUCN_original, levels = 1:5, labels = iucn_order),
    protection_percentage = IUCN_captain * 100
  ) %>%
  ggplot(aes(x = IUCN_status, y = protection_percentage)) +
  geom_jitter(width = 0.1,
              size = 0.4,
              alpha = 0.5,
              color = "darkgray") +
  stat_summary(fun = mean,
               geom = "point",
               size = 3,
               color = "black") +
  stat_summary(fun.data = function(x) {
                 mean_val <- mean(x, na.rm = TRUE)
                 sd_val <- sd(x, na.rm = TRUE)
                 return(data.frame(y = mean_val,
                                   ymin = max(0, mean_val - sd_val),
                                   ymax = min(100, mean_val + sd_val)))
               },
              geom = "errorbar",
              width = 0.1,
              color = "black") +
  labs(
       x = "IUCN Red List threat status",
       y = "Range protected (%)") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 18),
    legend.position = "none",
    panel.grid.major.x = element_blank(),
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "white", color = NA),
    axis.title.x = element_text(size = 16),
    axis.title.y = element_text(size = 16),
    axis.text.x = element_text(size = 14),
    axis.text.y = element_text(size = 14)
  ) +
  scale_x_discrete(limits = iucn_order, labels = iucn_labels) +
  scale_fill_manual(values = iucn_colors) +
  scale_color_manual(values = iucn_colors) +
  scale_y_continuous(limits = c(0, 100),
                     breaks = seq(0, 100, 25))

# 2. FUSE plot
fuse_plot <- combined_data %>%
  mutate(
    FUSE_category = factor(FUSE_original),
    protection_percentage = FUSE_captain * 100
  ) %>%
  ggplot(aes(x = FUSE_category, y = protection_percentage)) +
  geom_jitter(width = 0.1,
              size = 0.4,
              alpha = 0.5,
              color = "darkgray") +
  stat_summary(fun = mean,
               geom = "point",
               size = 3,
               color = "black") +
  stat_summary(fun.data = function(x) {
                 mean_val <- mean(x, na.rm = TRUE)
                 sd_val <- sd(x, na.rm = TRUE)
                 return(data.frame(y = mean_val,
                                   ymin = max(0, mean_val - sd_val),
                                   ymax = min(100, mean_val + sd_val)))
               },
              geom = "errorbar",
              width = 0.1,
              color = "black") +
  labs(
       x = "FUSE Score",
       y = "Range protected (%)") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 18),
    legend.position = "none",
    panel.grid.major.x = element_blank(),
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "white", color = NA),
    axis.title.x = element_text(size = 16),
    axis.title.y = element_text(size = 16),
    axis.text.x = element_text(size = 14),
    axis.text.y = element_text(size = 14)
  ) +
  scale_x_discrete(labels = fuse_labels) +
  scale_y_continuous(limits = c(0, 100),
                     breaks = seq(0, 100, 25))

# 3. EDGE2 plot
edge2_plot <- combined_data %>%
  mutate(
    EDGE2_category = factor(EDGE2_original),
    protection_percentage = EDGE2_captain * 100
  ) %>%
  ggplot(aes(x = EDGE2_category, y = protection_percentage)) +
  geom_jitter(width = 0.1,
              size = 0.4,
              alpha = 0.5,
              color = "darkgray") +
  stat_summary(fun = mean,
               geom = "point",
               size = 3,
               color = "black") +
  stat_summary(fun.data = function(x) {
                 mean_val <- mean(x, na.rm = TRUE)
                 sd_val <- sd(x, na.rm = TRUE)
                 return(data.frame(y = mean_val,
                                   ymin = max(0, mean_val - sd_val),
                                   ymax = min(100, mean_val + sd_val)))
               },
              geom = "errorbar",
              width = 0.1,
              color = "black") +
  labs(
       x = "EDGE2 Score",
       y = "Range protected (%)") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 18),
    legend.position = "none",
    panel.grid.major.x = element_blank(),
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "white", color = NA),
    axis.title.x = element_text(size = 16),
    axis.title.y = element_text(size = 16),
    axis.text.x = element_text(size = 14),
    axis.text.y = element_text(size = 14)
  ) +
  scale_x_discrete(labels = edge2_labels) +
  scale_y_continuous(limits = c(0, 100),
                     breaks = seq(0, 100, 25))

# Display individual plots
print(iucn_plot)
print(fuse_plot)
print(edge2_plot)

# Combine using patchwork
library(ggpubr)
library(here)

# Combine the three plots into a grid with one row and three columns
# Add labels A, B, C
combined_plots <- ggarrange(
  iucn_plot,                          # Plot A
  fuse_plot,                          # Plot B
  edge2_plot,                         # Plot C
  ncol = 3,                           # 3 columns
  nrow = 1,                           # 1 row
  labels = c("(A)", "(B)", "(C)"),    # Add labels to the plots
  font.label = list(size = 14,        # Customize label font size
                    face = "bold",    # Make labels bold
                    hjust = -2,
                    vjust = 1.5)     # Move labels to the left (negative values move left)
)
print(combined_plots)

# Save plots
ggsave(here::here("outputs", "iucn_protection_violin_styled.png"),
       iucn_plot, width = 8, height = 6, dpi = 300, bg = "white")
ggsave(here::here("outputs", "fuse_protection_violin_styled.png"),
       fuse_plot, width = 8, height = 6, dpi = 300, bg = "white")
ggsave(here::here("outputs", "edge2_protection_violin_styled.png"),
       edge2_plot, width = 8, height = 6, dpi = 300, bg = "white")
ggsave(here::here("outputs", "combined_protection_violin_styled.png"),
       combined_plots, width = 20, height = 6, dpi = 150, bg = "white")

# Calculate median, mean and sd protection by FUSE score
fuse_medians <- combined_data %>%
  group_by(FUSE_original) %>%
  summarise(
    n = n(),
    median_protection = median(FUSE_captain * 100),
    mean_protection = mean(FUSE_captain * 100),
    sd_protection = sd(FUSE_captain * 100)
  )

print("Median protection by FUSE score:")
print(fuse_medians)

# Also check for IUCN and EDGE2
iucn_medians <- combined_data %>%
  group_by(IUCN_original) %>%
  summarise(
    n = n(),
    median_protection = median(IUCN_captain * 100),
    mean_protection = mean(IUCN_captain * 100)
  )

edge2_medians <- combined_data %>%
  group_by(EDGE2_original) %>%
  summarise(
    n = n(),
    median_protection = median(EDGE2_captain * 100),
    mean_protection = mean(EDGE2_captain * 100)
  )

print("\nMedian protection by IUCN status:")
print(iucn_medians)

print("\nMedian protection by EDGE2 score:")
print(edge2_medians)

# Test for trend using Jonckheere-Terpstra test (better for ordered categories)
library(clinfun)

jt_fuse <- jonckheere.test(combined_data$FUSE_captain, 
                           combined_data$FUSE_original, 
                           alternative = "increasing")
print("\nJonckheere-Terpstra test for FUSE trend:")
print(jt_fuse)

jt_iucn <- jonckheere.test(combined_data$IUCN_captain, 
                           combined_data$IUCN_original, 
                           alternative = "increasing")
print("\nJonckheere-Terpstra test for IUCN trend:")
print(jt_iucn)

jt_edge2 <- jonckheere.test(combined_data$EDGE2_captain, 
                            combined_data$EDGE2_original, 
                            alternative = "increasing")
print("\nJonckheere-Terpstra test for EDGE2 trend:")
print(jt_edge2)

# Create a nicely formatted table showing the ordered species
species_table <- combined_data %>%
    dplyr::select(Species_captain, Species_original, IUCN_captain, FUSE_captain, EDGE2_captain, 
           IUCN_original, FUSE_original, EDGE2_original) %>%
    arrange(Species_original) %>%
    head(20)  # Just show the first 20 for display
  
  # Print species table
  cat("\nFirst 20 species (alphabetically by original species name):\n")
  print(species_table)
  
  # Save the full combined data
  write.csv(combined_data, here::here("outputs", "combined_species_data.csv"), row.names = FALSE)
  
} else {
  cat("ERROR: Datasets have different number of rows.\n")
  cat("Protected fractions:", nrow(protected_fractions), "rows\n")
  cat("Shark metrics:", nrow(shark_metrics), "rows\n")
}

# Statistical tests for each approach

# 1. IUCN: Spearman correlation between threat status and protection
iucn_correlation <- cor.test(combined_data$IUCN_original, 
                              combined_data$IUCN_captain, 
                              method = "spearman")
print("IUCN threat status vs IUCN protection:")
print(iucn_correlation)

# 2. FUSE: Spearman correlation between FUSE score and protection
fuse_correlation <- cor.test(combined_data$FUSE_original, 
                              combined_data$FUSE_captain, 
                              method = "spearman")
print("FUSE score vs FUSE protection:")
print(fuse_correlation)

# 3. EDGE2: Spearman correlation between EDGE2 score and protection
edge2_correlation <- cor.test(combined_data$EDGE2_original, 
                               combined_data$EDGE2_captain, 
                               method = "spearman")
print("EDGE2 score vs EDGE2 protection:")
print(edge2_correlation)

# Summary table of correlations
correlation_summary <- data.frame(
  Approach = c("IUCN", "FUSE", "EDGE2"),
  Rho = c(iucn_correlation$estimate, 
          fuse_correlation$estimate, 
          edge2_correlation$estimate),
  P_value = c(iucn_correlation$p.value, 
              fuse_correlation$p.value, 
              edge2_correlation$p.value)
)

print("\nCorrelation summary:")
print(correlation_summary)

#
# Cross correlations
cross_correlations <- data.frame(
  Protection_by = character(),
  Correlated_with = character(),
  Rho = numeric(),
  P_value = numeric(),
  stringsAsFactors = FALSE
)

# IUCN protection vs different scores
cross_correlations <- rbind(cross_correlations,
  data.frame(
    Protection_by = "IUCN",
    Correlated_with = c("IUCN_status", "FUSE_score", "EDGE2_score"),
    Rho = c(
      cor(combined_data$IUCN_original, combined_data$IUCN_captain, method = "spearman"),
      cor(combined_data$FUSE_original, combined_data$IUCN_captain, method = "spearman"),
      cor(combined_data$EDGE2_original, combined_data$IUCN_captain, method = "spearman")
    ),
    P_value = c(
      cor.test(combined_data$IUCN_original, combined_data$IUCN_captain, method = "spearman")$p.value,
      cor.test(combined_data$FUSE_original, combined_data$IUCN_captain, method = "spearman")$p.value,
      cor.test(combined_data$EDGE2_original, combined_data$IUCN_captain, method = "spearman")$p.value
    )
  )
)

# FUSE protection vs different scores
cross_correlations <- rbind(cross_correlations,
  data.frame(
    Protection_by = "FUSE",
    Correlated_with = c("IUCN_status", "FUSE_score", "EDGE2_score"),
    Rho = c(
      cor(combined_data$IUCN_original, combined_data$FUSE_captain, method = "spearman"),
      cor(combined_data$FUSE_original, combined_data$FUSE_captain, method = "spearman"),
      cor(combined_data$EDGE2_original, combined_data$FUSE_captain, method = "spearman")
    ),
    P_value = c(
      cor.test(combined_data$IUCN_original, combined_data$FUSE_captain, method = "spearman")$p.value,
      cor.test(combined_data$FUSE_original, combined_data$FUSE_captain, method = "spearman")$p.value,
      cor.test(combined_data$EDGE2_original, combined_data$FUSE_captain, method = "spearman")$p.value
    )
  )
)

# EDGE2 protection vs different scores
cross_correlations <- rbind(cross_correlations,
  data.frame(
    Protection_by = "EDGE2",
    Correlated_with = c("IUCN_status", "FUSE_score", "EDGE2_score"),
    Rho = c(
      cor(combined_data$IUCN_original, combined_data$EDGE2_captain, method = "spearman"),
      cor(combined_data$FUSE_original, combined_data$EDGE2_captain, method = "spearman"),
      cor(combined_data$EDGE2_original, combined_data$EDGE2_captain, method = "spearman")
    ),
    P_value = c(
      cor.test(combined_data$IUCN_original, combined_data$EDGE2_captain, method = "spearman")$p.value,
      cor.test(combined_data$FUSE_original, combined_data$EDGE2_captain, method = "spearman")$p.value,
      cor.test(combined_data$EDGE2_original, combined_data$EDGE2_captain, method = "spearman")$p.value
    )
  )
)

print("Cross-correlation matrix:")
print(cross_correlations)

# Reshape for easier visualization
cross_corr_wide <- cross_correlations %>%
  select(Protection_by, Correlated_with, Rho) %>%
  pivot_wider(names_from = Correlated_with, values_from = Rho)

print("\nCross-correlation matrix (wide format):")
print(cross_corr_wide)

#Linear models for each approach :
# Load required packages
library(dplyr)
library(lme4)
library(lmerTest)  # For p-values
library(car)       # For diagnostics

# Prepare data with protection as percentage
model_data <- combined_data %>%
  mutate(
    IUCN_status = IUCN_original,
    FUSE_score = FUSE_original,
    EDGE2_score = EDGE2_original,
    IUCN_protection = IUCN_captain * 100,
    FUSE_protection = FUSE_captain * 100,
    EDGE2_protection = EDGE2_captain * 100
  )

# Model 1: IUCN protection ~ IUCN status (ordinal predictor)
iucn_lm <- lm(IUCN_protection ~ IUCN_status, data = model_data)
summary(iucn_lm)

# Model 2: FUSE protection ~ FUSE score (ordinal predictor)
fuse_lm <- lm(FUSE_protection ~ FUSE_score, data = model_data)
summary(fuse_lm)

# Model 3: EDGE2 protection ~ EDGE2 score (ordinal predictor)
edge2_lm <- lm(EDGE2_protection ~ EDGE2_score, data = model_data)
summary(edge2_lm)

# Create summary table
model_summary <- data.frame(
  Approach = c("IUCN", "FUSE", "EDGE2"),
  Slope = c(
    coef(iucn_lm)[2],
    coef(fuse_lm)[2],
    coef(edge2_lm)[2]
  ),
  SE = c(
    summary(iucn_lm)$coefficients[2, 2],
    summary(fuse_lm)$coefficients[2, 2],
    summary(edge2_lm)$coefficients[2, 2]
  ),
  t_value = c(
    summary(iucn_lm)$coefficients[2, 3],
    summary(fuse_lm)$coefficients[2, 3],
    summary(edge2_lm)$coefficients[2, 3]
  ),
  P_value = c(
    summary(iucn_lm)$coefficients[2, 4],
    summary(fuse_lm)$coefficients[2, 4],
    summary(edge2_lm)$coefficients[2, 4]
  ),
  R_squared = c(
    summary(iucn_lm)$r.squared,
    summary(fuse_lm)$r.squared,
    summary(edge2_lm)$r.squared
  ),
  Adj_R_squared = c(
    summary(iucn_lm)$adj.r.squared,
    summary(fuse_lm)$adj.r.squared,
    summary(edge2_lm)$adj.r.squared
  )
)

print("Linear model summary (ordinal predictors):")
print(model_summary)

# Check model diagnostics
par(mfrow = c(3, 2))
plot(iucn_lm, which = 1:2, main = "IUCN")
plot(fuse_lm, which = 1:2, main = "FUSE")
plot(edge2_lm, which = 1:2, main = "EDGE2")

# Check residual normality
shapiro.test(residuals(iucn_lm))
shapiro.test(residuals(fuse_lm))
shapiro.test(residuals(edge2_lm))

#The Shapiro-Wilk tests show highly significant departures from normality (all p < 2.2e-16) for all three models, indicating clear violations of the normality assumption. This suggests you should use an alternative modeling approach.

# Test for heteroscedasticity (Breusch-Pagan test)
library(lmtest)
print("\nBreusch-Pagan test for heteroscedasticity:")
print("IUCN:")
print(bptest(iucn_lm))
print("FUSE:")
print(bptest(fuse_lm))
print("EDGE2:")
print(bptest(edge2_lm))

# Visualize model fits
library(ggplot2)

# IUCN fit plot
iucn_fit_plot <- ggplot(model_data, aes(x = IUCN_status, y = IUCN_protection)) +
  geom_jitter(width = 0.1, alpha = 0.3, color = "darkgray") +
  geom_smooth(method = "lm", color = "red", se = TRUE) +
  labs(title = "IUCN: Linear Model Fit",
       x = "IUCN Status",
       y = "Protection (%)") +
  theme_minimal()

# FUSE fit plot
fuse_fit_plot <- ggplot(model_data, aes(x = FUSE_score, y = FUSE_protection)) +
  geom_jitter(width = 0.1, alpha = 0.3, color = "darkgray") +
  geom_smooth(method = "lm", color = "red", se = TRUE) +
  labs(title = "FUSE: Linear Model Fit",
       x = "FUSE Score",
       y = "Protection (%)") +
  theme_minimal()

# EDGE2 fit plot
edge2_fit_plot <- ggplot(model_data, aes(x = EDGE2_score, y = EDGE2_protection)) +
  geom_jitter(width = 0.1, alpha = 0.3, color = "darkgray") +
  geom_smooth(method = "lm", color = "red", se = TRUE) +
  labs(title = "EDGE2: Linear Model Fit",
       x = "EDGE2 Score",
       y = "Protection (%)") +
  theme_minimal()

print(iucn_fit_plot)
print(fuse_fit_plot)
print(edge2_fit_plot)

# Save results
write.csv(model_summary, 
          here::here("outputs", "linear_model_summary.csv"), 
          row.names = FALSE)

# Save plots
ggsave(here::here("outputs", "iucn_model_fit.png"),
       iucn_fit_plot, width = 8, height = 6, dpi = 300)
ggsave(here::here("outputs", "fuse_model_fit.png"),
       fuse_fit_plot, width = 8, height = 6, dpi = 300)
ggsave(here::here("outputs", "edge2_model_fit.png"),
       edge2_fit_plot, width = 8, height = 6, dpi = 300)

#Beta regression 

# Install and load required package
install.packages("betareg")
library(betareg)

# Prepare data for beta regression
# Beta regression requires values in (0,1) interval, excluding 0 and 1
# Use Smithson & Verkuilen (2006) transformation for boundary cases
model_data <- model_data %>%
  mutate(
    # Convert to (0,1) scale and handle boundaries
    n_obs = n(),
    IUCN_protection_beta = (IUCN_protection/100 * (n_obs - 1) + 0.5) / n_obs,
    FUSE_protection_beta = (FUSE_protection/100 * (n_obs - 1) + 0.5) / n_obs,
    EDGE2_protection_beta = (EDGE2_protection/100 * (n_obs - 1) + 0.5) / n_obs
  )

# Fit beta regression models
iucn_beta <- betareg(IUCN_protection_beta ~ IUCN_status, data = model_data)
fuse_beta <- betareg(FUSE_protection_beta ~ FUSE_score, data = model_data)
edge2_beta <- betareg(EDGE2_protection_beta ~ EDGE2_score, data = model_data)

# View summaries
summary(iucn_beta)
summary(fuse_beta)
summary(edge2_beta)

# Extract key statistics
# Note: Beta regression uses pseudo-R¬≤ (squared correlation between fitted and observed)
library(broom)

# Get tidy summaries
iucn_tidy <- tidy(iucn_beta)
fuse_tidy <- tidy(fuse_beta)
edge2_tidy <- tidy(edge2_beta)

# Get pseudo R¬≤
iucn_r2 <- cor(predict(iucn_beta), model_data$IUCN_protection_beta)^2
fuse_r2 <- cor(predict(fuse_beta), model_data$FUSE_protection_beta)^2
edge2_r2 <- cor(predict(edge2_beta), model_data$EDGE2_protection_beta)^2

# Create summary table
beta_summary <- data.frame(
  Approach = c("IUCN", "FUSE", "EDGE2"),
  Coefficient = c(
    iucn_tidy$estimate[2],
    fuse_tidy$estimate[2],
    edge2_tidy$estimate[2]
  ),
  SE = c(
    iucn_tidy$std.error[2],
    fuse_tidy$std.error[2],
    edge2_tidy$std.error[2]
  ),
  z_value = c(
    iucn_tidy$statistic[2],
    fuse_tidy$statistic[2],
    edge2_tidy$statistic[2]
  ),
  P_value = c(
    iucn_tidy$p.value[2],
    fuse_tidy$p.value[2],
    edge2_tidy$p.value[2]
  ),
  Pseudo_R2 = c(iucn_r2, fuse_r2, edge2_r2)
)

print("Beta regression summary:")
print(beta_summary)

# Calculate marginal effects (average change in percentage per unit increase)
library(margins)

# Get marginal effects
iucn_margins <- margins(iucn_beta)
fuse_margins <- margins(fuse_beta)
edge2_margins <- margins(edge2_beta)

# Summary of marginal effects
print("IUCN marginal effects:")
summary(iucn_margins)

print("FUSE marginal effects:")
summary(fuse_margins)

print("EDGE2 marginal effects:")
summary(edge2_margins)

# Alternative: Calculate predicted values and differences manually
# This gives you the actual percentage change per category

# IUCN predictions
iucn_pred <- predict(iucn_beta, 
                     newdata = data.frame(IUCN_status = 1:5),
                     type = "response") * 100
print("Predicted protection by IUCN category:")
print(data.frame(Category = 1:5, 
                 IUCN_Category = c("LC", "NT", "VU", "EN", "CR"),
                 Predicted_Protection = round(iucn_pred, 2)))

# Average increase per category
iucn_avg_increase <- mean(diff(iucn_pred))
print(paste("Average increase per IUCN category:", round(iucn_avg_increase, 2), "%"))

# FUSE predictions
fuse_pred <- predict(fuse_beta, 
                     newdata = data.frame(FUSE_score = 1:5),
                     type = "response") * 100
print("Predicted protection by FUSE score:")
print(data.frame(Score = 1:5, 
                 Predicted_Protection = round(fuse_pred, 2)))

# Average increase per unit
fuse_avg_increase <- mean(diff(fuse_pred))
print(paste("Average increase per FUSE unit:", round(fuse_avg_increase, 2), "%"))

# EDGE2 predictions
edge2_pred <- predict(edge2_beta, 
                      newdata = data.frame(EDGE2_score = 1:5),
                      type = "response") * 100
print("Predicted protection by EDGE2 score:")
print(data.frame(Score = 1:5, 
                 Predicted_Protection = round(edge2_pred, 2)))

# Average increase per unit
edge2_avg_increase <- mean(diff(edge2_pred))
print(paste("Average increase per EDGE2 unit:", round(edge2_avg_increase, 2), "%"))

# Create comprehensive summary table
comprehensive_summary <- data.frame(
  Approach = c("IUCN", "FUSE", "EDGE2"),
  Coefficient_logit = c(
    iucn_tidy$estimate[2],
    fuse_tidy$estimate[2],
    edge2_tidy$estimate[2]
  ),
  SE = c(
    iucn_tidy$std.error[2],
    fuse_tidy$std.error[2],
    edge2_tidy$std.error[2]
  ),
  z_value = c(
    iucn_tidy$statistic[2],
    fuse_tidy$statistic[2],
    edge2_tidy$statistic[2]
  ),
  P_value = c(
    iucn_tidy$p.value[2],
    fuse_tidy$p.value[2],
    edge2_tidy$p.value[2]
  ),
  Avg_percent_increase = c(
    iucn_avg_increase,
    fuse_avg_increase,
    edge2_avg_increase
  ),
  Pseudo_R2 = c(iucn_r2, fuse_r2, edge2_r2)
)

print("Comprehensive beta regression summary:")
print(comprehensive_summary)

```

Linear regression models examining the relationship between biodiversity metric scores and species-level protection revealed significant but modest effects (Table X). IUCN-based prioritisation showed a significant positive relationship with threat status (slope = 3.25% per category, SE = 0.77, p < 0.001, R¬≤ = 0.018), with species gaining an average of 3.25 percentage points of additional range protection for each increase in threat category. EDGE2-based prioritisation demonstrated the strongest targeting effect (slope = 12.14% per score unit, SE = 2.14, p < 0.001, R¬≤ = 0.031), with evolutionarily distinct species receiving substantially higher protection. In contrast, FUSE-based prioritisation showed no significant relationship with functional uniqueness scores (slope = 2.71% per unit, SE = 1.72, p = 0.116, R¬≤ = 0.002), likely reflecting the highly skewed distribution of functional scores with 89.4% of species in the lowest category. The modest R¬≤ values (1.8-3.1%) reflect the substantial influence of species' geographic distributions and spatial optimization dynamics on protection outcomes, with biodiversity metrics explaining a meaningful but limited portion of variance in species-level protection beyond biogeographic factors.

## Best-Approach Assignment Analysis

To identify which prioritisation approach provided the highest protection for each species and to examine whether species characteristics differed based on which approach performed best, we conducted a best-approach assignment analysis.

For each species, we identified the approach (IUCN, FUSE, or EDGE2) that resulted in the maximum fraction of range protected. Species were classified into categories based on whether a single approach provided the best protection, multiple approaches were tied for best, or all three approaches performed equally. We then calculated "protection gaps" for each species‚Äîthe difference between the maximum protection achieved and the protection provided by each non-optimal approach‚Äîto quantify how much protection species would lose if their best-performing approach were not implemented.

To test whether species with different characteristics were best protected by different approaches, we examined the distribution of IUCN threat status, FUSE scores, and EDGE2 scores among species best protected by each approach. For IUCN threat status, we used a chi-square test to determine whether threatened species (Vulnerable, Endangered, or Critically Endangered) were disproportionately best protected by particular approaches. For FUSE and EDGE2 scores, we used Kruskal-Wallis rank sum tests to assess whether species best protected by different approaches differed significantly in their functional uniqueness or evolutionary distinctiveness scores. Kruskal-Wallis tests were selected due to the ordinal nature of FUSE and EDGE2 scores and non-normal distributions.

Species tied for best protection across multiple approaches were excluded from the comparative analyses to ensure clear attribution of protection performance to specific prioritisation frameworks. All statistical tests were performed at Œ± = 0.05 significance level. Analyses were conducted in R (version 4.4.2; R Core Team 2024) using the dplyr, tidyr, and ggplot2 packages.

```{r}
# Analysis 1: Best-Approach Assignment
library(here)
library(dplyr)
library(tidyr)
library(ggplot2)

# Identify which approach gives best protection for each species
best_approach_analysis <- combined_data %>%
  mutate(
    # Find maximum protection across the three approaches
    max_protection = pmax(IUCN_captain, FUSE_captain, EDGE2_captain),
    
    # Identify which approach(es) provide the maximum protection
    best_IUCN = (IUCN_captain == max_protection),
    best_FUSE = (FUSE_captain == max_protection),
    best_EDGE2 = (EDGE2_captain == max_protection),
    
    # Count how many approaches are tied for best
    n_best = as.integer(best_IUCN) + as.integer(best_FUSE) + as.integer(best_EDGE2),
    
    # Classify species by their best approach(es)
    best_approach = case_when(
      n_best == 3 ~ "All tied",
      n_best == 2 & best_IUCN & best_FUSE ~ "IUCN + FUSE tied",
      n_best == 2 & best_IUCN & best_EDGE2 ~ "IUCN + EDGE2 tied",
      n_best == 2 & best_FUSE & best_EDGE2 ~ "FUSE + EDGE2 tied",
      best_IUCN ~ "IUCN best",
      best_FUSE ~ "FUSE best",
      best_EDGE2 ~ "EDGE2 best",
      TRUE ~ "Error"
    ),
    
    # Calculate protection differences (how much better is the best vs others)
    IUCN_gap = max_protection - IUCN_captain,
    FUSE_gap = max_protection - FUSE_captain,
    EDGE2_gap = max_protection - EDGE2_captain
  )

# Summary statistics
best_approach_summary <- best_approach_analysis %>%
  count(best_approach) %>%
  mutate(percentage = (n / nrow(combined_data)) * 100) %>%
  arrange(desc(n))

print("Summary: Which approach provides best protection?")
print(best_approach_summary)

# For species with a single best approach, examine their characteristics
# First, create simplified categories for clearer analysis
best_approach_simple <- best_approach_analysis %>%
  mutate(
    best_single = case_when(
      best_approach == "IUCN best" ~ "IUCN",
      best_approach == "FUSE best" ~ "FUSE",
      best_approach == "EDGE2 best" ~ "EDGE2",
      TRUE ~ "Tied/Multiple"
    )
  )

# Test 1: Does IUCN threat status differ by which approach is best?
iucn_by_best <- best_approach_simple %>%
  filter(best_single != "Tied/Multiple") %>%
  group_by(best_single) %>%
  summarise(
    n = n(),
    mean_IUCN_status = mean(IUCN_original, na.rm = TRUE),
    median_IUCN_status = median(IUCN_original, na.rm = TRUE),
    LC_count = sum(IUCN_original == 1),
    NT_count = sum(IUCN_original == 2),
    VU_count = sum(IUCN_original == 3),
    EN_count = sum(IUCN_original == 4),
    CR_count = sum(IUCN_original == 5)
  )

print("\nIUCN threat status by best approach:")
print(iucn_by_best)

# Chi-square test: Are threatened species disproportionately best-protected by certain approaches?
contingency_table <- best_approach_simple %>%
  filter(best_single != "Tied/Multiple") %>%
  mutate(
    threatened = ifelse(IUCN_original >= 3, "Threatened", "Not threatened")
  ) %>%
  count(best_single, threatened) %>%
  pivot_wider(names_from = threatened, values_from = n, values_fill = 0)

print("\nContingency table: Threatened vs Not threatened by best approach:")
print(contingency_table)

if(nrow(contingency_table) > 1) {
  chi_test <- chisq.test(contingency_table[, -1])
  print("\nChi-square test (threatened vs best approach):")
  print(chi_test)
}

# Test 2: Does functional uniqueness (FUSE score) differ by which approach is best?
fuse_by_best <- best_approach_simple %>%
  filter(best_single != "Tied/Multiple") %>%
  group_by(best_single) %>%
  summarise(
    n = n(),
    mean_FUSE_score = mean(FUSE_original, na.rm = TRUE),
    median_FUSE_score = median(FUSE_original, na.rm = TRUE),
    sd_FUSE_score = sd(FUSE_original, na.rm = TRUE)
  )

print("\nFUSE scores by best approach:")
print(fuse_by_best)

# Kruskal-Wallis test for FUSE scores
if(length(unique(best_approach_simple$best_single[best_approach_simple$best_single != "Tied/Multiple"])) > 1) {
  kw_fuse <- kruskal.test(FUSE_original ~ best_single, 
                          data = filter(best_approach_simple, best_single != "Tied/Multiple"))
  print("\nKruskal-Wallis test (FUSE scores by best approach):")
  print(kw_fuse)
}

# Test 3: Does evolutionary distinctiveness (EDGE2 score) differ by which approach is best?
edge2_by_best <- best_approach_simple %>%
  filter(best_single != "Tied/Multiple") %>%
  group_by(best_single) %>%
  summarise(
    n = n(),
    mean_EDGE2_score = mean(EDGE2_original, na.rm = TRUE),
    median_EDGE2_score = median(EDGE2_original, na.rm = TRUE),
    sd_EDGE2_score = sd(EDGE2_original, na.rm = TRUE)
  )

print("\nEDGE2 scores by best approach:")
print(edge2_by_best)

# Kruskal-Wallis test for EDGE2 scores
if(length(unique(best_approach_simple$best_single[best_approach_simple$best_single != "Tied/Multiple"])) > 1) {
  kw_edge2 <- kruskal.test(EDGE2_original ~ best_single, 
                           data = filter(best_approach_simple, best_single != "Tied/Multiple"))
  print("\nKruskal-Wallis test (EDGE2 scores by best approach):")
  print(kw_edge2)
}

# Visualization 1: Stacked bar chart of best approach
best_approach_plot <- ggplot(best_approach_summary, 
                              aes(x = "", y = percentage, fill = best_approach)) +
  geom_bar(stat = "identity", width = 1) +
  coord_flip() +
  labs(
    title = "Which Prioritisation Approach Provides Best Protection?",
    y = "Percentage of species (%)",
    x = "",
    fill = "Best approach"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    legend.position = "right"
  ) +
  scale_fill_brewer(palette = "Set2")

print(best_approach_plot)

# Visualization 2: Protection gaps for species NOT best protected by each approach
protection_gaps <- best_approach_analysis %>%
  select(Species_original, IUCN_original, FUSE_original, EDGE2_original,
         best_approach, IUCN_gap, FUSE_gap, EDGE2_gap, max_protection) %>%
  pivot_longer(cols = c(IUCN_gap, FUSE_gap, EDGE2_gap),
               names_to = "gap_type",
               values_to = "protection_gap") %>%
  mutate(
    gap_type = gsub("_gap", "", gap_type),
    protection_gap_pct = protection_gap * 100
  )

gap_plot <- ggplot(filter(protection_gaps, protection_gap > 0), 
                    aes(x = gap_type, y = protection_gap_pct)) +
  geom_violin(fill = "lightblue", alpha = 0.6) +
  geom_boxplot(width = 0.1, outlier.shape = NA) +
  labs(
    title = "Protection Gaps: How Much Species Miss When Not Using Best Approach",
    x = "Prioritisation Approach",
    y = "Protection gap (%)",
    subtitle = "Gap = (Best protection) - (This approach's protection)"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5)
  )

print(gap_plot)

# Save outputs
ggsave(here::here("outputs", "best_approach_distribution.png"),
       best_approach_plot, width = 10, height = 6, dpi = 300)

ggsave(here::here("outputs", "protection_gaps.png"),
       gap_plot, width = 10, height = 6, dpi = 300)

write.csv(best_approach_analysis, 
          here::here("outputs", "best_approach_full_data.csv"), 
          row.names = FALSE)

write.csv(best_approach_summary, 
          here::here("outputs", "best_approach_summary.csv"), 
          row.names = FALSE)
```

## Coverage Accumulation Analysis

To evaluate whether combining multiple prioritisation approaches provided additive conservation value beyond single-metric strategies, we conducted a coverage accumulation analysis examining species-level protection adequacy across different implementation scenarios.

We first defined an adequate protection threshold of 10% of species range, representing a minimum viable protection target. For each prioritisation approach independently (IUCN, FUSE, EDGE2), we calculated the number and percentage of species achieving this threshold. 

We then simulated three sequential implementation scenarios to assess the marginal gains from adding additional prioritisation frameworks:

1. **Scenario A (IUCN ‚Üí FUSE ‚Üí EDGE2)**: Beginning with IUCN prioritisation, then adding areas prioritised by FUSE, followed by EDGE2
2. **Scenario B (FUSE ‚Üí EDGE2 ‚Üí IUCN)**: Beginning with FUSE prioritisation, then adding EDGE2, followed by IUCN  
3. **Scenario C (EDGE2 ‚Üí IUCN ‚Üí FUSE)**: Beginning with EDGE2 prioritisation, then adding IUCN, followed by FUSE

For each scenario, we calculated the cumulative number of species achieving adequate protection (‚â•10% range) at each implementation step. A species was considered adequately protected if it met the threshold under any of the approaches implemented up to that step. We quantified marginal gains as the additional number of species reaching adequate protection when each successive approach was added.

Additionally, we characterised species-level protection patterns by classifying each species according to which combination of approaches provided adequate protection: all three approaches, any pairwise combination, single approach only, or none. This classification identified species benefiting from multiple approaches versus those dependent on specific prioritisation frameworks.

All analyses were performed in R (version 4.4.2; R Core Team 2024) using the dplyr, tidyr, and ggplot2 packages.

```{r}
# Coverage Accumulation Analysis
library(here)
library(dplyr)
library(tidyr)
library(ggplot2)

# Assuming you have the combined_data from your script above

# Define adequate protection threshold (e.g., 10% of range)
protection_threshold <- 0.10

# Analysis 1: Single approach coverage
single_approach_coverage <- combined_data %>%
  summarise(
    IUCN_adequate = sum(IUCN_captain >= protection_threshold),
    FUSE_adequate = sum(FUSE_captain >= protection_threshold),
    EDGE2_adequate = sum(EDGE2_captain >= protection_threshold),
    total_species = n()
  ) %>%
  mutate(
    IUCN_pct = (IUCN_adequate / total_species) * 100,
    FUSE_pct = (FUSE_adequate / total_species) * 100,
    EDGE2_pct = (EDGE2_adequate / total_species) * 100
  )

print("Single approach coverage:")
print(single_approach_coverage)

# Analysis 2: Sequential implementation scenarios
# Scenario A: IUCN ‚Üí IUCN+FUSE ‚Üí IUCN+FUSE+EDGE2
scenario_a <- combined_data %>%
  mutate(
    step1_IUCN = IUCN_captain >= protection_threshold,
    step2_IUCN_FUSE = (IUCN_captain >= protection_threshold) | 
                      (FUSE_captain >= protection_threshold),
    step3_all = (IUCN_captain >= protection_threshold) | 
                (FUSE_captain >= protection_threshold) |
                (EDGE2_captain >= protection_threshold)
  ) %>%
  summarise(
    step1 = sum(step1_IUCN),
    step2 = sum(step2_IUCN_FUSE),
    step3 = sum(step3_all)
  )

# Scenario B: FUSE ‚Üí FUSE+EDGE2 ‚Üí FUSE+EDGE2+IUCN
scenario_b <- combined_data %>%
  mutate(
    step1_FUSE = FUSE_captain >= protection_threshold,
    step2_FUSE_EDGE2 = (FUSE_captain >= protection_threshold) | 
                       (EDGE2_captain >= protection_threshold),
    step3_all = (FUSE_captain >= protection_threshold) | 
                (EDGE2_captain >= protection_threshold) |
                (IUCN_captain >= protection_threshold)
  ) %>%
  summarise(
    step1 = sum(step1_FUSE),
    step2 = sum(step2_FUSE_EDGE2),
    step3 = sum(step3_all)
  )

# Scenario C: EDGE2 ‚Üí EDGE2+IUCN ‚Üí EDGE2+IUCN+FUSE
scenario_c <- combined_data %>%
  mutate(
    step1_EDGE2 = EDGE2_captain >= protection_threshold,
    step2_EDGE2_IUCN = (EDGE2_captain >= protection_threshold) | 
                       (IUCN_captain >= protection_threshold),
    step3_all = (EDGE2_captain >= protection_threshold) | 
                (IUCN_captain >= protection_threshold) |
                (FUSE_captain >= protection_threshold)
  ) %>%
  summarise(
    step1 = sum(step1_EDGE2),
    step2 = sum(step2_EDGE2_IUCN),
    step3 = sum(step3_all)
  )

# Combine scenarios into a single dataframe for plotting
accumulation_data <- data.frame(
  step = rep(1:3, 3),
  scenario = rep(c("IUCN‚ÜíFUSE‚ÜíEDGE2", "FUSE‚ÜíEDGE2‚ÜíIUCN", "EDGE2‚ÜíIUCN‚ÜíFUSE"), each = 3),
  species_count = c(
    scenario_a$step1, scenario_a$step2, scenario_a$step3,
    scenario_b$step1, scenario_b$step2, scenario_b$step3,
    scenario_c$step1, scenario_c$step2, scenario_c$step3
  )
) %>%
  mutate(
    percentage = (species_count / nrow(combined_data)) * 100
  )

# Plot accumulation curves
accumulation_plot <- ggplot(accumulation_data, aes(x = step, y = percentage, 
                                                     color = scenario, group = scenario)) +
  geom_line(linewidth = 1.2) +
  geom_point(size = 3) +
  scale_x_continuous(breaks = 1:3, labels = c("First\napproach", "Second\napproach", "All three\napproaches")) +
  scale_y_continuous(limits = c(0, 100), breaks = seq(0, 100, 20)) +
  labs(
    title = "Sequential Implementation of Conservation Approaches",
    subtitle = paste0("Species achieving ‚â•", protection_threshold * 100, "% range protection"),
    x = "Implementation Step",
    y = "Species with adequate protection (%)",
    color = "Implementation\nSequence"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5),
    legend.position = "right"
  )

print(accumulation_plot)

# Analysis 3: Marginal gains from adding each approach
marginal_gains <- accumulation_data %>%
  group_by(scenario) %>%
  arrange(step) %>%
  mutate(
    marginal_gain = species_count - lag(species_count, default = 0),
    marginal_pct = (marginal_gain / nrow(combined_data)) * 100
  )

print("Marginal gains by adding each approach:")
print(marginal_gains)

# Analysis 4: Identify species only protected by multi-approach strategy
species_protection_profile <- combined_data %>%
  mutate(
    IUCN_adequate = IUCN_captain >= protection_threshold,
    FUSE_adequate = FUSE_captain >= protection_threshold,
    EDGE2_adequate = EDGE2_captain >= protection_threshold,
    any_adequate = IUCN_adequate | FUSE_adequate | EDGE2_adequate,
    multiple_adequate = (as.integer(IUCN_adequate) + 
                         as.integer(FUSE_adequate) + 
                         as.integer(EDGE2_adequate)) >= 2,
    protection_pattern = case_when(
      IUCN_adequate & FUSE_adequate & EDGE2_adequate ~ "All three",
      IUCN_adequate & FUSE_adequate ~ "IUCN + FUSE",
      IUCN_adequate & EDGE2_adequate ~ "IUCN + EDGE2",
      FUSE_adequate & EDGE2_adequate ~ "FUSE + EDGE2",
      IUCN_adequate ~ "IUCN only",
      FUSE_adequate ~ "FUSE only",
      EDGE2_adequate ~ "EDGE2 only",
      TRUE ~ "None"
    )
  )

protection_summary <- species_protection_profile %>%
  count(protection_pattern) %>%
  mutate(percentage = (n / nrow(combined_data)) * 100) %>%
  arrange(desc(n))

print("Species protection patterns:")
print(protection_summary)

# Save outputs
ggsave(here::here("outputs", "coverage_accumulation_plot.png"),
       accumulation_plot, width = 10, height = 6, dpi = 300)

write.csv(accumulation_data, 
          here::here("outputs", "accumulation_analysis.csv"), 
          row.names = FALSE)

write.csv(protection_summary, 
          here::here("outputs", "protection_patterns.csv"), 
          row.names = FALSE)

write.csv(species_protection_profile %>% 
            select(Species_original, IUCN_captain, FUSE_captain, EDGE2_captain,
                   IUCN_adequate, FUSE_adequate, EDGE2_adequate, 
                   protection_pattern), 
          here::here("outputs", "species_protection_profiles.csv"), 
          row.names = FALSE)
```

## Correlation Analysis

## Species-Level Complementarity Analysis

To assess the degree of complementarity versus redundancy among the three prioritisation approaches at the species level, we conducted correlation and overlap analyses using the fraction of each species' range protected under each approach.

### Protection Level Correlations

We calculated pairwise Spearman rank correlations between the protection levels (fraction of range protected) achieved by each species under the three approaches (IUCN, FUSE, and EDGE2). Spearman correlations were used due to non-normal distributions of protection values. We classified the degree of complementarity based on correlation coefficients: Rho > 0.7 indicated substitutive (redundant) approaches that protect largely the same species; Rho < 0.5 indicated additive (complementary) approaches that protect substantially different species; and 0.5 ‚â§ Rho ‚â§ 0.7 indicated moderate overlap. All correlations were tested for statistical significance using the cor.test function in R.

### Quantile Overlap Analysis

To examine whether the approaches agreed on which species required the most and least protection, we conducted quantile overlap analyses. For each approach, we identified species in the top 20% (80th percentile and above) and bottom 20% (20th percentile and below) of protection levels. We then quantified the overlap among approaches by calculating:

1. The number of species appearing in the top 20% for all three approaches simultaneously
2. The number of species uniquely appearing in the top 20% for only one approach
3. The number of species appearing in pairwise combinations

This analysis revealed the extent to which different approaches prioritised different species assemblages for protection. A high degree of overlap in the top 20% would indicate redundancy (approaches protect the same species), whilst low overlap would indicate complementarity (approaches protect different species). The same analysis was conducted for species in the bottom 20% to identify conservation gaps‚Äîspecies consistently receiving low protection regardless of the approach used.

All analyses were conducted in R (version 4.4.2; R Core Team 2024) using the dplyr and ggplot2 packages for data manipulation and visualisation.

```{r}
# Analysis 3: Correlation between protection levels across approaches
library(here)
library(dplyr)
library(ggplot2)
library(tidyr)

# Calculate pairwise Spearman correlations between protection levels
correlation_results <- data.frame(
  Comparison = character(),
  Spearman_Rho = numeric(),
  P_value = numeric(),
  Interpretation = character(),
  stringsAsFactors = FALSE
)

# IUCN vs FUSE protection
iucn_fuse_cor <- cor.test(combined_data$IUCN_captain, 
                          combined_data$FUSE_captain, 
                          method = "spearman")

correlation_results <- rbind(correlation_results, data.frame(
  Comparison = "IUCN vs FUSE",
  Spearman_Rho = iucn_fuse_cor$estimate,
  P_value = iucn_fuse_cor$p.value,
  Interpretation = ifelse(iucn_fuse_cor$estimate > 0.7, "Substitutive (redundant)",
                          ifelse(iucn_fuse_cor$estimate < 0.5, "Additive (complementary)", 
                                 "Moderate overlap"))
))

# IUCN vs EDGE2 protection
iucn_edge2_cor <- cor.test(combined_data$IUCN_captain, 
                           combined_data$EDGE2_captain, 
                           method = "spearman")

correlation_results <- rbind(correlation_results, data.frame(
  Comparison = "IUCN vs EDGE2",
  Spearman_Rho = iucn_edge2_cor$estimate,
  P_value = iucn_edge2_cor$p.value,
  Interpretation = ifelse(iucn_edge2_cor$estimate > 0.7, "Substitutive (redundant)",
                          ifelse(iucn_edge2_cor$estimate < 0.5, "Additive (complementary)", 
                                 "Moderate overlap"))
))

# FUSE vs EDGE2 protection
fuse_edge2_cor <- cor.test(combined_data$FUSE_captain, 
                           combined_data$EDGE2_captain, 
                           method = "spearman")

correlation_results <- rbind(correlation_results, data.frame(
  Comparison = "FUSE vs EDGE2",
  Spearman_Rho = fuse_edge2_cor$estimate,
  P_value = fuse_edge2_cor$p.value,
  Interpretation = ifelse(fuse_edge2_cor$estimate > 0.7, "Substitutive (redundant)",
                          ifelse(fuse_edge2_cor$estimate < 0.5, "Additive (complementary)", 
                                 "Moderate overlap"))
))

print("Pairwise correlations between protection levels:")
print(correlation_results)

# Visualization: Individual scatterplots with trend lines
# IUCN vs FUSE
p1 <- ggplot(combined_data, aes(x = IUCN_captain * 100, y = FUSE_captain * 100)) +
  geom_point(alpha = 0.3, size = 1) +
  geom_smooth(method = "lm", color = "red", se = TRUE) +
  labs(
    title = "IUCN vs FUSE Protection",
    subtitle = paste0("Spearman œÅ = ", round(iucn_fuse_cor$estimate, 3), 
                     ", p < 0.001"),
    x = "IUCN Protection (%)",
    y = "FUSE Protection (%)"
  ) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        plot.subtitle = element_text(hjust = 0.5))

# IUCN vs EDGE2
p2 <- ggplot(combined_data, aes(x = IUCN_captain * 100, y = EDGE2_captain * 100)) +
  geom_point(alpha = 0.3, size = 1) +
  geom_smooth(method = "lm", color = "red", se = TRUE) +
  labs(
    title = "IUCN vs EDGE2 Protection",
    subtitle = paste0("Spearman œÅ = ", round(iucn_edge2_cor$estimate, 3), 
                     ", p < 0.001"),
    x = "IUCN Protection (%)",
    y = "EDGE2 Protection (%)"
  ) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        plot.subtitle = element_text(hjust = 0.5))

# FUSE vs EDGE2
p3 <- ggplot(combined_data, aes(x = FUSE_captain * 100, y = EDGE2_captain * 100)) +
  geom_point(alpha = 0.3, size = 1) +
  geom_smooth(method = "lm", color = "red", se = TRUE) +
  labs(
    title = "FUSE vs EDGE2 Protection",
    subtitle = paste0("Spearman œÅ = ", round(fuse_edge2_cor$estimate, 3), 
                     ", p < 0.001"),
    x = "FUSE Protection (%)",
    y = "EDGE2 Protection (%)"
  ) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        plot.subtitle = element_text(hjust = 0.5))

print(p1)
print(p2)
print(p3)

# Additional analysis: Agreement in extreme values
# Species in top 20% vs bottom 20% protection
quantile_analysis <- combined_data %>%
  mutate(
    IUCN_top20 = IUCN_captain >= quantile(IUCN_captain, 0.8),
    IUCN_bottom20 = IUCN_captain <= quantile(IUCN_captain, 0.2),
    FUSE_top20 = FUSE_captain >= quantile(FUSE_captain, 0.8),
    FUSE_bottom20 = FUSE_captain <= quantile(FUSE_captain, 0.2),
    EDGE2_top20 = EDGE2_captain >= quantile(EDGE2_captain, 0.8),
    EDGE2_bottom20 = EDGE2_captain <= quantile(EDGE2_captain, 0.2)
  )

# Count overlaps in top 20%
top20_overlap <- quantile_analysis %>%
  summarise(
    All_three_top20 = sum(IUCN_top20 & FUSE_top20 & EDGE2_top20),
    IUCN_FUSE_top20 = sum(IUCN_top20 & FUSE_top20 & !EDGE2_top20),
    IUCN_EDGE2_top20 = sum(IUCN_top20 & !FUSE_top20 & EDGE2_top20),
    FUSE_EDGE2_top20 = sum(!IUCN_top20 & FUSE_top20 & EDGE2_top20),
    Only_IUCN_top20 = sum(IUCN_top20 & !FUSE_top20 & !EDGE2_top20),
    Only_FUSE_top20 = sum(!IUCN_top20 & FUSE_top20 & !EDGE2_top20),
    Only_EDGE2_top20 = sum(!IUCN_top20 & !FUSE_top20 & EDGE2_top20)
  )

print("\nOverlap in top 20% protected species:")
print(top20_overlap)
print(paste0("Percentage in all three top 20%: ", 
             round(top20_overlap$All_three_top20 / 200 * 100, 1), "%"))

# Count overlaps in bottom 20%
bottom20_overlap <- quantile_analysis %>%
  summarise(
    All_three_bottom20 = sum(IUCN_bottom20 & FUSE_bottom20 & EDGE2_bottom20),
    IUCN_FUSE_bottom20 = sum(IUCN_bottom20 & FUSE_bottom20 & !EDGE2_bottom20),
    IUCN_EDGE2_bottom20 = sum(IUCN_bottom20 & !FUSE_bottom20 & EDGE2_bottom20),
    FUSE_EDGE2_bottom20 = sum(!IUCN_bottom20 & FUSE_bottom20 & EDGE2_bottom20),
    Only_IUCN_bottom20 = sum(IUCN_bottom20 & !FUSE_bottom20 & !EDGE2_bottom20),
    Only_FUSE_bottom20 = sum(!IUCN_bottom20 & FUSE_bottom20 & !EDGE2_bottom20),
    Only_EDGE2_bottom20 = sum(!IUCN_bottom20 & !FUSE_bottom20 & EDGE2_bottom20)
  )

print("\nOverlap in bottom 20% protected species:")
print(bottom20_overlap)
print(paste0("Percentage in all three bottom 20%: ", 
             round(bottom20_overlap$All_three_bottom20 / 200 * 100, 1), "%"))

# Calculate percentage of species unique to each approach in top 20%
unique_percentages <- data.frame(
  Approach = c("IUCN only", "FUSE only", "EDGE2 only", "All three"),
  Count = c(top20_overlap$Only_IUCN_top20, 
            top20_overlap$Only_FUSE_top20,
            top20_overlap$Only_EDGE2_top20,
            top20_overlap$All_three_top20),
  Percentage = c(
    top20_overlap$Only_IUCN_top20 / 200 * 100,
    top20_overlap$Only_FUSE_top20 / 200 * 100,
    top20_overlap$Only_EDGE2_top20 / 200 * 100,
    top20_overlap$All_three_top20 / 200 * 100
  )
)

print("\nTop 20% protection: unique vs shared:")
print(unique_percentages)

# Save outputs
ggsave(here::here("outputs", "iucn_vs_fuse_scatter.png"),
       p1, width = 8, height = 6, dpi = 300)

ggsave(here::here("outputs", "iucn_vs_edge2_scatter.png"),
       p2, width = 8, height = 6, dpi = 300)

ggsave(here::here("outputs", "fuse_vs_edge2_scatter.png"),
       p3, width = 8, height = 6, dpi = 300)

write.csv(correlation_results, 
          here::here("outputs", "protection_correlation_results.csv"), 
          row.names = FALSE)

write.csv(unique_percentages,
          here::here("outputs", "top20_unique_protection.csv"),
          row.names = FALSE)

# --- Barplots of protection levels for all species (colored by IUCN category) ---

library(ggplot2)
library(dplyr)
library(here)
library(ggpubr)

# Define IUCN categories and colors
iucn_order <- c("LC", "NT", "VU", "EN", "CR")
iucn_colors <- c(
  "LC" = "#50C878",  # Green
  "NT" = "#FFFF00",  # Yellow
  "VU" = "#FFA500",  # Orange
  "EN" = "#FF8C00",  # Dark Orange
  "CR" = "#FF0000"   # Red
)

# Ensure IUCN categories are text and ordered
combined_data <- combined_data %>%
  mutate(IUCN_category = case_when(
    IUCN_original == 1 ~ "LC",
    IUCN_original == 2 ~ "NT",
    IUCN_original == 3 ~ "VU",
    IUCN_original == 4 ~ "EN",
    IUCN_original == 5 ~ "CR",
    TRUE ~ NA_character_
  )) %>%
  mutate(IUCN_category = factor(IUCN_category, levels = iucn_order))

# Common theme
base_theme <- theme_classic(base_size = 13) +
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    legend.position = "right",
    panel.background = element_rect(fill = "white", color = NA),
    plot.background = element_rect(fill = "white", color = NA)
  )

# === IUCN ===
p_iucn_bar <- ggplot(combined_data, aes(
  x = IUCN_captain * 100,
  y = reorder(Species_captain, IUCN_captain),
  fill = IUCN_category
)) +
  geom_col() +
  scale_fill_manual(values = iucn_colors, name = "IUCN Category") +
  scale_x_continuous(expand = c(0, 0)) +
  labs(x = "Species range prioritized (%)", y = "Species") + 
  base_theme

# === FUSE ===
p_fuse_bar <- ggplot(combined_data, aes(
  x = FUSE_captain * 100,
  y = reorder(Species_captain, FUSE_captain),
  fill = IUCN_category
)) +
  geom_col() +
  scale_fill_manual(values = iucn_colors, name = "IUCN Category") +
  scale_x_continuous(expand = c(0, 0)) +
  labs(x = "Species range prioritized (%)", y = "Species") + 
  base_theme

# === EDGE2 ===
p_edge2_bar <- ggplot(combined_data, aes(
  x = EDGE2_captain * 100,
  y = reorder(Species_captain, EDGE2_captain),
  fill = IUCN_category
)) +
  geom_col() +
  scale_fill_manual(values = iucn_colors, name = "IUCN Category") +
  scale_x_continuous(expand = c(0, 0)) +
  labs(x = "Species range prioritized (%)", y = "Species") + 
  base_theme

# === Combine all three ===
combined_barplots <- ggarrange(
  p_iucn_bar, p_fuse_bar, p_edge2_bar,
  labels = c("A", "B", "C"),
  ncol = 3,
  nrow = 1,
  common.legend = TRUE,
  legend = "right"
)

# Display
combined_barplots

# === Save combined figure ===
ggsave(
  here::here("outputs", "combined_species_barplots.png"),
  combined_barplots,
  width = 12, height = 5, dpi = 300, bg = "white"
)

```

# Manuscript maps

### Individual maps

```{r}
CAPTAIN2_EDGE2_msmap <- ggplot() +
  geom_sf(data = CAPTAIN2_EDGE2_sf, aes(color = Priority), size = 0.5, alpha = 0.7) +
  geom_sf(data = world_projected_CAPTAIN2_EDGE2, fill = "lightgrey", color = "lightgrey", size = 0.1) +
  geom_sf(data = globe_border_CAPTAIN2_EDGE2, fill = NA, color = "lightgrey", size = 0.5) +
  scale_color_gradientn(
    colors = c("white", "yellow", "darkblue"),
    values = c(0, 0.5, 1),
    name = "Priority EDGE2",
    guide = guide_colorbar(barwidth = 20, barheight = 0.5, 
                         title.position = "top", title.hjust = 0.5)
  ) +
  labs(#title = "Global Conservation Priorities",
       #subtitle = "CAPTAIN2 - EDGE2 Index, Budget: 0.1, Replicates: 50",
       x = NULL, y = NULL) +
  my_theme_CAPTAIN2_EDGE2
CAPTAIN2_EDGE2_msmap

CAPTAIN2_FUSE_msmap <- ggplot() +
  geom_sf(data = CAPTAIN2_FUSE_sf, aes(color = Priority), size = 0.5, alpha = 0.7) +
  geom_sf(data = world_projected_CAPTAIN2_FUSE, fill = "lightgrey", color = "lightgrey", size = 0.1) +
  geom_sf(data = globe_border_CAPTAIN2_FUSE, fill = NA, color = "lightgrey", size = 0.5) +
  scale_color_gradientn(
    colors = c("white", "yellow", "darkblue"),
    values = c(0, 0.5, 1),
    name = "Priority FUSE",
    guide = guide_colorbar(barwidth = 20, barheight = 0.5, 
                         title.position = "top", title.hjust = 0.5)
  ) +
  labs(#title = "Global Conservation Priorities",
       #subtitle = "CAPTAIN2 - FUSE Index, Budget: 0.1, Replicates: 50",
       x = NULL, y = NULL) +
  my_theme_CAPTAIN2_FUSE
CAPTAIN2_FUSE_msmap

CAPTAIN2_IUCN_msmap <- ggplot() +
  geom_sf(data = CAPTAIN2_IUCN_sf, aes(color = Priority), size = 0.5, alpha = 0.7) +
  geom_sf(data = world_projected_CAPTAIN2_IUCN, fill = "lightgrey", color = "lightgrey", size = 0.1) +
  geom_sf(data = globe_border_CAPTAIN2_IUCN, fill = NA, color = "lightgrey", size = 0.5) +
  scale_color_gradientn(
    colors = c("white", "yellow", "darkblue"),
    values = c(0, 0.5, 1),
    name = "Priority IUCN",
    guide = guide_colorbar(barwidth = 20, barheight = 0.5, 
                         title.position = "top", title.hjust = 0.5)
  ) +
  labs(#title = "Global Conservation Priorities",
       #subtitle = "CAPTAIN2 - IUCN Index, Budget: 0.1, Replicates: 50",
       x = NULL, y = NULL) +
  my_theme_CAPTAIN2_IUCN
CAPTAIN2_IUCN_msmap

# Load required libraries
library(patchwork)
library(ggplot2)

# Create a function to add labels (A), (B), etc.
add_panel_labels <- function(plot, label) {
  plot + 
    theme(
      plot.title = element_text(face = "bold", hjust = 0, size = 12)
    ) +
    labs(title = paste0("(", label, ")"))
}

# Add labels to each plot
# First grid
CAPTAIN2_IUCN_msmap_labeled <- add_panel_labels(CAPTAIN2_IUCN_msmap, "A")
CAPTAIN2_FUSE_msmap_labeled <- add_panel_labels(CAPTAIN2_FUSE_msmap, "B")
CAPTAIN2_EDGE2_msmap_labeled <- add_panel_labels(CAPTAIN2_EDGE2_msmap, "C")

# Combine plots into two separate grids, each with 3 rows and 1 column
grid1 <- CAPTAIN2_IUCN_msmap_labeled /
         CAPTAIN2_FUSE_msmap_labeled /
         CAPTAIN2_EDGE2_msmap_labeled

# Display each grid separately
grid1

# Save the grids if needed
ggsave(here::here("grid1_maps_continental_2ndrun_new.png"), grid1, width = 8, height = 15, dpi = 300)

```

### Difference maps

```{r}
# 1. IUCN - FUSE Difference Map
IUCN_FUSE_msmap <- ggplot() +
  geom_sf(data = globe_border, fill = "#F8F8F8", color = NA) +
  geom_sf(data = IUCN_FUSE_diff, aes(color = IUCN_minus_FUSE), size = 0.5) +
  geom_sf(data = world_projected, fill = "lightgrey", color = "darkgrey", size = 0.1) +
  geom_sf(data = globe_border, fill = NA, color = "lightgrey", size = 0.5) +
  scale_color_gradientn(
    colors = diff_colors,
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.25),
    labels = as.character(seq(-1, 1, by = 0.25)),
    name = "Difference in Priority (IUCN - FUSE)",
    guide = guide_colorbar(barwidth = 20, barheight = 0.5, 
                         title.position = "top", title.hjust = 0.5)
  ) +
  labs(#title = "Difference in Conservation Priorities",
       #subtitle = "IUCN Index minus FUSE Index",
       x = NULL, y = NULL) +
  my_theme

# 2. IUCN - EDGE2 Difference Map
IUCN_EDGE2_msmap <- ggplot() +
  geom_sf(data = globe_border, fill = "#F8F8F8", color = NA) +
  geom_sf(data = IUCN_EDGE2_diff, aes(color = IUCN_minus_EDGE2), size = 0.5) +
  geom_sf(data = world_projected, fill = "lightgrey", color = "darkgrey", size = 0.1) +
  geom_sf(data = globe_border, fill = NA, color = "lightgrey", size = 0.5) +
  scale_color_gradientn(
    colors = diff_colors,
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.25),
    labels = as.character(seq(-1, 1, by = 0.25)),
    name = "Difference in Priority (IUCN - EDGE2)",
    guide = guide_colorbar(barwidth = 20, barheight = 0.5, 
                         title.position = "top", title.hjust = 0.5)
  ) +
  labs(#title = "Difference in Conservation Priorities",
       #subtitle = "IUCN Index minus EDGE2 Index",
       x = NULL, y = NULL) +
  my_theme

# 3. EDGE2 - FUSE Difference Map
EDGE2_FUSE_msmap <- ggplot() +
  geom_sf(data = globe_border, fill = "#F8F8F8", color = NA) +
  geom_sf(data = EDGE2_FUSE_diff, aes(color = EDGE2_minus_FUSE), size = 0.5) +
  geom_sf(data = world_projected, fill = "lightgrey", color = "darkgrey", size = 0.1) +
  geom_sf(data = globe_border, fill = NA, color = "lightgrey", size = 0.5) +
  scale_color_gradientn(
    colors = diff_colors,
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.25),
    labels = as.character(seq(-1, 1, by = 0.25)),
    name = "Difference in Priority (EDGE2 - FUSE)",
    guide = guide_colorbar(barwidth = 20, barheight = 0.5, 
                         title.position = "top", title.hjust = 0.5)
  ) +
  labs(#title = "Difference in Conservation Priorities",
       #subtitle = "EDGE2 Index minus FUSE Index",
       x = NULL, y = NULL) +
  my_theme

# Load required libraries
library(patchwork)
library(ggplot2)

# Create a function to add labels (A), (B), etc.
add_panel_labels <- function(plot, label) {
  plot + 
    theme(
      plot.title = element_text(face = "bold", hjust = 0, size = 12)
    ) +
    labs(title = paste0("(", label, ")"))
}

# Add labels to each plot
# First grid
IUCN_FUSE_msmap_labeled <- add_panel_labels(IUCN_FUSE_msmap, "A")
IUCN_EDGE2_msmap_labeled <- add_panel_labels(IUCN_EDGE2_msmap, "B")
EDGE2_FUSE_msmap_labeled <- add_panel_labels(EDGE2_FUSE_msmap, "C")

# Combine plots into two separate grids, each with 3 rows and 1 column
grid2 <- IUCN_FUSE_msmap_labeled /
         IUCN_EDGE2_msmap_labeled /
         EDGE2_FUSE_msmap_labeled

# Display each grid separately
grid2

# Save the grids if needed
ggsave(here::here("grid3_maps_continental_2ndrun.png"), grid2, width = 16, height = 15, dpi = 300)

```

### Combined individual and difference maps

```{r}

library(patchwork)

# Add labels to each plot
# First grid
CAPTAIN2_IUCN_msmap_labeled <- add_panel_labels(CAPTAIN2_IUCN_msmap, "A")
CAPTAIN2_FUSE_msmap_labeled <- add_panel_labels(CAPTAIN2_FUSE_msmap, "B")
CAPTAIN2_EDGE2_msmap_labeled <- add_panel_labels(CAPTAIN2_EDGE2_msmap, "C")

# Second grid
IUCN_FUSE_msmap_labeled <- add_panel_labels(IUCN_FUSE_msmap, "D")
IUCN_EDGE2_msmap_labeled <- add_panel_labels(IUCN_EDGE2_msmap, "E")
EDGE2_FUSE_msmap_labeled <- add_panel_labels(EDGE2_FUSE_msmap, "F")

# Create each grid (3 rows, 1 column)
grid1 <- CAPTAIN2_IUCN_msmap_labeled /
         CAPTAIN2_FUSE_msmap_labeled /
         CAPTAIN2_EDGE2_msmap_labeled

grid2 <- IUCN_FUSE_msmap_labeled /
         IUCN_EDGE2_msmap_labeled /
         EDGE2_FUSE_msmap_labeled

# Combine the two grids side by side (2 columns)
combined_grid <- grid1 | grid2

# Display the combined grid
combined_grid

# If you want to save it
ggsave(
  filename = here::here("outputs", "combined_priority_maps.png"),
  plot = combined_grid,
  width = 10,    # Adjust width as needed for two columns
  height = 12,   # Adjust height as needed for three rows
  dpi = 300,
  bg = "white"
)
```

### 0.9 value maps 

```{r}
# Filter for high priority cells (>0.9) and calculate percentages
library(dplyr)
library(sf)
library(egg)
library(patchwork)

# Calculate total coastal cells and high-priority cells for each index
# IUCN
CAPTAIN2_IUCN_high <- CAPTAIN2_IUCN_sf %>% 
  filter(Priority > 0.9)
iucn_total_cells <- nrow(CAPTAIN2_IUCN_sf)
iucn_high_cells <- nrow(CAPTAIN2_IUCN_high)
iucn_percent <- round((iucn_high_cells / iucn_total_cells) * 100, 1)

# FUSE
CAPTAIN2_FUSE_high <- CAPTAIN2_FUSE_sf %>% 
  filter(Priority > 0.9)
fuse_total_cells <- nrow(CAPTAIN2_FUSE_sf)
fuse_high_cells <- nrow(CAPTAIN2_FUSE_high)
fuse_percent <- round((fuse_high_cells / fuse_total_cells) * 100, 1)

# EDGE2
CAPTAIN2_EDGE2_high <- CAPTAIN2_EDGE2_sf %>% 
  filter(Priority > 0.9)
edge2_total_cells <- nrow(CAPTAIN2_EDGE2_sf)
edge2_high_cells <- nrow(CAPTAIN2_EDGE2_high)
edge2_percent <- round((edge2_high_cells / edge2_total_cells) * 100, 1)

# Print results
cat("IUCN: ", iucn_high_cells, " cells (", iucn_percent, "%) with priority >0.9\n", sep="")
cat("FUSE: ", fuse_high_cells, " cells (", fuse_percent, "%) with priority >0.9\n", sep="")
cat("EDGE2: ", edge2_high_cells, " cells (", edge2_percent, "%) with priority >0.9\n", sep="")

# Create maps showing only high-priority cells (>0.9) - SAME STYLE AS CONGRUENT MAP
CAPTAIN2_IUCN_high_map <- ggplot() +
  geom_sf(data = CAPTAIN2_IUCN_high, aes(fill = "High Priority"), 
          color = "darkblue", size = 0.8, alpha = 0.8) +
  geom_sf(data = world_projected_CAPTAIN2_IUCN, fill = "lightgrey", color = "lightgrey", size = 0.1) +
  geom_sf(data = globe_border_CAPTAIN2_IUCN, fill = NA, color = "black", size = 0.5) +
  scale_fill_manual(values = c("High Priority" = "darkblue"),
                    name = "Priority Areas") +
  labs(subtitle = paste0(iucn_percent, "% of coastal cells"),
       x = NULL, y = NULL) +
  my_theme_CAPTAIN2_IUCN +
  theme(axis.text.x = element_blank(),
        axis.text.y = element_blank())

CAPTAIN2_FUSE_high_map <- ggplot() +
  geom_sf(data = CAPTAIN2_FUSE_high, aes(fill = "High Priority"), 
          color = "darkblue", size = 0.8, alpha = 0.8) +
  geom_sf(data = world_projected_CAPTAIN2_FUSE, fill = "lightgrey", color = "lightgrey", size = 0.1) +
  geom_sf(data = globe_border_CAPTAIN2_FUSE, fill = NA, color = "black", size = 0.5) +
  scale_fill_manual(values = c("High Priority" = "darkblue"),
                    name = "Priority Areas") +
  labs(subtitle = paste0(fuse_percent, "% of coastal cells"),
       x = NULL, y = NULL) +
  my_theme_CAPTAIN2_FUSE +
  theme(axis.text.x = element_blank(),
        axis.text.y = element_blank())

CAPTAIN2_EDGE2_high_map <- ggplot() +
  geom_sf(data = CAPTAIN2_EDGE2_high, aes(fill = "High Priority"), 
          color = "darkblue", size = 0.8, alpha = 0.8) +
  geom_sf(data = world_projected_CAPTAIN2_EDGE2, fill = "lightgrey", color = "lightgrey", size = 0.1) +
  geom_sf(data = globe_border_CAPTAIN2_EDGE2, fill = NA, color = "black", size = 0.5) +
  scale_fill_manual(values = c("High Priority" = "darkblue"),
                    name = "Priority Areas") +
  labs(subtitle = paste0(edge2_percent, "% of coastal cells"),
       x = NULL, y = NULL) +
  my_theme_CAPTAIN2_EDGE2 +
  theme(axis.text.x = element_blank(),
        axis.text.y = element_blank())

# Add panel labels
CAPTAIN2_IUCN_high_labeled <- add_panel_labels(CAPTAIN2_IUCN_high_map, "A")
CAPTAIN2_FUSE_high_labeled <- add_panel_labels(CAPTAIN2_FUSE_high_map, "B")
CAPTAIN2_EDGE2_high_labeled <- add_panel_labels(CAPTAIN2_EDGE2_high_map, "C")

# Combine
grid_high_priority <- CAPTAIN2_IUCN_high_labeled /
                      CAPTAIN2_FUSE_high_labeled /
                      CAPTAIN2_EDGE2_high_labeled

grid_high_priority

# Save
ggsave(here::here("grid_high_priority_maps.png"), grid_high_priority, 
       width = 8, height = 15, dpi = 300)
```

### Ecoregions with high priority

```{r}
# Load marine ecoregion shapefile (if not already loaded)
meow_ecos <- st_read(here("Data", "Shapefiles", "meow_ecos", "meow_ecos.shp"), quiet = TRUE)

# Make sure CRS matches for all datasets
st_crs(CAPTAIN2_IUCN_high) <- st_crs(meow_ecos)
st_crs(CAPTAIN2_FUSE_high) <- st_crs(meow_ecos)
st_crs(CAPTAIN2_EDGE2_high) <- st_crs(meow_ecos)

#---------------------- HIGH PRIORITY CELLS BY ECOREGION ----------------------#

# IUCN - Process high-priority cells for ECOREGIONS
IUCN_with_ecoregion <- st_join(CAPTAIN2_IUCN_high, meow_ecos %>% dplyr::select(ECOREGION, REALM))

iucn_ecoregion_stats <- IUCN_with_ecoregion %>%
  st_drop_geometry() %>%
  group_by(ECOREGION, REALM) %>%
  summarize(
    n_high_priority_cells = n(),
    mean_priority = mean(Priority, na.rm = TRUE),
    .groups = 'drop'
  ) %>%
  filter(!is.na(ECOREGION)) %>%
  arrange(desc(n_high_priority_cells))

iucn_n_ecoregions <- nrow(iucn_ecoregion_stats)
iucn_top3 <- head(iucn_ecoregion_stats, 3)

# FUSE - Process high-priority cells for ECOREGIONS
FUSE_with_ecoregion <- st_join(CAPTAIN2_FUSE_high, meow_ecos %>% dplyr::select(ECOREGION, REALM))

fuse_ecoregion_stats <- FUSE_with_ecoregion %>%
  st_drop_geometry() %>%
  group_by(ECOREGION, REALM) %>%
  summarize(
    n_high_priority_cells = n(),
    mean_priority = mean(Priority, na.rm = TRUE),
    .groups = 'drop'
  ) %>%
  filter(!is.na(ECOREGION)) %>%
  arrange(desc(n_high_priority_cells))

fuse_n_ecoregions <- nrow(fuse_ecoregion_stats)
fuse_top3 <- head(fuse_ecoregion_stats, 3)

# EDGE2 - Process high-priority cells for ECOREGIONS
EDGE2_with_ecoregion <- st_join(CAPTAIN2_EDGE2_high, meow_ecos %>% dplyr::select(ECOREGION, REALM))

edge2_ecoregion_stats <- EDGE2_with_ecoregion %>%
  st_drop_geometry() %>%
  group_by(ECOREGION, REALM) %>%
  summarize(
    n_high_priority_cells = n(),
    mean_priority = mean(Priority, na.rm = TRUE),
    .groups = 'drop'
  ) %>%
  filter(!is.na(ECOREGION)) %>%
  arrange(desc(n_high_priority_cells))

edge2_n_ecoregions <- nrow(edge2_ecoregion_stats)
edge2_top3 <- head(edge2_ecoregion_stats, 3)

#---------------------- PRINT RESULTS ----------------------#

cat("\n=== HIGH PRIORITY CELLS BY ECOREGION ===\n\n")

cat("IUCN: ", iucn_n_ecoregions, " ecoregions with high-priority cells (>0.9)\n", sep="")
cat("Top 3 ecoregions:\n")
print(iucn_top3 %>% dplyr::select(ECOREGION, REALM, n_high_priority_cells))

cat("\n")

cat("FUSE: ", fuse_n_ecoregions, " ecoregions with high-priority cells (>0.9)\n", sep="")
cat("Top 3 ecoregions:\n")
print(fuse_top3 %>% dplyr::select(ECOREGION, REALM, n_high_priority_cells))

cat("\n")

cat("EDGE2: ", edge2_n_ecoregions, " ecoregions with high-priority cells (>0.9)\n", sep="")
cat("Top 3 ecoregions:\n")
print(edge2_top3 %>% dplyr::select(ECOREGION, REALM, n_high_priority_cells))

# Optional: Save the full ecoregion statistics
write.csv(iucn_ecoregion_stats, here("output", "IUCN_high_priority_ecoregions.csv"), row.names = FALSE)
write.csv(fuse_ecoregion_stats, here("output", "FUSE_high_priority_ecoregions.csv"), row.names = FALSE)
write.csv(edge2_ecoregion_stats, here("output", "EDGE2_high_priority_ecoregions.csv"), row.names = FALSE)
```


## Congruence maps

```{r}
# Method 1: If you have separate dataframes for each index
# Assuming your data has columns: PUID, Priority, and geometry

# Fxirst, identify high priority areas (>0.9) for each index
high_priority_EDGE2 <- CAPTAIN2_EDGE2_sf[CAPTAIN2_EDGE2_sf$Priority > 0.9, ]
high_priority_FUSE <- CAPTAIN2_FUSE_sf[CAPTAIN2_FUSE_sf$Priority > 0.9, ]
high_priority_IUCN <- CAPTAIN2_IUCN_sf[CAPTAIN2_IUCN_sf$Priority > 0.9, ]

# Find congruent areas (present in all three)
# Method using PUID (assuming you have PUID column)
congruent_PUIDs <- intersect(intersect(high_priority_EDGE2$PUID, 
                                      high_priority_FUSE$PUID), 
                            high_priority_IUCN$PUID)

# Extract congruent areas
congruent_areas <- CAPTAIN2_EDGE2_sf[CAPTAIN2_EDGE2_sf$PUID %in% congruent_PUIDs, ]

# Print summary
cat("High priority areas (>0.9):\n")
cat("EDGE2:", nrow(high_priority_EDGE2), "areas\n")
cat("FUSE:", nrow(high_priority_FUSE), "areas\n") 
cat("IUCN:", nrow(high_priority_IUCN), "areas\n")
cat("Congruent areas:", nrow(congruent_areas), "areas\n")
cat("Percentage of overlap:", round(nrow(congruent_areas)/min(nrow(high_priority_EDGE2), 
                                                            nrow(high_priority_FUSE), 
                                                            nrow(high_priority_IUCN))*100, 2), "%\n")

# Method 2: If you need to merge dataframes first
# Create a combined dataframe with all three priority scores
# First, extract just the data (without geometry) from the other sf objects
FUSE_data <- st_drop_geometry(CAPTAIN2_FUSE_sf[, c("PUID", "Priority")])
IUCN_data <- st_drop_geometry(CAPTAIN2_IUCN_sf[, c("PUID", "Priority")])

# Merge with the EDGE2 sf object (keeping geometry)
combined_priorities <- merge(CAPTAIN2_EDGE2_sf, FUSE_data, 
                            by = "PUID", suffixes = c("_EDGE2", "_FUSE"))
combined_priorities <- merge(combined_priorities, IUCN_data, 
                            by = "PUID")
names(combined_priorities)[names(combined_priorities) == "Priority"] <- "Priority_IUCN"

# Identify congruent high priority areas
congruent_areas_v2 <- combined_priorities[combined_priorities$Priority_EDGE2 > 0.9 & 
                                         combined_priorities$Priority_FUSE > 0.9 & 
                                         combined_priorities$Priority_IUCN > 0.9, ]

# Create a map showing only congruent areas
congruent_map <- ggplot() +
  geom_sf(data = congruent_areas, aes(fill = "Congruent High Priority"), 
          color = "red", size = 0.8, alpha = 0.8) +
  geom_sf(data = world_projected_CAPTAIN2_EDGE2, fill = "lightgrey", color = "lightgrey", size = 0.1) +
  geom_sf(data = globe_border_CAPTAIN2_EDGE2, fill = NA, color = "black", size = 0.5) +
  scale_fill_manual(values = c("Congruent high priority" = "red"),
                    name = "Priority areas") +
  labs(title = "Congruent high priority areas",
       subtitle = "Areas with priority > 0.9 in IUCN, FUSE and EDGE2 dimensions",
       x = NULL, y = NULL) +
  my_theme_CAPTAIN2_EDGE2

# Display the map
print(congruent_map)

ggsave(here::here("outputs", "congruent_high_prioritiy_areas_09.png"), 
       congruent_map, 
       width = 10, height = 8, dpi = 300, bg = "white")

# Create detailed congruence categories
# Define logical conditions for each index
EDGE2_high <- combined_priorities$Priority_EDGE2 > 0.9
FUSE_high <- combined_priorities$Priority_FUSE > 0.9
IUCN_high <- combined_priorities$Priority_IUCN > 0.9

# Create detailed congruence categories
combined_priorities$congruence_category <- case_when(
  EDGE2_high & FUSE_high & IUCN_high ~ "All three indices",
  !EDGE2_high & FUSE_high & IUCN_high ~ "IUCN + FUSE",      # Changed from "FUSE + IUCN"
  EDGE2_high & !FUSE_high & IUCN_high ~ "IUCN + EDGE2",     # Changed from "EDGE2 + IUCN"
  EDGE2_high & FUSE_high & !IUCN_high ~ "FUSE + EDGE2",     # Changed from "EDGE2 + FUSE"
  !EDGE2_high & !FUSE_high & IUCN_high ~ "IUCN only",
  !EDGE2_high & FUSE_high & !IUCN_high ~ "FUSE only",
  EDGE2_high & !FUSE_high & !IUCN_high ~ "EDGE2 only",
  TRUE ~ "No high priority"
)

# Convert to factor with desired order
combined_priorities$congruence_category <- factor(
  combined_priorities$congruence_category,
  levels = c("All three indices",
             "IUCN + FUSE", "IUCN + EDGE2", "FUSE + EDGE2",  # Changed order
             "IUCN only", "FUSE only", "EDGE2 only")
)

# Filter data to only include high priority areas
high_priority_data <- combined_priorities[combined_priorities$congruence_category %in%
                                          c("All three indices", 
                                            "IUCN + FUSE", "IUCN + EDGE2", "FUSE + EDGE2",  # Changed names
                                            "IUCN only", "FUSE only", "EDGE2 only"), ]

# Debug: Check the data
cat("Data check:\n")
cat("Total high priority areas:", nrow(high_priority_data), "\n")
print(table(high_priority_data$congruence_category))

# Check if the factor levels are properly set
cat("\nFactor levels:\n")
print(levels(high_priority_data$congruence_category))

# Check for any issues with the data
cat("\nData structure check:\n")
print(str(high_priority_data$congruence_category))

# Test a simple plot first
cat("\nTesting simple plot...\n")
test_plot <- ggplot() +
  geom_sf(data = high_priority_data, aes(fill = congruence_category)) +
  scale_fill_manual(values = c("All three indices" = "#8B0000",
                              "EDGE2 + FUSE" = "#FF4500",
                              "EDGE2 + IUCN" = "#FF6347",
                              "FUSE + IUCN" = "#FFA500",
                              "EDGE2 only" = "#4169E1",
                              "FUSE only" = "#32CD32",
                              "IUCN only" = "#9370DB")) +
  theme_void()

# Try to print the simple test plot
tryCatch({
  print(test_plot)
  cat("Simple plot works!\n")
}, error = function(e) {
  cat("Simple plot failed with error:", e$message, "\n")
})

# If simple plot fails, let's check the data more thoroughly
if (nrow(high_priority_data) == 0) {
  cat("No high priority data found! Checking original data...\n")
  cat("EDGE2 > 0.9:", sum(combined_priorities$Priority_EDGE2 > 0.9, na.rm = TRUE), "\n")
  cat("FUSE > 0.9:", sum(combined_priorities$Priority_FUSE > 0.9, na.rm = TRUE), "\n") 
  cat("IUCN > 0.9:", sum(combined_priorities$Priority_IUCN > 0.9, na.rm = TRUE), "\n")
}

# Extract coordinates for the congruence plot
if (nrow(high_priority_data) > 0) {
  coords <- st_coordinates(st_centroid(high_priority_data))
  plot_data <- data.frame(
    x = coords[,1],
    y = coords[,2], 
    category = high_priority_data$congruence_category
  )
  
  # Remove any rows with NA category
  plot_data <- plot_data[!is.na(plot_data$category), ]
  
  cat("Creating enhanced congruence plot...\n")
  cat("Plot data dimensions:", nrow(plot_data), "points\n")
  
  # Create the enhanced congruence plot
  congruence_map <- ggplot(plot_data, aes(x = x, y = y, color = category)) +
    geom_point(size = 1.2, alpha = 0.85, stroke = 0) +  # Larger points, no stroke to reduce overlap
    scale_color_manual(
      values = c("All three indices" = "#8B0000",      # Dark red
                "EDGE2 + FUSE" = "#FF8C00",            # Dark orange  
                "EDGE2 + IUCN" = "#DC143C",            # Crimson
                "FUSE + IUCN" = "#FFD700",             # Gold
                "EDGE2 only" = "#4169E1",              # Royal blue
                "FUSE only" = "#32CD32",               # Lime green
                "IUCN only" = "#9370DB"),              # Medium purple
      name = "High Priority\nCongruence",
      guide = guide_legend(
        override.aes = list(size = 4, alpha = 1),  # Larger, more opaque legend points
        title.position = "top",
        title.hjust = 0.5,
        ncol = 4  # Two columns for legend to save space
      )) +
    labs(
      title = "Global Conservation Priority Congruence Analysis",
      subtitle = "High priority areas (>0.9) showing agreement patterns across EDGE2, FUSE, and IUCN indices",
      x = "Longitude", 
      y = "Latitude",
      caption = paste("Total high priority areas:", nrow(plot_data))
    ) +
    theme_minimal() +
    theme(
      # Plot aesthetics
      plot.background = element_rect(fill = "white", color = NA),
      panel.background = element_rect(fill = "#f8f9fa", color = NA),
      panel.grid.major = element_line(color = "white", size = 0.5, linetype = "solid"),
      panel.grid.minor = element_line(color = "white", size = 0.25, linetype = "solid"),
      
      # Text styling
      plot.title = element_text(size = 16, hjust = 0.5, face = "bold", 
                               margin = margin(b = 10)),
      plot.subtitle = element_text(size = 12, hjust = 0.5, color = "gray30",
                                  margin = margin(b = 20)),
      plot.caption = element_text(size = 10, color = "gray50", hjust = 1),
      
      # Axis styling
      axis.title = element_text(size = 12, face = "bold"),
      axis.text = element_text(size = 10, color = "gray30"),
      axis.ticks = element_line(color = "gray50", size = 0.5),
      
      # Legend styling
      legend.position = "bottom",
      legend.background = element_rect(fill = "white", color = "gray80", size = 0.5),
      legend.margin = margin(t = 15, r = 10, b = 10, l = 10),
      legend.title = element_text(size = 12, face = "bold"),
      legend.text = element_text(size = 10),
      legend.key.size = unit(0.8, "cm"),
      
      # Panel border
      panel.border = element_rect(color = "gray70", fill = NA, size = 0.5)
    ) +
    # Add coordinate system and aspect ratio
    coord_fixed(ratio = 1.3) +  # Adjust ratio for better map appearance
    # Add subtle borders around plot area
    scale_x_continuous(expand = c(0.02, 0.02)) +
    scale_y_continuous(expand = c(0.02, 0.02))
  
  # Print the enhanced plot
  print(congruence_map)
  cat("Enhanced congruence plot created successfully!\n")
  
  # Print summary by category
  cat("\nBreakdown by congruence category:\n")
  category_counts <- table(plot_data$category)
  category_percentages <- round(prop.table(category_counts) * 100, 1)
  
  for(i in 1:length(category_counts)) {
    cat(sprintf("%-20s: %4d points (%4.2f%%)\n", 
                names(category_counts)[i], 
                category_counts[i], 
                category_percentages[i]))
  }
  
} else {
  cat("No valid high priority data to plot\n")
}

# Print summary of congruence patterns
cat("\nCongruence Pattern Summary:\n")
congruence_summary <- table(combined_priorities$congruence_category, useNA = "ifany")
print(congruence_summary)

# Calculate percentages
total_high_priority <- sum(congruence_summary[names(congruence_summary) != "No high priority"], na.rm = TRUE)
congruence_percentages <- round(congruence_summary / total_high_priority * 100, 2)
cat("\nPercentages of high priority areas:\n")
print(congruence_percentages[names(congruence_percentages) != "No high priority"])

# ms style map -----

# Add troubleshooting statements throughout the code
library(sf)
library(ggplot2)

# Step 1: Check original data
print("=== STEP 1: CHECKING ORIGINAL DATA ===")
print(paste("Number of rows in plot_data:", nrow(plot_data)))
print("First few rows of plot_data:")
print(head(plot_data))
print("Summary of coordinates:")
print(summary(plot_data[c("x", "y")]))
print("Unique categories:")
print(unique(plot_data$category))

# Step 2: Transform to sf object
print("=== STEP 2: CREATING SF OBJECT ===")
congruence_sf <- st_as_sf(
  plot_data, 
  coords = c("x", "y"), 
  crs = mcbryde_thomas_2  # Assuming WGS84
)
print(paste("Number of sf features created:", nrow(congruence_sf)))
print("Original CRS:")
print(st_crs(congruence_sf))
print("Bounding box before projection:")
print(st_bbox(congruence_sf))

# Step 3: Project to McBryde-Thomas 2
print("=== STEP 3: PROJECTING TO MCBRYDE-THOMAS 2 ===")
congruence_sf <- st_transform(congruence_sf, crs = mcbryde_thomas_2)
print("CRS after projection:")
print(st_crs(congruence_sf))
print("Bounding box after projection:")
print(st_bbox(congruence_sf))

# Step 4: Check world projection
print("=== STEP 4: CHECKING WORLD PROJECTION ===")
world_projected_congruence <- st_transform(world, crs = mcbryde_thomas_2)
print("World bounding box:")
print(st_bbox(world_projected_congruence))

# Step 5: Create globe border
print("=== STEP 5: CREATING GLOBE BORDER ===")
globe_bbox <- rbind(c(-180, -90), c(-180, 90), 
                    c(180, 90), c(180, -90), c(-180, -90))
globe_border_congruence <- st_polygon(list(globe_bbox)) %>%
  st_sfc(crs = 4326) %>%
  st_sf(data.frame(rgn = 'globe', geom = .)) %>%
  smoothr::densify(max_distance = 0.5) %>%
  st_transform(crs = mcbryde_thomas_2)
print("Globe border bounding box:")
print(st_bbox(globe_border_congruence))

# Step 6: Check intersection
print("=== STEP 6: CHECKING INTERSECTION ===")
points_in_globe <- st_intersects(congruence_sf, globe_border_congruence, sparse = FALSE)
print(paste("Points within globe boundary:", sum(points_in_globe)))
print(paste("Percentage of points in globe:", round(sum(points_in_globe)/nrow(congruence_sf)*100, 2), "%"))

# Step 7: Extract coordinates for verification
print("=== STEP 7: EXTRACTING COORDINATES ===")
coords <- st_coordinates(congruence_sf)
print("Projected coordinate summary:")
print(summary(coords))
print("First few projected coordinates:")
print(head(coords))

# Step 8: Create theme
my_theme_congruence <- theme_minimal() +
  theme(
    legend.position = "bottom",
    legend.direction = "horizontal",
    legend.box = "vertical",
    legend.margin = margin(t = 20, r = 0, b = 0, l = 0),
    legend.title = element_text(margin = margin(b = 10)),
    panel.background = element_rect(fill = "white", color = NA),
    plot.background = element_rect(fill = "white", color = NA),
    panel.grid = element_blank(),
    axis.text = element_blank(),      # Add this line
    axis.ticks = element_blank()      # Add this line
  )

# Step 9: Create plot with debugging
print("=== STEP 9: CREATING PLOT ===")
congruence_map <- ggplot() +
  geom_sf(data = congruence_sf, aes(color = category), size = 1.2, alpha = 0.85) +
  geom_sf(data = world_projected_congruence, fill = "lightgrey", color = "lightgrey", size = 0.1) +
  geom_sf(data = globe_border_congruence, fill = NA, color = "lightgrey", size = 0.5) +
  scale_color_manual(
  values = c("All three indices" = "#8B0000",
            "IUCN + FUSE" = "#FFD700",           # Changed from "FUSE + IUCN"
            "IUCN + EDGE2" = "#DC143C",          # Changed from "EDGE2 + IUCN"
            "FUSE + EDGE2" = "#FF8C00",          # Changed from "EDGE2 + FUSE"
            "IUCN only" = "#9370DB",
            "FUSE only" = "#32CD32",
            "EDGE2 only" = "#4169E1"),
  breaks = c("All three indices",
             "IUCN + FUSE", 
             "IUCN + EDGE2", 
             "FUSE + EDGE2",
             "IUCN only", 
             "FUSE only", 
             "EDGE2 only"),              # Finally: FUSE + EDGE2
    name = "High priority congruence",
    guide = guide_legend(
      override.aes = list(size = 4, alpha = 1),
      title.position = "top", 
      title.hjust = 0.5,
      ncol = 4
    )) +
  labs(
    title = "Global conservation priority congruence analysis",
    subtitle = "High priority areas (>0.9) showing agreement patterns across IUCN, FUSE and EDGE2 prioritisations",
    x = NULL, 
    y = NULL
  ) +
  my_theme_congruence

ggsave(here::here("outputs", "congruent_high_prioritiy_areas_09_all_indices.png"), 
       congruence_map, 
       width = 10, height = 8, dpi = 300, bg = "white")

print("=== STEP 10: DISPLAYING PLOT ===")
print("Plot created successfully")

# Alternative test plot with just points to see if they're visible
print("=== CREATING TEST PLOT WITH JUST POINTS ===")
test_plot <- ggplot() +
  geom_sf(data = congruence_sf, aes(color = category), size = 2, alpha = 1) +
  scale_color_manual(
    values = c("All three indices" = "#8B0000",      
              "EDGE2 + FUSE" = "#FF8C00",            
              "EDGE2 + IUCN" = "#DC143C",            
              "FUSE + IUCN" = "#FFD700",             
              "EDGE2 only" = "#4169E1",              
              "FUSE only" = "#32CD32",               
              "IUCN only" = "#9370DB")) +
  labs(title = "Test Plot - Points Only")

print("Test plot created")

# Display both plots
print(congruence_map)
print(test_plot)
```


## Congruence tests 

```{r}
# Statistical congruence analysis following the methods section
# First, extract priority values for the comparison
priority_threshold <- 0.9

# Create binary matrices for high-priority areas (>0.9)
fuse_high <- CAPTAIN2_FUSE_data_nonzero$Priority > priority_threshold
edge2_high <- CAPTAIN2_EDGE2_data_nonzero$Priority > priority_threshold
iucn_high <- CAPTAIN2_IUCN_data_nonzero$Priority > priority_threshold

# Calculate observed overlaps
observed_fuse_edge2 <- sum(fuse_high & edge2_high)
observed_fuse_iucn <- sum(fuse_high & iucn_high)
observed_edge2_iucn <- sum(edge2_high & iucn_high)
observed_all_three <- sum(fuse_high & edge2_high & iucn_high)

# Calculate minimum high-priority cells for each comparison
min_fuse_edge2 <- min(sum(fuse_high), sum(edge2_high))
min_fuse_iucn <- min(sum(fuse_high), sum(iucn_high))
min_edge2_iucn <- min(sum(edge2_high), sum(iucn_high))

# Calculate percentage overlaps (conservative estimate)
overlap_fuse_edge2 <- (observed_fuse_edge2 / min_fuse_edge2) * 100
overlap_fuse_iucn <- (observed_fuse_iucn / min_fuse_iucn) * 100
overlap_edge2_iucn <- (observed_edge2_iucn / min_edge2_iucn) * 100

# Randomization test function
randomization_test <- function(index1_high, index2_high, n_permutations = 999) {
  observed_overlap <- sum(index1_high & index2_high)
  min_cells <- min(sum(index1_high), sum(index2_high))
  observed_percentage <- (observed_overlap / min_cells) * 100
  
  # Generate random overlaps
  random_overlaps <- replicate(n_permutations, {
    # Randomly shuffle the spatial distribution of index1
    shuffled_index1 <- sample(index1_high)
    random_overlap <- sum(shuffled_index1 & index2_high)
    (random_overlap / min_cells) * 100
  })
  
  # Calculate p-value
  if (observed_percentage > mean(random_overlaps)) {
    p_value <- sum(random_overlaps >= observed_percentage) / n_permutations
  } else {
    p_value <- sum(random_overlaps <= observed_percentage) / n_permutations
  }
  
  return(list(
    observed_percentage = observed_percentage,
    expected_percentage = mean(random_overlaps),
    p_value = p_value,
    random_overlaps = random_overlaps
  ))
}

# Perform randomization tests
print("=== STATISTICAL CONGRUENCE ANALYSIS ===")
cat("Threshold for high-priority areas:", priority_threshold, "\n\n")

# FUSE vs EDGE2
test_fuse_edge2 <- randomization_test(fuse_high, edge2_high)
cat("FUSE vs EDGE2:\n")
cat("Observed overlap:", round(test_fuse_edge2$observed_percentage, 2), "%\n")
cat("Expected overlap:", round(test_fuse_edge2$expected_percentage, 2), "%\n")
cat("P-value:", test_fuse_edge2$p_value, "\n\n")

# FUSE vs IUCN
test_fuse_iucn <- randomization_test(fuse_high, iucn_high)
cat("FUSE vs IUCN:\n")
cat("Observed overlap:", round(test_fuse_iucn$observed_percentage, 2), "%\n")
cat("Expected overlap:", round(test_fuse_iucn$expected_percentage, 2), "%\n")
cat("P-value:", test_fuse_iucn$p_value, "\n\n")

# EDGE2 vs IUCN
test_edge2_iucn <- randomization_test(edge2_high, iucn_high)
cat("EDGE2 vs IUCN:\n")
cat("Observed overlap:", round(test_edge2_iucn$observed_percentage, 2), "%\n")
cat("Expected overlap:", round(test_edge2_iucn$expected_percentage, 2), "%\n")
cat("P-value:", test_edge2_iucn$p_value, "\n\n")

# Summary statistics
cat("SUMMARY:\n")
cat("Total high-priority cells:\n")
cat("- FUSE:", sum(fuse_high), "\n")
cat("- EDGE2:", sum(edge2_high), "\n")
cat("- IUCN:", sum(iucn_high), "\n")
cat("- All three indices:", observed_all_three, "\n")
cat("- Percentage of cells with full congruence:", 
    round((observed_all_three / max(sum(fuse_high), sum(edge2_high), sum(iucn_high))) * 100, 2), "%\n")

# Create a summary table
congruence_results <- data.frame(
  Comparison = c("FUSE vs EDGE2", "FUSE vs IUCN", "EDGE2 vs IUCN"),
  Observed_Overlap_Percent = c(test_fuse_edge2$observed_percentage,
                               test_fuse_iucn$observed_percentage,
                               test_edge2_iucn$observed_percentage),
  Expected_Overlap_Percent = c(test_fuse_edge2$expected_percentage,
                               test_fuse_iucn$expected_percentage,
                               test_edge2_iucn$expected_percentage),
  P_Value = c(test_fuse_edge2$p_value,
              test_fuse_iucn$p_value,
              test_edge2_iucn$p_value),
  Significance = c(
    ifelse(test_fuse_edge2$p_value < 0.001, "***",
           ifelse(test_fuse_edge2$p_value < 0.01, "**",
                  ifelse(test_fuse_edge2$p_value < 0.05, "*", "ns"))),
    ifelse(test_fuse_iucn$p_value < 0.001, "***",
           ifelse(test_fuse_iucn$p_value < 0.01, "**",
                  ifelse(test_fuse_iucn$p_value < 0.05, "*", "ns"))),
    ifelse(test_edge2_iucn$p_value < 0.001, "***",
           ifelse(test_edge2_iucn$p_value < 0.01, "**",
                  ifelse(test_edge2_iucn$p_value < 0.05, "*", "ns")))
  )
)

print(congruence_results)
```


## Relationship with fishing effort : ecoregion level scatterplots  

```{r}
library(here)
library(dplyr)
library(ggplot2)
library(sf)
library(rnaturalearth)
library(raster)
library(tidyr)
library(ggrepel)
library(ggsci)   # For nice color palettes

# Read all priority data
CAPTAIN2_EDGE2_data <- readRDS(here::here("Data/CAPTAIN2_EDGE_full_results_averaged_budget0.1_replicates50.rds"))
CAPTAIN2_FUSE_data <- readRDS(here::here("Data/CAPTAIN2_FUSE_res_full_results_averaged_budget0.1_replicates50.rds"))
CAPTAIN2_IUCN_data <- readRDS(here::here("Data/CAPTAIN2_IUCN_full_results_averaged_budget0.1_replicates50.rds"))

# Load fishing data
load(here::here("Data", "Raw", "Predicted_Fishing_Hours_05Deg.Rdata"))

# Load marine ecoregion shapefile
meow_ecos <- st_read(here("Data", "Shapefiles", "meow_ecos", "meow_ecos.shp"), quiet = TRUE)

# Load raster to get coordinate system
raster_file <- here::here("Data", "tif files continental", "Psammobatis_parvacauda.tif")
r <- raster(raster_file)

# Create coordinates for all grid cells
coords <- as.data.frame(coordinates(r))
names(coords) <- c("Longitude", "Latitude")
coords$PUID <- 1:nrow(coords)

#---------------------- FISHING DATA PROCESSING ----------------------#

# Convert aggregated_data to an sf object
fishing_sf <- aggregated_data %>%
  filter(!is.na(lon_05deg), !is.na(lat_05deg), !is.na(predicted_fishing_hours)) %>%
  st_as_sf(coords = c("lon_05deg", "lat_05deg"), crs = 4326)

# Make sure CRS matches
st_crs(fishing_sf) <- st_crs(meow_ecos)

# Process fishing data for ECOREGIONS
fishing_with_ecoregion <- st_join(fishing_sf, meow_ecos %>% dplyr::select(ECOREGION, REALM))

ecoregion_fishing_stats <- fishing_with_ecoregion %>%
  st_drop_geometry() %>%
  group_by(ECOREGION, REALM) %>%
  summarize(
    mean_fishing_hours = mean(predicted_fishing_hours, na.rm = TRUE),
    median_fishing_hours = median(predicted_fishing_hours, na.rm = TRUE),
    fishing_q05 = quantile(predicted_fishing_hours, 0.05, na.rm = TRUE),
    fishing_q95 = quantile(predicted_fishing_hours, 0.95, na.rm = TRUE),
    fishing_cells = n(),
    .groups = 'drop'
  ) %>%
  filter(!is.na(ECOREGION)) %>%
  arrange(desc(mean_fishing_hours))

#---------------------- PRIORITY DATA PROCESSING ----------------------#

# Combine all priority data with coordinates
combined_data <- CAPTAIN2_EDGE2_data %>%
  rename(Priority_EDGE2 = Priority) %>%
  left_join(CAPTAIN2_FUSE_data %>% dplyr::select(PUID, Priority) %>% rename(Priority_FUSE = Priority), by = "PUID") %>%
  left_join(CAPTAIN2_IUCN_data %>% dplyr::select(PUID, Priority) %>% rename(Priority_IUCN = Priority), by = "PUID") %>%
  left_join(coords, by = "PUID")

# Convert to sf object for each index
iucn_sf <- combined_data %>%
  filter(!is.na(Longitude), !is.na(Latitude), !is.na(Priority_IUCN)) %>%
  st_as_sf(coords = c("Longitude", "Latitude"), crs = 4326)

fuse_sf <- combined_data %>%
  filter(!is.na(Longitude), !is.na(Latitude), !is.na(Priority_FUSE)) %>%
  st_as_sf(coords = c("Longitude", "Latitude"), crs = 4326)

edge2_sf <- combined_data %>%
  filter(!is.na(Longitude), !is.na(Latitude), !is.na(Priority_EDGE2)) %>%
  st_as_sf(coords = c("Longitude", "Latitude"), crs = 4326)

# Make sure CRS matches
st_crs(iucn_sf) <- st_crs(meow_ecos)
st_crs(fuse_sf) <- st_crs(meow_ecos)
st_crs(edge2_sf) <- st_crs(meow_ecos)

# Process priority data for ECOREGIONS - IUCN
iucn_with_ecoregion <- st_join(iucn_sf, meow_ecos %>% dplyr::select(ECOREGION, REALM))
ecoregion_iucn_stats <- iucn_with_ecoregion %>%
  st_drop_geometry() %>%
  group_by(ECOREGION, REALM) %>%
  summarize(
    mean_priority = mean(Priority_IUCN, na.rm = TRUE),
    median_priority = median(Priority_IUCN, na.rm = TRUE),
    priority_q05 = quantile(Priority_IUCN, 0.05, na.rm = TRUE),
    priority_q95 = quantile(Priority_IUCN, 0.95, na.rm = TRUE),
    priority_cells = n(),
    .groups = 'drop'
  ) %>%
  filter(!is.na(ECOREGION)) %>%
  arrange(desc(mean_priority))

# Process priority data for ECOREGIONS - FUSE
fuse_with_ecoregion <- st_join(fuse_sf, meow_ecos %>% dplyr::select(ECOREGION, REALM))
ecoregion_fuse_stats <- fuse_with_ecoregion %>%
  st_drop_geometry() %>%
  group_by(ECOREGION, REALM) %>%
  summarize(
    mean_priority = mean(Priority_FUSE, na.rm = TRUE),
    median_priority = median(Priority_FUSE, na.rm = TRUE),
    priority_q05 = quantile(Priority_FUSE, 0.05, na.rm = TRUE),
    priority_q95 = quantile(Priority_FUSE, 0.95, na.rm = TRUE),
    priority_cells = n(),
    .groups = 'drop'
  ) %>%
  filter(!is.na(ECOREGION)) %>%
  arrange(desc(mean_priority))

# Process priority data for ECOREGIONS - EDGE2
edge2_with_ecoregion <- st_join(edge2_sf, meow_ecos %>% dplyr::select(ECOREGION, REALM))
ecoregion_edge2_stats <- edge2_with_ecoregion %>%
  st_drop_geometry() %>%
  group_by(ECOREGION, REALM) %>%
  summarize(
    mean_priority = mean(Priority_EDGE2, na.rm = TRUE),
    median_priority = median(Priority_EDGE2, na.rm = TRUE),
    priority_q05 = quantile(Priority_EDGE2, 0.05, na.rm = TRUE),
    priority_q95 = quantile(Priority_EDGE2, 0.95, na.rm = TRUE),
    priority_cells = n(),
    .groups = 'drop'
  ) %>%
  filter(!is.na(ECOREGION)) %>%
  arrange(desc(mean_priority))

#---------------------- MERGE DATASETS FOR SCATTERPLOTS ----------------------#

# Merge ECOREGION data for each index
ecoregion_combined_iucn <- inner_join(
  ecoregion_fishing_stats, 
  ecoregion_iucn_stats, 
  by = c("ECOREGION", "REALM")) %>%
  mutate(cell_ratio = fishing_cells / priority_cells)

ecoregion_combined_fuse <- inner_join(
  ecoregion_fishing_stats, 
  ecoregion_fuse_stats, 
  by = c("ECOREGION", "REALM")) %>%
  mutate(cell_ratio = fishing_cells / priority_cells)

ecoregion_combined_edge2 <- inner_join(
  ecoregion_fishing_stats, 
  ecoregion_edge2_stats, 
  by = c("ECOREGION", "REALM")) %>%
  mutate(cell_ratio = fishing_cells / priority_cells)

#---------------------- CREATE ECOREGION SCATTERPLOTS ----------------------#

# IUCN - Get top 5 fishing and top 5 priority ecoregions
top_fishing_iucn <- ecoregion_combined_iucn %>%
  arrange(desc(mean_fishing_hours)) %>%
  head(5) %>%
  pull(ECOREGION)

top_priority_iucn <- ecoregion_combined_iucn %>%
  arrange(desc(mean_priority)) %>%
  head(5) %>%
  pull(ECOREGION)

ecoregions_to_label_iucn <- unique(c(top_fishing_iucn, top_priority_iucn))
label_data_iucn <- ecoregion_combined_iucn %>%
  filter(ECOREGION %in% ecoregions_to_label_iucn)

# Create IUCN plot
iucn_ecoregion_plot <- ggplot(ecoregion_combined_iucn,
                             aes(x = mean_fishing_hours, y = mean_priority)) +
  geom_point(aes(size = fishing_cells, color = REALM), alpha = 0.4) +
  geom_label_repel(
    data = label_data_iucn,
    aes(label = ECOREGION),
    size = 3,
    max.overlaps = 10,
    box.padding = 0.5
  ) +
  scale_x_log10() +
  scale_size_continuous(name = "Number of cells", range = c(1, 8)) +
  scale_color_manual(values = c("red", "blue", "darkgreen", "purple", "orange", "brown", 
                               "black", "pink", "darkgray", "navy", "darkred", "forestgreen")) +
  labs(title = "Relationship between fishing pressure and conservation priority",
       subtitle = "By ecoregion (IUCN)",
       x = "Mean fishing hours (log scale)",
       y = "Mean conservation priority (IUCN)") +
  theme_minimal() +
  guides(color = guide_legend(title = "Realm", override.aes = list(size = 4)))

# FUSE - Get top 5 fishing and top 5 priority ecoregions
top_fishing_fuse <- ecoregion_combined_fuse %>%
  arrange(desc(mean_fishing_hours)) %>%
  head(5) %>%
  pull(ECOREGION)

top_priority_fuse <- ecoregion_combined_fuse %>%
  arrange(desc(mean_priority)) %>%
  head(5) %>%
  pull(ECOREGION)

ecoregions_to_label_fuse <- unique(c(top_fishing_fuse, top_priority_fuse))
label_data_fuse <- ecoregion_combined_fuse %>%
  filter(ECOREGION %in% ecoregions_to_label_fuse)

# Create FUSE plot
fuse_ecoregion_plot <- ggplot(ecoregion_combined_fuse,
                             aes(x = mean_fishing_hours, y = mean_priority)) +
  geom_point(aes(size = fishing_cells, color = REALM), alpha = 0.4) +
  geom_label_repel(
    data = label_data_fuse,
    aes(label = ECOREGION),
    size = 3,
    max.overlaps = 10,
    box.padding = 0.5
  ) +
  scale_x_log10() +
  scale_size_continuous(name = "Number of Cells", range = c(1, 8)) +
  scale_color_manual(values = c("red", "blue", "darkgreen", "purple", "orange", "brown", 
                               "black", "pink", "darkgray", "navy", "darkred", "forestgreen")) +
  labs(title = "Relationship between fishing pressure and conservation priority",
       subtitle = "By ecoregion (FUSE)",
       x = "Mean fishing hours (log scale)",
       y = "Mean conservation priority (FUSE)") +
  theme_minimal() +
  guides(color = guide_legend(title = "Realm", override.aes = list(size = 4)))

# EDGE2 - Get top 5 fishing and top 5 priority ecoregions
top_fishing_edge2 <- ecoregion_combined_edge2 %>%
  arrange(desc(mean_fishing_hours)) %>%
  head(5) %>%
  pull(ECOREGION)

top_priority_edge2 <- ecoregion_combined_edge2 %>%
  arrange(desc(mean_priority)) %>%
  head(5) %>%
  pull(ECOREGION)

ecoregions_to_label_edge2 <- unique(c(top_fishing_edge2, top_priority_edge2))
label_data_edge2 <- ecoregion_combined_edge2 %>%
  filter(ECOREGION %in% ecoregions_to_label_edge2)

# Create EDGE2 plot
edge2_ecoregion_plot <- ggplot(ecoregion_combined_edge2,
                              aes(x = mean_fishing_hours, y = mean_priority)) +
  geom_point(aes(size = fishing_cells, color = REALM), alpha = 0.4) +
  geom_label_repel(
    data = label_data_edge2,
    aes(label = ECOREGION),
    size = 3,
    max.overlaps = 10,
    box.padding = 0.5
  ) +
  scale_x_log10() +
  scale_size_continuous(name = "Number of Cells", range = c(1, 8)) +
  scale_color_manual(values = c("red", "blue", "darkgreen", "purple", "orange", "brown", 
                               "black", "pink", "darkgray", "navy", "darkred", "forestgreen")) +
  labs(title = "Relationship between fishing pressure and conservation priority",
       subtitle = "By ecoregion (EDGE2)",
       x = "Mean fishing hours (log scale)",
       y = "Mean conservation priority (EDGE2)") +
  theme_minimal() +
  guides(color = guide_legend(title = "Realm", override.aes = list(size = 4)))

# Create the plots without titles and legends (we'll use a shared legend)

# IUCN Plot
iucn_ecoregion_plot <- ggplot(ecoregion_combined_iucn,
                             aes(x = mean_fishing_hours, y = mean_priority)) +
  geom_point(aes(size = fishing_cells, color = REALM), alpha = 0.4) +
  geom_label_repel(
    data = label_data_iucn,
    aes(label = ECOREGION),
    size = 3,
    max.overlaps = 10,
    box.padding = 0.5
  ) +
  scale_x_log10() +
  scale_size_continuous(name = "Number of cells", range = c(1, 8)) +
  scale_color_manual(values = c("red", "blue", "darkgreen", "purple", "orange", "brown", 
                               "black", "pink", "darkgray", "navy", "darkred", "forestgreen")) +
  labs(x = "Mean fishing hours (log scale)",
       y = "Mean conservation priority") +
  theme_minimal() +
  theme(
    legend.position = "none",  # Remove legend from individual plots
    panel.grid.minor = element_blank(),
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "white", color = NA)
  ) +
  guides(
    color = guide_legend(title = "Realm", override.aes = list(size = 4, alpha = 1)),
    size = guide_legend(title = "Number of cells")
  )

# FUSE Plot
fuse_ecoregion_plot <- ggplot(ecoregion_combined_fuse,
                             aes(x = mean_fishing_hours, y = mean_priority)) +
  geom_point(aes(size = fishing_cells, color = REALM), alpha = 0.4) +
  geom_label_repel(
    data = label_data_fuse,
    aes(label = ECOREGION),
    size = 3,
    max.overlaps = 10,
    box.padding = 0.5
  ) +
  scale_x_log10() +
  scale_size_continuous(name = "Number of cells", range = c(1, 8)) +
  scale_color_manual(values = c("red", "blue", "darkgreen", "purple", "orange", "brown", 
                               "black", "pink", "darkgray", "navy", "darkred", "forestgreen")) +
  labs(x = "Mean fishing hours (log scale)",
       y = "Mean conservation priority") +
  theme_minimal() +
  theme(
    legend.position = "none",  # Remove legend from individual plots
    panel.grid.minor = element_blank(),
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "white", color = NA)
  ) +
  guides(
    color = guide_legend(title = "Realm", override.aes = list(size = 4, alpha = 1)),
    size = guide_legend(title = "Number of cells")
  )

# EDGE2 Plot
edge2_ecoregion_plot <- ggplot(ecoregion_combined_edge2,
                              aes(x = mean_fishing_hours, y = mean_priority)) +
  geom_point(aes(size = fishing_cells, color = REALM), alpha = 0.4) +
  geom_label_repel(
    data = label_data_edge2,
    aes(label = ECOREGION),
    size = 3,
    max.overlaps = 10,
    box.padding = 0.5
  ) +
  scale_x_log10() +
  scale_size_continuous(name = "Number of cells", range = c(1, 8)) +
  scale_color_manual(values = c("red", "blue", "darkgreen", "purple", "orange", "brown", 
                               "black", "pink", "darkgray", "navy", "darkred", "forestgreen")) +
  labs(x = "Mean fishing hours (log scale)",
       y = "Mean conservation priority") +
  theme_minimal() +
  theme(
    legend.position = "none",  # Remove legend from individual plots
    panel.grid.minor = element_blank(),
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "white", color = NA)
  ) +
  guides(
    color = guide_legend(title = "Realm", override.aes = list(size = 4, alpha = 1)),
    size = guide_legend(title = "Number of cells")
  )

# Create one plot with legend for extracting the common legend
legend_plot <- ggplot(ecoregion_combined_iucn,
                     aes(x = mean_fishing_hours, y = mean_priority)) +
  geom_point(aes(size = fishing_cells, color = REALM), alpha = 0.4) +
  scale_size_continuous(name = "Number of Cells", range = c(1, 8)) +
  scale_color_manual(values = c("red", "blue", "darkgreen", "purple", "orange", "brown", 
                               "black", "pink", "darkgray", "navy", "darkred", "forestgreen")) +
  guides(
    color = guide_legend(title = "Realm", override.aes = list(size = 4, alpha = 1)),
    size = guide_legend(title = "Number of cells")
  ) +
  theme_minimal() +
  theme(
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "white", color = NA)
  )

# Create a blank plot for the legend position
blank_plot <- ggplot() + theme_void()

# Extract the legend as a separate grob
legend_grob <- cowplot::get_legend(legend_plot)

# Use ggpubr::ggarrange to combine plots in a 2x2 grid with legend in position 4
library(ggpubr)
combined_ecoregion_plots <- ggarrange(
  iucn_ecoregion_plot, fuse_ecoregion_plot, 
  edge2_ecoregion_plot, as_ggplot(legend_grob),
  labels = c("(A)", "(B)", "(C)", ""),  # No label for legend position
  ncol = 2, nrow = 2
)

# Ensure white background for the entire combined plot
combined_ecoregion_plots <- combined_ecoregion_plots + 
  theme(plot.background = element_rect(fill = "white", color = NA))

# Print the combined plot
print(combined_ecoregion_plots)

# Save the plot with adjusted dimensions for 2x2 layout and explicit white background
ggsave(here::here("outputs", "ecoregion_fishing_priority_relationship.png"), 
       combined_ecoregion_plots, 
       width = 12, height = 10, dpi = 300, bg = "white")

# Print summary statistics
cat("Summary of ecoregion-level analysis:\n")
cat("Ecoregions analyzed - IUCN:", nrow(ecoregion_combined_iucn), "\n")
cat("Ecoregions analyzed - FUSE:", nrow(ecoregion_combined_fuse), "\n")
cat("Ecoregions analyzed - EDGE2:", nrow(ecoregion_combined_edge2), "\n\n")

# Show labeled ecoregions for each index
cat("Ecoregions labeled in IUCN plot:\n")
print(label_data_iucn %>% dplyr::select(ECOREGION, REALM, mean_fishing_hours, mean_priority) %>% arrange(desc(mean_priority)))

cat("\nEcoregions labeled in FUSE plot:\n")
print(label_data_fuse %>% dplyr::select(ECOREGION, REALM, mean_fishing_hours, mean_priority) %>% arrange(desc(mean_priority)))

cat("\nEcoregions labeled in EDGE2 plot:\n")
print(label_data_edge2 %>% dplyr::select(ECOREGION, REALM, mean_fishing_hours, mean_priority) %>% arrange(desc(mean_priority)))

# Optional: Create individual plots if needed
# print(iucn_ecoregion_plot)
# print(fuse_ecoregion_plot) 
# print(edge2_ecoregion_plot)

# The main combined plot is printed above

```

## Relationship with fishing effort : bivariate maps  

```{r}
# Load required packages
library(tidyverse)      # For data manipulation and visualization
library(sf)             # For spatial data handling
library(rnaturalearth)  # For world map data
library(rnaturalearthdata) # Additional natural earth data
library(biscale)        # For bivariate mapping
library(gridExtra)      # For arranging multiple plots
library(grid)           # For text elements in plots
library(colorspace)     # For color manipulation
library(here)           # For file path management

# Load your CAPTAIN data
IUCN_data <- CAPTAIN2_IUCN_data_nonzero  # Assuming this exists from your previous code
FUSE_data <- CAPTAIN2_FUSE_data_nonzero  # Assuming this exists from your previous code
EDGE2_data <- CAPTAIN2_EDGE2_data_nonzero # Assuming this exists from your previous code

# Load fishing data
load(here::here("Data", "Raw", "Predicted_Fishing_Hours_05Deg.Rdata"))

# Process and prepare the data function
process_bivariate_data <- function(priority_data, fishing_data, min_priority = 0) {
  # Filter for cells with priority > min_priority
  priority_data_filtered <- priority_data %>%
    filter(Priority > min_priority)
  
  # Prepare fishing data
  fishing_data <- fishing_data %>%
    rename(Longitude = lon_05deg, Latitude = lat_05deg, FishingHours = predicted_fishing_hours)
  
  # Join datasets
  combined_data <- priority_data_filtered %>%
    left_join(fishing_data, by = c("Longitude", "Latitude"))
  
  # Handle NAs in fishing hours (replace with 0)
  combined_data$FishingHours[is.na(combined_data$FishingHours)] <- 0
  
  # Normalize priorities to 0-1 range and log transform fishing hours
  combined_data <- combined_data %>%
    mutate(
      Priority_Norm = Priority, # Assuming already in 0-1 range
      # Log transform fishing hours to better handle skewed distribution
      FishingHours_Log = log1p(FishingHours),
      # Normalize log fishing hours
      FishingHours_Norm = (FishingHours_Log - min(FishingHours_Log, na.rm = TRUE)) /
                         (max(FishingHours_Log, na.rm = TRUE) - min(FishingHours_Log, na.rm = TRUE))
    )
  
  # Set projection
  mcbryde_thomas_2 <- "+proj=mbt_s"
  
  # Transform to sf object
  data_sf <- st_as_sf(combined_data, coords = c("Longitude", "Latitude"), crs = 4326) %>%
    st_transform(crs = mcbryde_thomas_2)
  
  return(data_sf)
}

# Process the three datasets with fishing data (only cells with Priority > 0)
iucn_fishing_sf <- process_bivariate_data(IUCN_data, aggregated_data, min_priority = 0)
fuse_fishing_sf <- process_bivariate_data(FUSE_data, aggregated_data, min_priority = 0)
edge2_fishing_sf <- process_bivariate_data(EDGE2_data, aggregated_data, min_priority = 0)

# Create color palette - using the PurpleOr scheme
create_bivariate_palette <- function() {
  map_pal_raw <- bi_pal(pal = 'PurpleOr', dim = 4, preview = FALSE)
  map_pal_mtx <- matrix(map_pal_raw, nrow = 4, ncol = 4)
  map_pal_mtx[3, ] <- colorspace::lighten(map_pal_mtx[3, ], .1)
  map_pal_mtx[2, ] <- colorspace::lighten(map_pal_mtx[2, ], .2)
  map_pal_mtx[1, ] <- colorspace::lighten(map_pal_mtx[1, ], .3)
  map_pal_mtx[ , 3] <- colorspace::lighten(map_pal_mtx[ , 3], .1)
  map_pal_mtx[ , 2] <- colorspace::lighten(map_pal_mtx[ , 2], .2)
  map_pal_mtx[ , 1] <- colorspace::lighten(map_pal_mtx[ , 1], .3)
  map_pal_mtx[1, 1] <- '#ffffee'
  map_pal <- as.vector(map_pal_mtx) %>% setNames(names(map_pal_raw))
  return(map_pal)
}

map_pal <- create_bivariate_palette()

# Color mapping function
get_color <- function(priority, fishing) {
  priority_class <- cut(priority, breaks = c(-Inf, 0.25, 0.5, 0.75, Inf), labels = 1:4)
  fishing_class <- cut(fishing, breaks = c(-Inf, 0.25, 0.5, 0.75, Inf), labels = 1:4)
  return(map_pal[(as.numeric(fishing_class)-1)*4 + as.numeric(priority_class)])
}

# Apply colors to the datasets
iucn_fishing_sf$bivariate_color <- mapply(get_color,
                                          iucn_fishing_sf$Priority_Norm,
                                          iucn_fishing_sf$FishingHours_Norm)

fuse_fishing_sf$bivariate_color <- mapply(get_color,
                                          fuse_fishing_sf$Priority_Norm,
                                          fuse_fishing_sf$FishingHours_Norm)

edge2_fishing_sf$bivariate_color <- mapply(get_color,
                                          edge2_fishing_sf$Priority_Norm,
                                          edge2_fishing_sf$FishingHours_Norm)

# Get world map and project
world <- ne_countries(scale = "medium", returnclass = "sf")
mcbryde_thomas_2 <- "+proj=mbt_s"
world_projected <- st_transform(world, crs = mcbryde_thomas_2)

# Create globe border
lon_points <- rep(c(-180, 180), each = 100)
lat_points <- c(seq(-90, 90, length.out = 100), seq(90, -90, length.out = 100))
globe_outline <- data.frame(lon = lon_points, lat = lat_points) %>%
  st_as_sf(coords = c("lon", "lat"), crs = 4326) %>%
  st_combine() %>%
  st_cast("POLYGON") %>%
  st_transform(crs = mcbryde_thomas_2)

# Function to create individual bivariate maps with labels and titles
create_bivariate_map <- function(data_sf, label, title) {
  ggplot() +
    geom_sf(data = data_sf, aes(color = bivariate_color), size = 0.1, alpha = 1) +
    geom_sf(data = world_projected, fill = "lightgray", color = "lightgray") +
    geom_sf(data = globe_outline, fill = NA, color = "grey70", size = 0.5) +
    scale_color_identity() +
    coord_sf() +
    theme_minimal() +
    labs(x = NULL, y = NULL, title = title) +  # Added title
    theme(panel.grid = element_blank(),
          axis.text = element_blank(),
          axis.ticks = element_blank(),
          plot.title = element_text(size = 14, face = "bold", hjust = 0.5),  # Title styling
          plot.margin = margin(5, 5, 5, 5, "mm")) +
    # Add smaller label in top-left corner
    annotate("text", x = -Inf, y = Inf, label = label,
             hjust = -0.2, vjust = 1.2, size = 4, fontface = "bold")  # Reduced from 8 to 4
}

# Create the three maps with labels and titles
iucn_plot <- create_bivariate_map(iucn_fishing_sf, "(A)", "IUCN")
fuse_plot <- create_bivariate_map(fuse_fishing_sf, "(B)", "FUSE")  
edge2_plot <- create_bivariate_map(edge2_fishing_sf, "(C)", "EDGE2")

# Create a larger legend for better visibility
larger_legend <- bi_legend(pal = map_pal, dim = 4,
                          xlab = 'Conservation\npriority',
                          ylab = 'Fishing\neffort',
                          size = 4) +  # Increased from 3 to 4 for bigger legend
  theme(
    axis.title = element_text(size = 10, face = "bold"),  # Reduced from 12 to 10
    axis.text = element_blank(),
    legend.text = element_text(size = 8),  # Reduced from 10 to 8
    legend.title = element_text(size = 10, face = "bold"),  # Reduced from 12 to 10
    plot.margin = margin(10, 10, 10, 10, "mm")
  )

# Create layout matrix: 3 rows, 2 columns
# Column 1: maps (wider)
# Column 2: empty, legend (middle row), empty
layout_matrix <- rbind(
  c(1, NA),      # Row 1: Map A, empty
  c(2, 4),       # Row 2: Map B, legend
  c(3, NA)       # Row 3: Map C, empty
)

# Arrange all plots together
combined_plot <- grid.arrange(
  iucn_plot,
  fuse_plot,
  edge2_plot,
  larger_legend,
  layout_matrix = layout_matrix,
  heights = c(1, 1, 1),      # Equal height for all three map rows
  widths = c(3, 1)           # Maps take 3/4 width, legend takes 1/4
)

# Display the plot
print(combined_plot)

# Print summary statistics
cat("Summary Statistics (Priority > 0 cells only):\n")
cat("IUCN cells (A):", nrow(iucn_fishing_sf), "\n")
cat("FUSE cells (B):", nrow(fuse_fishing_sf), "\n")
cat("EDGE2 cells (C):", nrow(edge2_fishing_sf), "\n")

# Save with dimensions better suited for A4 portrait
ggsave(here::here("outputs", "All_indices_fishing_bivariate_maps_vertical.png"),
       combined_plot, width = 8.3, height = 11, dpi = 300, bg = "white")  # A4 portrait dimensions
```

## Maps of SR, FUn and EDGE2  

```{r}

# Sepcies richness ----
# Load required libraries
library(here)
library(terra)
library(ggplot2)
library(viridis)
library(sf)
library(rnaturalearth)
library(smoothr)

# Set the path to your raster files
raster_path <- here("Data", "tif files continental")

# Get list of all TIF files in the directory
tif_files <- list.files(raster_path, pattern = "\\.tif$", full.names = TRUE)

# Check if files were found
if(length(tif_files) == 0) {
  stop("No TIF files found in the specified directory")
}

print(paste("Found", length(tif_files), "TIF files"))

# Read all rasters into a SpatRaster stack
species_rasters <- rast(tif_files)

# Calculate species richness by summing across all layers
# This assumes presence = 1, absence = 0 or NA
species_richness <- sum(species_rasters, na.rm = TRUE)

# Name the layer
names(species_richness) <- "Species_Richness"

# Create a basic plot
#plot(species_richness, 
#     main = "Species Richness Map",
#     col = viridis(100))

# Alternative: Create a ggplot map with McBryde-Thomas 2 projection
# Get world map data
world <- ne_countries(scale = "medium", returnclass = "sf")

# Define the McBryde-Thomas 2 projection
mcbryde_thomas_2 <- "+proj=mbt_s"

# Project the species richness raster to McBryde-Thomas 2
species_richness_projected <- project(species_richness, mcbryde_thomas_2)

# Convert to dataframe for ggplot
richness_df <- as.data.frame(species_richness_projected, xy = TRUE)

# Remove NA values for cleaner plotting
richness_df <- richness_df[!is.na(richness_df$Species_Richness), ]

# Project the world map
world_projected <- st_transform(world, crs = mcbryde_thomas_2)

# Create the globe bounding box
globe_bbox <- rbind(c(-180, -90), c(-180, 90), 
                    c(180, 90), c(180, -90), c(-180, -90))

# Create the globe border
globe_border <- st_polygon(list(globe_bbox)) %>%
  st_sfc(crs = 4326) %>%
  st_sf(data.frame(rgn = 'globe', geom = .)) %>%
  smoothr::densify(max_distance = 0.5) %>%
  st_transform(crs = mcbryde_thomas_2)

# Create base theme
my_theme <- theme_minimal() +
  theme(
    legend.position = "bottom",
    legend.direction = "horizontal",
    legend.box = "vertical",
    legend.margin = margin(t = 20, r = 0, b = 0, l = 0),
    legend.title = element_text(margin = margin(b = 10)),
    panel.background = element_rect(fill = "white", color = NA),
    plot.background = element_rect(fill = "white", color = NA),
    panel.grid = element_blank(),
    axis.text = element_blank(),      # Add this line
    axis.ticks = element_blank()      # Add this line
  )

# Convert richness data to sf points for proper clipping
richness_sf <- st_as_sf(richness_df, coords = c("x", "y"), crs = mcbryde_thomas_2)

# Clip the richness data to the globe boundary
richness_clipped <- st_intersection(richness_sf, globe_border)

# Extract coordinates back for plotting
richness_clipped_coords <- st_coordinates(richness_clipped)
richness_final <- data.frame(
  x = richness_clipped_coords[,1],
  y = richness_clipped_coords[,2],
  Species_Richness = richness_clipped$Species_Richness
)

# Create ggplot map
species_richness_plot <- ggplot() +
  geom_tile(data = richness_final, aes(x = x, y = y, fill = Species_Richness)) +
  geom_sf(data = world_projected, fill = "lightgrey", color = "lightgrey", size = 0.1) +
  geom_sf(data = globe_border, fill = NA, color = "black", size = 0.5) +
  scale_fill_viridis_c(
    name = "Species\nRichness",
    guide = guide_colorbar(barwidth = 20, barheight = 0.5, 
                         title.position = "top", title.hjust = 0.5)
  ) +
  coord_sf(crs = mcbryde_thomas_2, expand = FALSE) +
  labs(title = "Global Species Richness Map",
       x = NULL, y = NULL) +
  my_theme

# Display the plot
print(species_richness_plot)

# Richness of threatened species, top 25% FUSE and top 25% EDGE2 ----

# Load required libraries
library(here)
library(terra)
library(ggplot2)
library(viridis)
library(sf)
library(rnaturalearth)
library(smoothr)
library(dplyr)

# Load the conservation metrics dataset
conservation_data <- read.csv(here("Data", "My dataframes", "continental_shark_conservation_metrics_10_harmonised_IUCN_csv.csv"))

# Filter for threatened species (IUCN values of 0.5, 0.75, or 1)
threatened_species <- conservation_data %>%
  filter(IUCN %in% c(0.5, 0.75, 1)) %>%
  pull(Species.name)

# Get top 25% FUSE scoring species by rank (not by threshold)
n_species <- nrow(conservation_data)
top_25_percent_count <- ceiling(n_species * 0.25)

top_fuse_species <- conservation_data %>%
  arrange(desc(FUSE)) %>%
  slice_head(n = top_25_percent_count) %>%
  pull(Species.name)

# Get top 25% EDGE2 scoring species by rank
top_edge2_species <- conservation_data %>%
  arrange(desc(EDGE2)) %>%
  slice_head(n = top_25_percent_count) %>%
  pull(Species.name)

# Get the actual threshold values for reporting
fuse_threshold <- conservation_data %>%
  arrange(desc(FUSE)) %>%
  slice(top_25_percent_count) %>%
  pull(FUSE)

edge2_threshold <- conservation_data %>%
  arrange(desc(EDGE2)) %>%
  slice(top_25_percent_count) %>%
  pull(EDGE2)

print(paste("Total species in dataset:", n_species))
print(paste("Top 25% count:", top_25_percent_count))
print(paste("Found", length(threatened_species), "threatened species"))
print(paste("Found", length(top_fuse_species), "top 25% FUSE species (threshold:", round(fuse_threshold, 4), ")"))
print(paste("Found", length(top_edge2_species), "top 25% EDGE2 species (threshold:", round(edge2_threshold, 4), ")"))

# Set the path to your raster files
raster_path <- here("Data", "tif files continental")

# Get list of all TIF files in the directory
all_tif_files <- list.files(raster_path, pattern = "\\.tif$", full.names = TRUE)

# Extract species names from file names (assuming filename format includes species name)
# You may need to adjust this pattern based on your actual file naming convention
file_species_names <- basename(all_tif_files)
file_species_names <- gsub("\\.tif$", "", file_species_names)

# Function to find matching raster files for a species list
find_matching_files <- function(species_list, all_files) {
  matching_files <- c()
  for(species in species_list) {
    # Create pattern to match species name in filename (handles spaces and underscores)
    species_pattern <- gsub(" ", "[_ ]", species)
    matches <- all_files[grepl(species_pattern, basename(all_files), ignore.case = TRUE)]
    matching_files <- c(matching_files, matches)
  }
  return(unique(matching_files))
}

# Find matching files for each species group
threatened_files <- find_matching_files(threatened_species, all_tif_files)
fuse_files <- find_matching_files(top_fuse_species, all_tif_files)
edge2_files <- find_matching_files(top_edge2_species, all_tif_files)

print(paste("Found", length(threatened_files), "raster files for threatened species"))
print(paste("Found", length(fuse_files), "raster files for top FUSE species"))
print(paste("Found", length(edge2_files), "raster files for top EDGE2 species"))

# Check if files were found
if(length(threatened_files) == 0) {
  stop("No matching TIF files found for threatened species. Please check file naming convention.")
}

# Read rasters and calculate richness for each group
# Threatened species
threatened_rasters <- rast(threatened_files)
threatened_richness <- sum(threatened_rasters, na.rm = TRUE)
names(threatened_richness) <- "Threatened_Species_Richness"

# Top FUSE species
fuse_rasters <- rast(fuse_files)
fuse_richness <- sum(fuse_rasters, na.rm = TRUE)
names(fuse_richness) <- "Top_FUSE_Richness"

# Top EDGE2 species
edge2_rasters <- rast(edge2_files)
edge2_richness <- sum(edge2_rasters, na.rm = TRUE)
names(edge2_richness) <- "Top_EDGE2_Richness"

# Create basic plots for all three metrics
#plot(threatened_richness, 
#     main = "Threatened Species Richness Map",
#     col = viridis(100))

#plot(fuse_richness, 
#     main = "Top 25% FUSE Species Richness Map",
#     col = viridis(100))

#plot(edge2_richness, 
#     main = "Top 25% EDGE2 Species Richness Map",
#     col = viridis(100))

# Function to create projected richness map
create_richness_map <- function(richness_raster, title, subtitle, legend_name) {
  # Project the richness raster to McBryde-Thomas 2
  richness_projected <- project(richness_raster, mcbryde_thomas_2)
  
  # Convert to dataframe for ggplot
  richness_df <- as.data.frame(richness_projected, xy = TRUE)
  colnames(richness_df)[3] <- "richness_value"
  
  # Remove NA values for cleaner plotting
  richness_df <- richness_df[!is.na(richness_df$richness_value), ]
  
  # Convert richness data to sf points for proper clipping
  richness_sf <- st_as_sf(richness_df, coords = c("x", "y"), crs = mcbryde_thomas_2)
  
  # Clip the richness data to the globe boundary
  richness_clipped <- st_intersection(richness_sf, globe_border)
  
  # Extract coordinates back for plotting
  richness_clipped_coords <- st_coordinates(richness_clipped)
  richness_final <- data.frame(
    x = richness_clipped_coords[,1],
    y = richness_clipped_coords[,2],
    richness_value = richness_clipped$richness_value
  )
  
  # Create ggplot map
  richness_plot <- ggplot() +
    geom_tile(data = richness_final, aes(x = x, y = y, fill = richness_value)) +
    geom_sf(data = world_projected, fill = "lightgrey", color = "lightgrey", size = 0.1) +
    geom_sf(data = globe_border, fill = NA, color = "black", size = 0.5) +
    scale_fill_viridis_c(
      name = legend_name,
      guide = guide_colorbar(barwidth = 20, barheight = 0.5, 
                           title.position = "top", title.hjust = 0.5)
    ) +
    coord_sf(crs = mcbryde_thomas_2, expand = FALSE) +
    labs(title = title,
         subtitle = subtitle,
         x = NULL, y = NULL) +
    my_theme
  
  return(richness_plot)
}

# Create maps for all three metrics
threatened_richness_plot <- create_richness_map(
  threatened_richness, 
  "Global Threatened Species Richness Map",
  "Species with IUCN threat levels 0.5, 0.75, or 1.0",
  "Threatened\nSpecies Richness"
)

fuse_richness_plot <- create_richness_map(
  fuse_richness,
  "Global Top 25% FUSE Species Richness Map", 
  paste("Species in top quartile of FUSE scores (‚â•", round(fuse_threshold, 4), ")"),
  "Top FUSE\nSpecies Richness"
)

edge2_richness_plot <- create_richness_map(
  edge2_richness,
  "Global Top 25% EDGE2 Species Richness Map",
  paste("Species in top quartile of EDGE2 scores (‚â•", round(edge2_threshold, 4), ")"),
  "Top EDGE2\nSpecies Richness"
)

# Display all plots
print(threatened_richness_plot)
print(fuse_richness_plot)
print(edge2_richness_plot)

```

## Differences between priority and normal richness maps   

```{r}
create_comparison_maps <- function(captain2_data, richness_raster, priority_threshold = 0.85, 
                                   comparison_name = "Comparison") {
  
  # Count grid cells with CAPTAIN2 priority > threshold
  high_priority_cells <- sum(captain2_data$Priority > priority_threshold, na.rm = TRUE)
  
  print(paste("CAPTAIN2", comparison_name, "cells with priority >", priority_threshold, ":", high_priority_cells))
  
  # Get the same number of top richness cells
  richness_values <- values(richness_raster, na.rm = TRUE)
  richness_threshold <- quantile(richness_values, 1 - (high_priority_cells / length(richness_values)), na.rm = TRUE)
  
  print(paste("Richness threshold for top", high_priority_cells, "cells:", round(richness_threshold, 2)))
  
  # Create binary rasters for comparison
  # CAPTAIN2 binary (1 = high priority, 0 = other)
  captain2_binary <- captain2_data
  captain2_binary$Binary_Priority <- ifelse(captain2_data$Priority > priority_threshold, 1, 0)
  
  # Richness binary (1 = top cells, 0 = other)  
  richness_binary <- richness_raster
  values(richness_binary) <- ifelse(values(richness_raster) >= richness_threshold, 1, 0)
  
  # Convert CAPTAIN2 data to sf if it's not already
  if(!inherits(captain2_binary, "sf")) {
    # Assuming captain2_data has Longitude and Latitude columns
    captain2_binary_sf <- st_as_sf(captain2_binary, 
                                   coords = c("Longitude", "Latitude"), 
                                   crs = 4326)
  } else {
    captain2_binary_sf <- captain2_binary
  }
  
  # Transform to match the richness raster CRS
  captain2_binary_sf <- st_transform(captain2_binary_sf, crs = crs(richness_binary))
  
  # Convert to raster using terra::rasterize with explicit method
  captain2_raster <- rasterize(captain2_binary_sf, richness_binary, 
                               field = "Binary_Priority", 
                               fun = "max",  # Use max to avoid averaging
                               background = 0)  # Set background to 0
  
  # Ensure we only have 0s and 1s
  captain2_raster[captain2_raster > 0] <- 1
  
  # Define the McBryde-Thomas 2 projection
  mcbryde_thomas_2 <- "+proj=mbt_s"
  
  # Calculate difference and debug each step
  difference_raster <- captain2_raster - richness_binary
  print(paste("Difference raster total cells:", ncell(difference_raster)))
  print(paste("Difference raster non-NA cells:", sum(!is.na(values(difference_raster)))))
  
  # Create a mask for cells where at least one method has priority (value = 1)
  priority_mask <- (captain2_raster == 1) | (richness_binary == 1)
  print(paste("Priority mask TRUE cells:", sum(values(priority_mask), na.rm = TRUE)))
  
  # Apply the mask to keep only priority cells
  difference_raster[!priority_mask] <- NA
  print(paste("After masking, non-NA cells:", sum(!is.na(values(difference_raster)))))
  
  # Project difference raster
  difference_projected <- project(difference_raster, mcbryde_thomas_2)
  print(paste("After projection, non-NA cells:", sum(!is.na(values(difference_projected)))))
  
  # Convert to dataframe and clip to globe
  diff_df <- as.data.frame(difference_projected, xy = TRUE)
  colnames(diff_df)[3] <- "difference"
  diff_df <- diff_df[!is.na(diff_df$difference), ]
  print(paste("After df conversion, rows:", nrow(diff_df)))
  
  # Convert to sf and clip
  diff_sf <- st_as_sf(diff_df, coords = c("x", "y"), crs = mcbryde_thomas_2)
  print(paste("SF object rows:", nrow(diff_sf)))
  
  # Create world map and globe border for this function
  world <- ne_countries(scale = "medium", returnclass = "sf")
  world_projected <- st_transform(world, crs = mcbryde_thomas_2)
  
  # Create the globe bounding box and border
  globe_bbox <- rbind(c(-180, -90), c(-180, 90), 
                      c(180, 90), c(180, -90), c(-180, -90))
  globe_border <- st_polygon(list(globe_bbox)) %>%
    st_sfc(crs = 4326) %>%
    st_sf(data.frame(rgn = 'globe', geom = .)) %>%
    smoothr::densify(max_distance = 0.5) %>%
    st_transform(crs = mcbryde_thomas_2)
  
  # Create base theme
  my_theme <- theme_minimal() +
    theme(
      legend.position = "bottom",
      legend.direction = "horizontal",
      legend.box = "vertical",
      legend.margin = margin(t = 20, r = 0, b = 0, l = 0),
      legend.title = element_text(margin = margin(b = 10)),
      panel.background = element_rect(fill = "white", color = NA),
      plot.background = element_rect(fill = "white", color = NA),
      panel.grid = element_blank()
    )
  
  diff_clipped <- st_intersection(diff_sf, globe_border)
  print(paste("After globe clipping, rows:", nrow(diff_clipped)))
  
  # Extract coordinates
  diff_coords <- st_coordinates(diff_clipped)
  diff_final <- data.frame(
    x = diff_coords[,1],
    y = diff_coords[,2],
    difference = diff_clipped$difference
  )
  print(paste("Final data rows:", nrow(diff_final)))
  
  # Create difference map
  diff_plot <- ggplot() +
    geom_tile(data = diff_final, aes(x = x, y = y, fill = factor(difference))) +
    geom_sf(data = world_projected, fill = "lightgrey", color = "lightgrey", size = 0.1) +
    geom_sf(data = globe_border, fill = NA, color = "black", size = 0.5) +
    scale_fill_manual(
      values = c("-1" = "red", "0" = "black", "1" = "blue"),
      labels = c("-1" = "Only Richness", "0" = "Agreement", "1" = "Only CAPTAIN2"),
      name = "Priority\nDifference",
      guide = guide_legend(title.position = "top", title.hjust = 0.5)
    ) +
    coord_sf(crs = mcbryde_thomas_2, expand = FALSE) +
    labs(title = paste("Priority Comparison:", comparison_name),
         subtitle = paste("CAPTAIN2 vs Simple Richness (", high_priority_cells, "top cells each)"),
         x = NULL, y = NULL) +
    my_theme +
    theme(legend.position = "bottom")
  
  # Calculate summary statistics
  total_cells <- nrow(diff_final)
  agreement_cells <- sum(diff_final$difference == 0, na.rm = TRUE)
  captain2_only <- sum(diff_final$difference == 1, na.rm = TRUE)
  richness_only <- sum(diff_final$difference == -1, na.rm = TRUE)
  
  agreement_percent <- (agreement_cells / total_cells) * 100
  captain2_only_percent <- (captain2_only / total_cells) * 100
  richness_only_percent <- (richness_only / total_cells) * 100
  
  # Print summary statistics with debugging info
  cat("\n========================================\n")
  cat("SUMMARY STATISTICS -", comparison_name, "\n")
  cat("========================================\n")
  cat("CAPTAIN2 priority cells:", high_priority_cells, "\n")
  cat("Richness priority cells:", high_priority_cells, "(same number)\n")
  cat("CAPTAIN2 raster 1s:", sum(values(captain2_raster) == 1, na.rm = TRUE), "\n")
  cat("Richness raster 1s:", sum(values(richness_binary) == 1, na.rm = TRUE), "\n")
  cat("Total priority cells compared:", total_cells, "\n")
  cat("----------------------------------------\n")
  cat("Agreement (both prioritize same cell):", agreement_cells, "(", round(agreement_percent, 2), "%)\n")
  cat("Only CAPTAIN2 prioritizes:", captain2_only, "(", round(captain2_only_percent, 2), "%)\n")
  cat("Only Richness prioritizes:", richness_only, "(", round(richness_only_percent, 2), "%)\n")
  cat("----------------------------------------\n")
  cat("Total accounted for:", round(agreement_percent + captain2_only_percent + richness_only_percent, 2), "%\n")
  cat("========================================\n\n")
  
  return(list(plot = diff_plot, 
              captain2_cells = high_priority_cells,
              richness_threshold = richness_threshold,
              total_cells = total_cells,
              agreement_cells = agreement_cells,
              agreement_percent = agreement_percent,
              captain2_only_percent = captain2_only_percent,
              richness_only_percent = richness_only_percent))
}

# Threatened species comparison
threatened_comparison <- create_comparison_maps(
  CAPTAIN2_IUCN_data_nonzero, 
  threatened_richness, 
  priority_threshold = 0.85,
  comparison_name = "Threatened Species"
)
print(threatened_comparison$plot)

# FUSE comparison  
fuse_comparison <- create_comparison_maps(
  CAPTAIN2_FUSE_data_nonzero,
  fuse_richness,
  priority_threshold = 0.85, 
  comparison_name = "FUSE"
)
print(fuse_comparison$plot)

# EDGE2 comparison
edge2_comparison <- create_comparison_maps(
  CAPTAIN2_EDGE2_data_nonzero,
  edge2_richness,
  priority_threshold = 0.85,
  comparison_name = "EDGE2" 
)
print(edge2_comparison$plot)
```


