---
title: "GAP analyses"
author: "Th√©ophile L. Mouton"
date: "October 9, 2024"
format:
  html:
    toc: true
    toc-location: right
    css: custom.css
    output-file: "GAP_analyses_EEZs.html"
    self-contained: true
    code-fold: true
    code-tools: true
editor: visual
execute:
  warning: false
  message: false
  echo: true
---

# Load the data

Load the grid and the MPA raster layers

```{r}
# Load necessary libraries
library(raster)
library(here)
library(sp)
library(dplyr)
library(tidyr)

# Load the data ----
load(here::here("Data", "GAP analyses", "puvsp_marine.Rdata"))

# Load the raster layers
mpa_ALL <- raster::raster(here::here("Data", "GAP analyses", "mpa_ALL_binary.tif"))
mpa_NT <- raster::raster(here::here("Data", "GAP analyses", "mpa_NT_binary.tif"))

```

# GAP analyses

GAP analyses of shark and ray range overlaps with Marine Protected Areas

```{r}
# Convert species dataframe to spatial points
species_points <- SpatialPointsDataFrame(coords = puvsp_marine[, c("lon", "lat")], 
                                         data = puvsp_marine, 
                                         proj4string = CRS(projection(mpa_ALL)))

# Extract MPA values for each species point
mpa_ALL_values <- raster::extract(mpa_ALL, species_points)
mpa_NT_values <- raster::extract(mpa_NT, species_points)

# Add MPA values to the species dataframe
puvsp_marine$mpa_ALL_present <- mpa_ALL_values
puvsp_marine$mpa_NT_present <- mpa_NT_values

# Function to calculate percentage of range in MPA
calculate_mpa_percentage <- function(species_column, mpa_column) {
  species_presence <- species_column == 1  # Assuming 1 indicates species presence
  total_range <- sum(species_presence, na.rm = TRUE)
  range_in_mpa <- sum(species_presence & mpa_column == 1, na.rm = TRUE)
  
  if (total_range == 0) {
    return(NA)  # Return NA if the species is not present anywhere
  }
  
  percentage <- (range_in_mpa / total_range) * 100
  return(percentage)
}

# Apply function to all species columns for both MPA types
species_columns <- 4:(ncol(puvsp_marine) - 2)  # Assuming species columns start at 4
mpa_ALL_percentages <- sapply(puvsp_marine[, species_columns], 
                              function(x) calculate_mpa_percentage(x, puvsp_marine$mpa_ALL_present))
mpa_NT_percentages <- sapply(puvsp_marine[, species_columns], 
                             function(x) calculate_mpa_percentage(x, puvsp_marine$mpa_NT_present))

# Create a dataframe with results
results <- data.frame(
  species = names(mpa_ALL_percentages),
  percentage_in_ALL_MPA = mpa_ALL_percentages,
  percentage_in_NT_MPA = mpa_NT_percentages
)

# Remove any NA results
results <- results[!is.na(results$percentage_in_ALL_MPA) & !is.na(results$percentage_in_NT_MPA), ]

# Sort results by percentage in ALL MPAs (descending)
results <- results[order(-results$percentage_in_ALL_MPA), ]

# Display top 10 species
#print(head(results, 10))

# Summary statistics
cat("\nSummary Statistics for ALL MPAs:\n")
print(summary(results$percentage_in_ALL_MPA))
print(sd(results$percentage_in_ALL_MPA))

cat("\nSummary Statistics for No-Take MPAs:\n")
print(summary(results$percentage_in_NT_MPA))
print(sd(results$percentage_in_NT_MPA))

# Save results to CSV
write.csv(results, here::here("Data","species_mpa_coverage_ALL_and_NT.csv"), row.names = FALSE)
```

# Null model of MPA placement within EEZs

Null model of MPA placement and overlaps with the range of sharks and rays

```{r}
library(raster)
library(here)
library(sp)
library(sf)
library(parallel)
library(pbapply)

# Load the bathymetry raster
Bathy <- raster(here::here("Data", "bathymetry-0.1deg-adjusted.tif"))

# Create marine mask from bathymetry (areas < 0)
marine_mask <- Bathy < 0

# Resample marine mask to match MPA raster resolution
marine_mask_resampled <- raster::resample(marine_mask, mpa_ALL, method = "ngb")

# Ensure marine_mask_resampled is binary (0 or 1)
marine_mask_resampled <- raster::reclassify(marine_mask_resampled, c(-Inf, 0.5, 0, 0.5, Inf, 1))

# Load the EEZ shapefile
eez <- st_read(here("Data", "World_EEZ_v12_20231025", "eez_v12.shp"), quiet = TRUE)

# Function to create a raster mask of EEZs with unique values for each country
create_eez_mask <- function(template_raster) {
  # Ensure EEZ has a unique identifier for each country
  eez$country_id <- as.numeric(as.factor(eez$SOVEREIGN1))
  
  # Rasterize the EEZ shapefile using the country_id
  eez_raster <- rasterize(eez, template_raster, field = "country_id")
  
  return(eez_raster)
}

# Updated create_random_mpa function to randomize within each country's EEZ
create_random_mpa <- function(template_raster, marine_mask, eez_mask) {
  # Ensure template_raster is binary
  template_raster <- raster::reclassify(template_raster, c(-Inf, 0.5, 0, 0.5, Inf, 1))
  
  # Combine marine_mask and eez_mask
  combined_mask <- marine_mask * (eez_mask > 0)
  
  # Get unique country IDs
  country_ids <- unique(eez_mask[!is.na(eez_mask)])
  country_ids <- country_ids[country_ids > 0]
  
  # Initialize random raster
  random_raster <- template_raster
  random_raster[] <- NA
  
  for (country_id in country_ids) {
    # Create mask for current country
    country_mask <- eez_mask == country_id
    
    # Count original marine MPA cells within current country's EEZ
    original_mpa_cells <- sum(template_raster[] == 1 & country_mask[] & !is.na(combined_mask[]), na.rm = TRUE)
    
    # Get all valid cells for current country (marine areas within EEZ)
    valid_cells <- which(country_mask[] & !is.na(combined_mask[]))
    total_valid_cells <- length(valid_cells)
    
    if (original_mpa_cells > 0 && total_valid_cells > 0) {
      if (original_mpa_cells > total_valid_cells) {
        warning(paste("More MPA cells than valid marine cells for country ID", country_id, ". Adjusting MPA cell count."))
        original_mpa_cells <- total_valid_cells
      }
      
      # Randomly select valid cells to be MPAs for current country
      mpa_cells <- sample(valid_cells, size = min(original_mpa_cells, total_valid_cells), replace = FALSE)
      
      # Update random raster
      random_raster[valid_cells] <- 0
      random_raster[mpa_cells] <- 1
    }
  }
  
  return(random_raster)
}

# Calculate MPA percentage function
calculate_mpa_percentage <- function(species_values, mpa_values) {
  total_cells <- sum(!is.na(species_values))
  mpa_cells <- sum(mpa_values == 1 & !is.na(species_values), na.rm = TRUE)
  percentage <- (mpa_cells / total_cells) * 100
  return(percentage)
}

# Main analysis function
run_random_mpa_analysis <- function(species_data, mpa_raster, marine_mask, eez_mask, n_iterations = 100) {
  # Convert species dataframe to spatial points
  species_points <- sp::SpatialPointsDataFrame(coords = species_data[, c("lon", "lat")], 
                                               data = species_data, 
                                               proj4string = sp::CRS(raster::projection(mpa_raster)))
  
  # Prepare results storage
  species_columns <- 4:(ncol(species_data) - 1)  # Adjust if needed
  all_results <- matrix(nrow = length(species_columns), ncol = n_iterations)
  rownames(all_results) <- names(species_data)[species_columns]
  
  # Use pblapply for parallel processing with a progress bar
  all_results <- pblapply(1:n_iterations, function(i) {
    set.seed(i)  # Set seed for reproducibility
    random_mpa <- create_random_mpa(mpa_raster, marine_mask, eez_mask)
    random_mpa_values <- raster::extract(random_mpa, species_points)
    sapply(species_data[, species_columns], 
           function(x) calculate_mpa_percentage(x, random_mpa_values))
  }, cl = detectCores() - 1)  # Use one less than available cores
  
  all_results <- do.call(cbind, all_results)
  
  # Calculate mean and standard deviation for each species
  mean_percentages <- rowMeans(all_results, na.rm = TRUE)
  sd_percentages <- apply(all_results, 1, sd, na.rm = TRUE)
  
  results <- data.frame(
    species = rownames(all_results),
    mean_percentage = mean_percentages,
    sd_percentage = sd_percentages
  )
  
  return(results)
}

# Function to process results
process_results <- function(results, mpa_type) {
  # Sort results by mean_percentage in descending order
  results <- results[order(-results$mean_percentage), ]
  
  # Calculate summary statistics
  summary_stats <- summary(results$mean_percentage)
  
  # Write results to CSV
  write.csv(results, here::here("Outputs",paste0("species_random_", mpa_type, "_coverage.csv")), row.names = FALSE)
  
  # Return a list containing the processed data
  return(list(
    top_10 = head(results, 10),
    summary_stats = summary_stats,
    all_results = results
  ))
}

# Create the EEZ mask with unique country IDs
eez_mask <- create_eez_mask(mpa_ALL)

# Run the analysis with the country-specific EEZ constraint
tryCatch({
  random_results_ALL <- run_random_mpa_analysis(puvsp_marine, mpa_ALL, marine_mask_resampled, eez_mask, n_iterations = 100)
  print("Analysis for ALL MPAs completed successfully.")
}, error = function(e) {
  print(paste("Error in ALL MPAs analysis:", e$message))
})

tryCatch({
  random_results_NT <- run_random_mpa_analysis(puvsp_marine, mpa_NT, marine_mask_resampled, eez_mask, n_iterations = 100)
  print("Analysis for No-Take MPAs completed successfully.")
}, error = function(e) {
  print(paste("Error in No-Take MPAs analysis:", e$message))
})

# Process results for both MPA types
processed_results <- list()

if (exists("random_results_ALL")) {
  processed_results[["ALL MPAs"]] <- process_results(random_results_ALL, "ALL MPAs")
}

if (exists("random_results_NT")) {
  processed_results[["No-take MPAs"]] <- process_results(random_results_NT, "No-take MPAs")
}
```

**Important note:** This NULL model randomly distributes protected grid cells at a 0.5-degree resolution within country's EEZs. However, it does not preserve MPA shape.

# Compare results

Compare results between the MPA network and the Null model of MPA placement

```{r}
# Compare results ---- 
library(dplyr)
library(tidyr)
library(ggplot2)

# Load actual MPA coverage data
actual_coverage <- read.csv(here::here("Outputs", "species_mpa_coverage_ALL_and_NT.csv"))
colnames(actual_coverage)[2:3]=c("ALL","NT")

# Load random MPA coverage results
random_ALL <- read.csv(here::here("Outputs", "species_random_ALL MPAs_coverage.csv"))
random_NT <- read.csv(here::here("Outputs", "species_random_No-take MPAs_coverage.csv"))

# Reshape actual coverage data to long format
actual_long <- actual_coverage %>%
  pivot_longer(cols = c(ALL, NT), 
               names_to = "mpa_type", 
               values_to = "actual_percentage")

# Function to merge and compare actual vs random data
compare_coverage <- function(actual_data, random_data, mpa_type) {
  comparison <- actual_data %>%
    filter(mpa_type == !!mpa_type) %>%
    left_join(random_data, by = "species") %>%
    mutate(difference = actual_percentage - mean_percentage,
           z_score = (actual_percentage - mean_percentage) / sd_percentage)
  return(comparison)
}

# Create comparison dataframes
comparison_ALL <- compare_coverage(actual_long, random_ALL, "ALL")
comparison_NT <- compare_coverage(actual_long, random_NT, "NT")

# Function to summarize and print results
library(knitr)
library(kableExtra)

summarize_results <- function(comparison_data, mpa_type) {
  over_represented <- mean(comparison_data$difference > 0, na.rm=TRUE) * 100
  under_represented <- mean(comparison_data$difference < 0, na.rm=TRUE) * 100
  equally_represented <- 100 - over_represented - under_represented
  
  summary_df <- data.frame(
    Representation = c("Over-represented", "Under-represented", "Equally represented"),
    Percentage = round(c(over_represented, under_represented, equally_represented), 2)
  )
  
  kable(summary_df, format = "html", col.names = c("Representation", "Percentage (%)"),
        caption = paste("Summary for", mpa_type, "MPAs")) %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"),
                  full_width = FALSE) %>%
    column_spec(2, width = "100px") %>%
    row_spec(0, bold = TRUE) %>%
    add_header_above(c(" " = 1, "Species" = 1)) %>%
    footnote(general = "Percentages may not sum to 100% due to rounding.")
}

# Summarize results
summarize_results(comparison_ALL, "ALL")
summarize_results(comparison_NT, "No-Take")

# Identify significantly over/under-represented species
library(dplyr)

significant_species <- function(comparison_data, mpa_type, z_threshold = 1.96) {
  over_represented <- comparison_data %>% 
    filter(z_score > z_threshold) %>% 
    arrange(desc(z_score))
  
  under_represented <- comparison_data %>% 
    filter(z_score < -z_threshold) %>% 
    arrange(z_score)
  
  top_5_over <- over_represented %>% 
    dplyr::select(species, actual_percentage, mean_percentage, difference, z_score) %>% 
    head(5)
  
  top_5_under <- under_represented %>% 
    dplyr::select(species, actual_percentage, mean_percentage, difference, z_score) %>% 
    head(5)
  
  combined_table <- bind_rows(
    mutate(top_5_over, representation = "Over-represented"),
    mutate(top_5_under, representation = "Under-represented")
  ) %>%
    mutate(across(where(is.numeric), ~round(., 2)))
  
  kable_output <- kable(combined_table, format = "html", 
        col.names = c("Species", "Actual %", "Random %", "Difference", "Z-score", "Representation"),
        caption = paste("Top 5 Significantly Over/Under-represented Species in", mpa_type, "MPAs")) %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"),
                  full_width = FALSE) %>%
    column_spec(1, width = "200px") %>%
    column_spec(2:5, width = "100px") %>%
    column_spec(6, width = "150px") %>%
    row_spec(0, bold = TRUE) %>%
    pack_rows("Over-represented", 1, 5, label_row_css = "background-color: #e6f3ff; color: #000;") %>%
    pack_rows("Under-represented", 6, 10, label_row_css = "background-color: #fff0e6; color: #000;")
  
  footnote_text <- paste(
    "Total significantly over-represented species:", nrow(over_represented), "\n",
    "Total significantly under-represented species:", nrow(under_represented)
  )
  
  kable_output %>%
    footnote(general = footnote_text, general_title = "Note:")
}

# Identify significant species
significant_species(comparison_ALL, "ALL")
significant_species(comparison_NT, "No-Take")
```

**Key message:** \>60% of species are under-represented by the global MPA network (i.e. less protected by the current MPA network than by a random placement of MPAs).

# Map results of the GAP analyses

Map Standardised Effect Sizes of MPA coverage

```{r}
#For ALL MPAs 
difference_sp=comparison_ALL[,c(1,3,6)]

#Plot the difference 
# Load necessary libraries
library(dplyr)
library(tidyr)
library(ggplot2)

#SES:
# Step 1: Calculate SES for each species in comparison_ALL
comparison_ALL <- comparison_ALL %>%
  mutate(SES = (actual_percentage - mean_percentage) / sd_percentage)

# Assuming you have a similar species-to-grid-cell mapping like puvsp_marine
# Reshape puvsp_marine from wide to long format (if needed)
puvsp_long <- puvsp_marine %>%
  pivot_longer(cols = -c(id, lon, lat), names_to = "species", values_to = "presence") %>%
  filter(!is.na(presence) & presence == 1)  # Only keep rows where species is present

# Join SES data (comparison_ALL) to puvsp_long
combined_data <- puvsp_long %>%
  left_join(comparison_ALL, by = c("species" = "species"))

# Step 3: Group by grid cell (id, lon, lat) and calculate mean SES
mean_ses_per_cell <- combined_data %>%
  group_by(id, lon, lat) %>%
  summarise(mean_SES = mean(SES, na.rm = TRUE)) %>%
  ungroup()

# Load necessary libraries
library(ggplot2)
library(rnaturalearth)
library(sf)

# Step 1: Get land polygons from rnaturalearth
land <- ne_countries(scale = "medium", returnclass = "sf")

# Step 2: Plot the mean SES with a diverging color scale
g_ses_1 = ggplot() +
  geom_tile(data = mean_ses_per_cell, aes(x = lon, y = lat, fill = mean_SES)) +
  geom_sf(data = land, fill = "darkgrey", color = NA) +  # Add land in dark grey
  scale_fill_gradient2(
    low = "#2166ac", mid = "#f0f0f0", high = "#b2182b", midpoint = 0  # Blue-White-Red gradient, with midpoint at 0
  ) +
  coord_sf(xlim = c(-180, 180), ylim = c(-90, 90), expand = FALSE) +  # Set global coordinates
  theme_minimal() +
  theme(
    legend.position = "bottom",            # Position the legend at the bottom
    legend.title = element_text(hjust = 0.5),  # Center the legend title
    legend.key.width = unit(3, "cm"),      # Adjust width of the legend bar
    legend.key.height = unit(0.5, "cm")    # Adjust height of the legend bar
  ) +
  guides(
    fill = guide_colorbar(
      direction = "horizontal",            # Make the legend horizontal
      title.position = "top",              # Move the title to the top of the legend
      title.hjust = 0.5                    # Center the title horizontally
    )
  ) +
  labs(title = "Standardized Effect Size (SES) of Observed vs. Null MPA Coverage",
       x = "Longitude",
       y = "Latitude",
       fill = "Mean SES")
print(g_ses_1)

#For No-take MPAs 
difference_sp=comparison_NT[,c(1,3,6)]

#SES
# Step 1: Calculate SES for each species in comparison_ALL
comparison_NT <- comparison_NT %>%
  mutate(SES = (actual_percentage - mean_percentage) / sd_percentage)

# Assuming you have a similar species-to-grid-cell mapping like puvsp_marine
# Reshape puvsp_marine from wide to long format (if needed)
puvsp_long <- puvsp_marine %>%
  pivot_longer(cols = -c(id, lon, lat), names_to = "species", values_to = "presence") %>%
  filter(!is.na(presence) & presence == 1)  # Only keep rows where species is present

# Join SES data (comparison_ALL) to puvsp_long
combined_data <- puvsp_long %>%
  left_join(comparison_NT, by = c("species" = "species"))

# Step 3: Group by grid cell (id, lon, lat) and calculate mean SES
mean_ses_per_cell <- combined_data %>%
  group_by(id, lon, lat) %>%
  summarise(mean_SES = mean(SES, na.rm = TRUE)) %>%
  ungroup()

# Load necessary libraries
library(ggplot2)
library(rnaturalearth)
library(sf)

# Step 1: Get land polygons from rnaturalearth
land <- ne_countries(scale = "medium", returnclass = "sf")

# Step 2: Plot the mean SES with a diverging color scale
g_ses_2 = ggplot() +
  geom_tile(data = mean_ses_per_cell, aes(x = lon, y = lat, fill = mean_SES)) +
  geom_sf(data = land, fill = "darkgrey", color = NA) +  # Add land in dark grey
  scale_fill_gradient2(
    low = "#2166ac", mid = "#f0f0f0", high = "#b2182b", midpoint = 0  # Blue-White-Red gradient, with midpoint at 0
  ) +
  coord_sf(xlim = c(-180, 180), ylim = c(-90, 90), expand = FALSE) +  # Set global coordinates
  theme_minimal() +
  theme(
    legend.position = "bottom",            # Position the legend at the bottom
    legend.title = element_text(hjust = 0.5),  # Center the legend title
    legend.key.width = unit(3, "cm"),      # Adjust width of the legend bar
    legend.key.height = unit(0.5, "cm")    # Adjust height of the legend bar
  ) +
  guides(
    fill = guide_colorbar(
      direction = "horizontal",            # Make the legend horizontal
      title.position = "top",              # Move the title to the top of the legend
      title.hjust = 0.5                    # Center the title horizontally
    )
  ) +
  labs(title = "Standardized Effect Size (SES) of Observed vs. Null no-take MPA Coverage",
       x = "Longitude",
       y = "Latitude",
       fill = "Mean SES")
print(g_ses_2)

# Load the patchwork library for combining plots
library(patchwork)

# Combine the plots side by side
combined_plots <- g_ses_1 + g_ses_2

# Save the combined plot
# Adjust width and height as needed for your desired output
ggsave(here::here("SES_maps_comparison.png"), 
       combined_plots,
       width = 16,  # Width in inches
       height = 8,  # Height in inches
       dpi = 300)   # Resolution

```

**Key message:** Northern Pacific, Northern Atlantic, Southern Pacific, Southern Atlantic and global coastal/continental sharks and rays are less protected by MPAs than expected under a random placement of MPAs. This is even more the case for no-take MPAs.

# Maps for the manuscript

Map Standardised Effect Sizes of MPA coverage with Mcbryde Thomas 2 projection

```{r}
library(ggplot2)
library(dplyr)
library(sf)
library(rnaturalearth)
library(patchwork)
library(smoothr)

# Step 1: Calculate SES for each species in comparison_ALL
comparison_ALL <- comparison_ALL %>%
  mutate(SES = (actual_percentage - mean_percentage) / sd_percentage)

# Reshape puvsp_marine to long format
puvsp_long <- puvsp_marine %>%
  pivot_longer(cols = -c(id, lon, lat), names_to = "species", values_to = "presence") %>%
  filter(!is.na(presence) & presence == 1)

# Join SES data to puvsp_long
combined_data <- puvsp_long %>%
  left_join(comparison_ALL, by = c("species" = "species"))

# Calculate mean SES per cell
mean_ses_per_cell <- combined_data %>%
  group_by(id, lon, lat) %>%
  summarise(mean_SES = mean(SES, na.rm = TRUE)) %>%
  ungroup()

# Define the projection
mcbryde_thomas_2 <- "+proj=mbt_s"

# Convert data to sf object and project
mean_ses_per_cell_sf <- mean_ses_per_cell %>%
  st_as_sf(coords = c("lon", "lat"), crs = 4326) %>%
  st_transform(crs = mcbryde_thomas_2)

# Get and project land
land_projected <- ne_countries(scale = "medium", returnclass = "sf") %>%
  st_transform(crs = mcbryde_thomas_2)

# Create the globe border
globe_bbox <- rbind(c(-180, -90), c(-180, 90), 
                    c(180, 90), c(180, -90), c(-180, -90))

globe_border <- st_polygon(list(globe_bbox)) %>%
  st_sfc(crs = 4326) %>%
  st_sf(data.frame(rgn = 'globe', geom = .)) %>%
  smoothr::densify(max_distance = 0.5) %>%
  st_transform(crs = mcbryde_thomas_2)

# Create base theme
my_theme <- theme_minimal() +
  theme(
    legend.position = "bottom",
    legend.direction = "horizontal",
    legend.box = "vertical",
    legend.margin = margin(t = 20, r = 0, b = 0, l = 0),
    legend.title = element_text(margin = margin(b = 10)),
    panel.background = element_rect(fill = "white", color = NA),
    plot.background = element_rect(fill = "white", color = NA),
    panel.grid = element_blank()
  )

# Plot for All MPAs (now g_ses_2)
g_ses_2 = ggplot() +
  geom_sf(data = mean_ses_per_cell_sf, aes(color = mean_SES), size = 0.5, alpha = 0.7) +
  geom_sf(data = land_projected, fill = "lightgrey", color = "lightgrey", size = 0.1) +
  geom_sf(data = globe_border, fill = NA, color = "black", size = 0.5) +
  scale_color_gradient2(
    low = "#2166ac", mid = "#f0f0f0", high = "#b2182b", 
    midpoint = 0,
    name = "Mean SES",
    guide = guide_colorbar(barwidth = 20, barheight = 0.5, 
                         title.position = "top", title.hjust = 0.5)
  ) +
  coord_sf() +
  labs(x = NULL, y = NULL) +
  annotate("text", x = -Inf, y = Inf, label = "(B)", 
           hjust = -1, vjust = 2, size = 6, fontface = "bold") +
  my_theme

# Repeat process for No-take MPAs
comparison_NT <- comparison_NT %>%
  mutate(SES = (actual_percentage - mean_percentage) / sd_percentage)

combined_data_NT <- puvsp_long %>%
  left_join(comparison_NT, by = c("species" = "species"))

mean_ses_per_cell_NT <- combined_data_NT %>%
  group_by(id, lon, lat) %>%
  summarise(mean_SES = mean(SES, na.rm = TRUE)) %>%
  ungroup()

mean_ses_per_cell_sf_NT <- mean_ses_per_cell_NT %>%
  st_as_sf(coords = c("lon", "lat"), crs = 4326) %>%
  st_transform(crs = mcbryde_thomas_2)

# Plot for No-take MPAs (now g_ses_1)
g_ses_1 = ggplot() +
  geom_sf(data = mean_ses_per_cell_sf_NT, aes(color = mean_SES), size = 0.5, alpha = 0.7) +
  geom_sf(data = land_projected, fill = "lightgrey", color = "lightgrey", size = 0.1) +
  geom_sf(data = globe_border, fill = NA, color = "black", size = 0.5) +
  scale_color_gradient2(
    low = "#2166ac", mid = "#f0f0f0", high = "#b2182b", 
    midpoint = 0,
    name = "Mean SES",
    guide = guide_colorbar(barwidth = 20, barheight = 0.5, 
                         title.position = "top", title.hjust = 0.5)
  ) +
  coord_sf() +
  labs(x = NULL, y = NULL) +
  annotate("text", x = -Inf, y = Inf, label = "(A)", 
           hjust = -1, vjust = 2, size = 6, fontface = "bold") +
  my_theme

# Create layout matrix for two plots in a column
layout <- matrix(c(1, 2), ncol = 1)

# Combine plots using grid.arrange
combined_plot <- gridExtra::grid.arrange(
  g_ses_1,
  g_ses_2,
  layout_matrix = layout,
  heights = unit(c(6, 6), "inches")  # Equal height for both plots
)

# Save the combined plot
ggsave(here::here("SES_maps_comparison.png"), 
       combined_plot,
       width = 10,    # adjusted for single column
       height = 12,  # adjusted for two rows
       dpi = 300,
       bg = "white")
```

# Relate to IUCN status

1.  Relate the percentage of species range overlapped by MPAs to the IUCN Red List status with difference tests between categories

```{r}
IUCN <- readRDS(here::here("Data","GAP analyses","sharks_iucn_final.RDS"))
# Remove underscores from species names
IUCN$species <- gsub("_", " ", IUCN$Species)

# Read the CSV file and assign it to "results"
results <- read.csv(here::here("Data", "species_mpa_coverage_ALL_and_NT.csv"))

results_IUCN=left_join(IUCN, results, by=c("species"))

library(ggplot2)
library(dplyr)

# Convert iucn_GE to a factor for better plotting
results_IUCN$iucn_GE <- as.factor(results_IUCN$iucn_GE)

results_IUCN <- results_IUCN %>%
  mutate(IUCN_status = case_when(
    iucn_GE == 0 ~ "LC",
    iucn_GE == 1 ~ "NT",
    iucn_GE == 2 ~ "VU",
    iucn_GE == 3 ~ "EN",
    iucn_GE == 4 ~ "CR",
    TRUE ~ "Unknown"
  ))

# Filter out the "Unknown" category
results_IUCN_filtered <- results_IUCN %>%
  filter(IUCN_status != "Unknown")

# Define IUCN colors and order
iucn_colors <- c(
  "CR" = "#D81E05",  # Red
  "EN" = "#FC7F3F",  # Orange
  "VU" = "#FEC748",  # Yellow
  "NT" = "#58AFFF",  # Light Blue
  "LC" = "#38AB38"   # Green
)

iucn_order <- c("LC", "NT", "VU", "EN", "CR")

library(ggplot2)
library(dplyr)
library(dunn.test)

# Perform Kruskal-Wallis test
kruskal_result <- kruskal.test(percentage_in_ALL_MPA ~ IUCN_status, data = results_IUCN_filtered)

# Perform Dunn's test for pairwise comparisons and capture the output
invisible(capture.output(
  dunn_result <- dunn.test(results_IUCN_filtered$percentage_in_ALL_MPA, 
                           results_IUCN_filtered$IUCN_status, 
                           method = "bonferroni")
))

# Create a function to add significance levels to the plot
add_significance <- function(p.value) {
  if(p.value <= 0.001) return("***")
  else if(p.value <= 0.01) return("**")
  else if(p.value <= 0.05) return("*")
  else return("ns")
}

# Create a data frame with pairwise comparisons and their significance
significant_comparisons <- data.frame(
  group1 = sapply(strsplit(dunn_result$comparisons, " - "), `[`, 1),
  group2 = sapply(strsplit(dunn_result$comparisons, " - "), `[`, 2),
  p.value = dunn_result$P.adjusted,
  stringsAsFactors = FALSE
)

# Add significance levels to the data frame
significant_comparisons$significance <- sapply(significant_comparisons$p.value, add_significance)

# Filter out non-significant comparisons
significant_comparisons <- significant_comparisons[significant_comparisons$significance != "ns", ]

# Calculate x positions for the significance bars
iucn_levels <- c("LC", "NT", "VU", "EN", "CR")
x_positions <- seq_along(iucn_levels)
names(x_positions) <- iucn_levels

significant_comparisons$x1 <- x_positions[significant_comparisons$group1]
significant_comparisons$x2 <- x_positions[significant_comparisons$group2]

# Sort comparisons based on the difference between group indices
significant_comparisons$group_diff <- abs(significant_comparisons$x2 - significant_comparisons$x1)
significant_comparisons <- significant_comparisons[order(significant_comparisons$group_diff, decreasing = TRUE), ]

# Calculate y positions for the sorted comparisons
max_y <- max(results_IUCN_filtered$percentage_in_ALL_MPA, na.rm = TRUE)
significant_comparisons$y.position <- seq(max_y + 5, 
                                        by = 10, 
                                        length.out = nrow(significant_comparisons))

# Recreate the base violin plot
violin_plot_all <- ggplot(results_IUCN_filtered, aes(x = factor(IUCN_status, levels = iucn_order), y = percentage_in_ALL_MPA)) +
  geom_violin(aes(fill = IUCN_status, color = IUCN_status), trim = FALSE, alpha = 0.5) +
  geom_jitter(width = 0.1, size = 0.5, alpha = 0.5, color = "darkgray") +
  geom_boxplot(width = 0.1, fill = "white", color = "black", outlier.shape = NA, alpha = 0.8) +
  labs(x = "IUCN Status", y = "(%) Range within MPAs") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5), legend.position = "none") +
  scale_x_discrete(limits = iucn_order) +
  scale_fill_manual(values = iucn_colors) +
  scale_color_manual(values = iucn_colors)

# Add significance bars and labels
violin_plot_with_significance_all <- violin_plot_all +
  geom_segment(data = significant_comparisons,
               aes(x = x1, xend = x2, y = y.position, yend = y.position),
               inherit.aes = FALSE,
               color = "black", size = 0.5) +
  geom_segment(data = significant_comparisons,
               aes(x = x1, xend = x1, y = y.position, yend = y.position - 2),
               inherit.aes = FALSE,
               color = "black", size = 0.5) +
  geom_segment(data = significant_comparisons,
               aes(x = x2, xend = x2, y = y.position, yend = y.position - 2),
               inherit.aes = FALSE,
               color = "black", size = 0.5) +
  geom_text(data = significant_comparisons,
            aes(x = (x1 + x2) / 2, y = y.position, label = significance),
            inherit.aes = FALSE,
            vjust = -0.2, size = 3)

# Display the updated plot
print(violin_plot_with_significance_all)

# Save the plot
#ggsave("violin_plot_with_significance.pdf", violin_plot_with_significance, width = 10, height = 8, units = "in")

# Summary statistics
summary_stats <- results_IUCN_filtered %>%
  group_by(IUCN_status) %>%
  summarise(
    count = n(),
    mean = mean(percentage_in_ALL_MPA, na.rm = TRUE),
    median = median(percentage_in_ALL_MPA, na.rm = TRUE),
    sd = sd(percentage_in_ALL_MPA, na.rm = TRUE)
  ) %>%
  arrange(factor(IUCN_status, levels = iucn_order))

print(summary_stats)

#Now for no-take MPAs 
kruskal_result <- kruskal.test(sqrt(percentage_in_NT_MPA) ~ IUCN_status, data = results_IUCN_filtered)

# Perform Dunn's test for pairwise comparisons
# Perform Dunn's test for pairwise comparisons and capture the output
invisible(capture.output(
  dunn_result <- dunn.test(sqrt(results_IUCN_filtered$percentage_in_NT_MPA), 
                           results_IUCN_filtered$IUCN_status, 
                           method = "bonferroni")
))

# Create a function to add significance levels to the plot
add_significance <- function(p.value) {
  if(p.value <= 0.001) return("***")
  else if(p.value <= 0.01) return("**")
  else if(p.value <= 0.05) return("*")
  else return("ns")
}

# Create a data frame with pairwise comparisons and their significance
significant_comparisons <- data.frame(
  group1 = sapply(strsplit(dunn_result$comparisons, " - "), `[`, 1),
  group2 = sapply(strsplit(dunn_result$comparisons, " - "), `[`, 2),
  p.value = dunn_result$P.adjusted,
  stringsAsFactors = FALSE
)

# Add significance levels to the data frame
significant_comparisons$significance <- sapply(significant_comparisons$p.value, add_significance)

# Filter out non-significant comparisons
significant_comparisons <- significant_comparisons[significant_comparisons$significance != "ns", ]

# Calculate x positions for the significance bars
iucn_levels <- c("LC", "NT", "VU", "EN", "CR")
x_positions <- seq_along(iucn_levels)
names(x_positions) <- iucn_levels

significant_comparisons$x1 <- x_positions[significant_comparisons$group1]
significant_comparisons$x2 <- x_positions[significant_comparisons$group2]

# Sort comparisons based on the difference between group indices
significant_comparisons$group_diff <- abs(significant_comparisons$x2 - significant_comparisons$x1)
significant_comparisons <- significant_comparisons[order(significant_comparisons$group_diff, decreasing = TRUE), ]

# Calculate y positions for the sorted comparisons
significant_comparisons$y.position <- seq(max(results_IUCN_filtered$percentage_in_ALL_MPA, na.rm = TRUE) + 5, 
                                          by = 5, 
                                          length.out = nrow(significant_comparisons))

# Recreate the base violin plot
violin_plot_nt <- ggplot(results_IUCN_filtered, aes(x = factor(IUCN_status, levels = iucn_order), y = percentage_in_NT_MPA)) +
  geom_violin(aes(fill = IUCN_status, color = IUCN_status), trim = FALSE, alpha = 0.5) +
  geom_jitter(width = 0.1, size = 0.5, alpha = 0.5, color = "darkgray") +
  geom_boxplot(width = 0.1, fill = "white", color = "black", outlier.shape = NA, alpha = 0.8) +
  labs(x = "IUCN Status", y = "(%) Range within no-take MPAs") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5), legend.position = "none") +
  scale_x_discrete(limits = iucn_order) +
  scale_y_continuous(transform = "sqrt") +
  scale_fill_manual(values = iucn_colors) +
  scale_color_manual(values = iucn_colors)

# Add significance bars and labels
violin_plot_with_significance_nt <- violin_plot_nt +
  geom_segment(data = significant_comparisons,
               aes(x = x1, xend = x2, y = y.position, yend = y.position),
               inherit.aes = FALSE,
               color = "black", size = 0.5) +
  geom_segment(data = significant_comparisons,
               aes(x = x1, xend = x1, y = y.position, yend = y.position - 2),
               inherit.aes = FALSE,
               color = "black", size = 0.5) +
  geom_segment(data = significant_comparisons,
               aes(x = x2, xend = x2, y = y.position, yend = y.position - 2),
               inherit.aes = FALSE,
               color = "black", size = 0.5) +
  geom_text(data = significant_comparisons,
            aes(x = (x1 + x2) / 2, y = y.position, label = significance),
            inherit.aes = FALSE,
            vjust = -0.5, size = 3)

# Display the updated plot
print(violin_plot_with_significance_nt)

# Summary statistics
summary_stats <- results_IUCN_filtered %>%
  group_by(IUCN_status) %>%
  summarise(
    count = n(),
    mean = mean(percentage_in_NT_MPA, na.rm = TRUE),
    median = median(percentage_in_NT_MPA, na.rm = TRUE),
    sd = sd(percentage_in_NT_MPA, na.rm = TRUE)
  ) %>%
  arrange(factor(IUCN_status, levels = iucn_order))

print(summary_stats)

# Then combine them using patchwork:
library(patchwork)
combined_plot <- violin_plot_with_significance_all + violin_plot_with_significance_nt +
  plot_annotation(tag_levels = 'A')

# Save the combined plot
ggsave(here::here("combined_violin_plots_current_protection.png"), combined_plot, width = 12, height = 6, units = "in")

```

**Key message:** Least concerned species are significantly more protected by all MPAs than any other IUCN Red List threat status category. We also note a similar relationship (LC vs VU, EN & CR) for no-take MPAs, however, after p-value adjustment for multiple comparison, differences were not significant for no-take MPAs.

## Relate to IUCN status: proposed protection

### FUSE 0.3 budget

```{r}
# Read the data
combined_protection_FUSE_03 <- readRDS(here::here("Data", "combined_protection_FUSE_03.rds"))

# FUSE 0.3 budget 
IUCN <- readRDS(here::here("Data","GAP analyses","sharks_iucn_final.RDS"))
# Remove underscores from species names
IUCN$species <- gsub("_", " ", IUCN$Species)

# Join with combined_protection_FUSE_03
results_IUCN <- left_join(IUCN, combined_protection_FUSE_03, by=c("species" = "Species"))

library(ggplot2)
library(dplyr)

# Convert iucn_GE to a factor for better plotting
results_IUCN$iucn_GE <- as.factor(results_IUCN$iucn_GE)

results_IUCN <- results_IUCN %>%
  mutate(IUCN_status = case_when(
    iucn_GE == 0 ~ "LC",
    iucn_GE == 1 ~ "NT",
    iucn_GE == 2 ~ "VU",
    iucn_GE == 3 ~ "EN",
    iucn_GE == 4 ~ "CR",
    TRUE ~ "Unknown"
  ))

# Filter out the "Unknown" category
results_IUCN_filtered <- results_IUCN %>%
  filter(IUCN_status != "Unknown")

# Define IUCN colors and order
iucn_colors <- c(
  "CR" = "#D81E05",  # Red
  "EN" = "#FC7F3F",  # Orange
  "VU" = "#FEC748",  # Yellow
  "NT" = "#58AFFF",  # Light Blue
  "LC" = "#38AB38"   # Green
)

iucn_order <- c("LC", "NT", "VU", "EN", "CR")

library(ggplot2)
library(dplyr)
library(dunn.test)

# Perform Kruskal-Wallis test with sqrt transformation
kruskal_result <- kruskal.test(sqrt(weighted_protection) ~ IUCN_status, data = results_IUCN_filtered)

# Perform Dunn's test for pairwise comparisons with sqrt transformation and capture the output
invisible(capture.output(
  dunn_result <- dunn.test(sqrt(results_IUCN_filtered$weighted_protection), 
                           results_IUCN_filtered$IUCN_status, 
                           method = "bonferroni")
))

# Create a function to add significance levels to the plot
add_significance <- function(p.value) {
  if(p.value <= 0.001) return("***")
  else if(p.value <= 0.01) return("**")
  else if(p.value <= 0.05) return("*")
  else return("ns")
}

# Create a data frame with pairwise comparisons and their significance
significant_comparisons <- data.frame(
  group1 = sapply(strsplit(dunn_result$comparisons, " - "), `[`, 1),
  group2 = sapply(strsplit(dunn_result$comparisons, " - "), `[`, 2),
  p.value = dunn_result$P.adjusted,
  stringsAsFactors = FALSE
)

# Add significance levels to the data frame
significant_comparisons$significance <- sapply(significant_comparisons$p.value, add_significance)

# Filter out non-significant comparisons
significant_comparisons <- significant_comparisons[significant_comparisons$significance != "ns", ]

# Calculate x positions for the significance bars
iucn_levels <- c("LC", "NT", "VU", "EN", "CR")
x_positions <- seq_along(iucn_levels)
names(x_positions) <- iucn_levels

significant_comparisons$x1 <- x_positions[significant_comparisons$group1]
significant_comparisons$x2 <- x_positions[significant_comparisons$group2]

# Sort comparisons based on the difference between group indices
significant_comparisons$group_diff <- abs(significant_comparisons$x2 - significant_comparisons$x1)
significant_comparisons <- significant_comparisons[order(significant_comparisons$group_diff, decreasing = TRUE), ]

# Calculate y positions for the sorted comparisons using sqrt transformation
max_y <- max(sqrt(results_IUCN_filtered$weighted_protection), na.rm = TRUE)
significant_comparisons$y.position <- seq(max_y + 0.05, 
                                        by = 0.1, 
                                        length.out = nrow(significant_comparisons))

# Create the base violin plot with scale_y_sqrt
violin_plot_FUSE_03 <- ggplot(results_IUCN_filtered, aes(x = factor(IUCN_status, levels = iucn_order), y = weighted_protection)) +
  geom_violin(aes(fill = IUCN_status, color = IUCN_status), trim = FALSE, alpha = 0.5) +
  geom_jitter(width = 0.1, size = 0.5, alpha = 0.5, color = "darkgray") +
  geom_boxplot(width = 0.1, fill = "white", color = "black", outlier.shape = NA, alpha = 0.8) +
  labs(x = "IUCN Status", 
       y = "Weighted Protection") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5), legend.position = "none") +
  scale_x_discrete(limits = iucn_order) +
  scale_fill_manual(values = iucn_colors) +
  scale_color_manual(values = iucn_colors) +
  scale_y_sqrt(limits = c(0,1.2))

# Recalculate max_y for significance bars (no need for sqrt here as scale_y_sqrt handles it)
max_y <- max(results_IUCN_filtered$weighted_protection, na.rm = TRUE)
significant_comparisons$y.position <- seq(max_y + 0.05, 
                                        by = 0.1, 
                                        length.out = nrow(significant_comparisons))

# Add significance bars and labels
violin_plot_with_significance_FUSE_03 <- violin_plot_FUSE_03 +
  geom_segment(data = significant_comparisons,
               aes(x = x1, xend = x2, y = y.position, yend = y.position),
               inherit.aes = FALSE,
               color = "black", size = 0.5) +
  geom_segment(data = significant_comparisons,
               aes(x = x1, xend = x1, y = y.position, yend = y.position - 0.02),
               inherit.aes = FALSE,
               color = "black", size = 0.5) +
  geom_segment(data = significant_comparisons,
               aes(x = x2, xend = x2, y = y.position, yend = y.position - 0.02),
               inherit.aes = FALSE,
               color = "black", size = 0.5) +
  geom_text(data = significant_comparisons,
            aes(x = (x1 + x2) / 2, y = y.position, label = significance),
            inherit.aes = FALSE,
            vjust = -0.2, size = 3)

# Display the updated plot
print(violin_plot_with_significance_FUSE_03)

# Summary statistics with both raw and transformed values
summary_stats <- results_IUCN_filtered %>%
  group_by(IUCN_status) %>%
  summarise(
    count = n(),
    mean_raw = mean(weighted_protection, na.rm = TRUE),
    median_raw = median(weighted_protection, na.rm = TRUE),
    sd_raw = sd(weighted_protection, na.rm = TRUE),
    mean_sqrt = mean(sqrt(weighted_protection), na.rm = TRUE),
    median_sqrt = median(sqrt(weighted_protection), na.rm = TRUE),
    sd_sqrt = sd(sqrt(weighted_protection), na.rm = TRUE)
  ) %>%
  arrange(factor(IUCN_status, levels = iucn_order))

print(summary_stats)

# Save the results
saveRDS(results_IUCN_filtered, file = here::here("Data", "results_IUCN_filtered_FUSE_03.rds"))
```

### FUSE 0.1 budget

```{r}
# Read the data
combined_protection_FUSE_01 <- readRDS(here::here("Data", "combined_protection_FUSE_01.rds"))

# FUSE 0.1 budget 
IUCN <- readRDS(here::here("Data","GAP analyses","sharks_iucn_final.RDS"))
# Remove underscores from species names
IUCN$species <- gsub("_", " ", IUCN$Species)

# Join with combined_protection_FUSE_01
results_IUCN <- left_join(IUCN, combined_protection_FUSE_01, by=c("species" = "Species"))

library(ggplot2)
library(dplyr)

# Convert iucn_GE to a factor for better plotting
results_IUCN$iucn_GE <- as.factor(results_IUCN$iucn_GE)

results_IUCN <- results_IUCN %>%
  mutate(IUCN_status = case_when(
    iucn_GE == 0 ~ "LC",
    iucn_GE == 1 ~ "NT",
    iucn_GE == 2 ~ "VU",
    iucn_GE == 3 ~ "EN",
    iucn_GE == 4 ~ "CR",
    TRUE ~ "Unknown"
  ))

# Filter out the "Unknown" category
results_IUCN_filtered <- results_IUCN %>%
  filter(IUCN_status != "Unknown")

# Define IUCN colors and order
iucn_colors <- c(
  "CR" = "#D81E05",  # Red
  "EN" = "#FC7F3F",  # Orange
  "VU" = "#FEC748",  # Yellow
  "NT" = "#58AFFF",  # Light Blue
  "LC" = "#38AB38"   # Green
)

iucn_order <- c("LC", "NT", "VU", "EN", "CR")

library(ggplot2)
library(dplyr)
library(dunn.test)

# Perform Kruskal-Wallis test with sqrt transformation
kruskal_result <- kruskal.test(sqrt(weighted_protection) ~ IUCN_status, data = results_IUCN_filtered)

# Perform Dunn's test for pairwise comparisons with sqrt transformation and capture the output
invisible(capture.output(
  dunn_result <- dunn.test(sqrt(results_IUCN_filtered$weighted_protection), 
                           results_IUCN_filtered$IUCN_status, 
                           method = "bonferroni")
))

# Create a function to add significance levels to the plot
add_significance <- function(p.value) {
  if(p.value <= 0.001) return("***")
  else if(p.value <= 0.01) return("**")
  else if(p.value <= 0.05) return("*")
  else return("ns")
}

# Create a data frame with pairwise comparisons and their significance
significant_comparisons <- data.frame(
  group1 = sapply(strsplit(dunn_result$comparisons, " - "), `[`, 1),
  group2 = sapply(strsplit(dunn_result$comparisons, " - "), `[`, 2),
  p.value = dunn_result$P.adjusted,
  stringsAsFactors = FALSE
)

# Add significance levels to the data frame
significant_comparisons$significance <- sapply(significant_comparisons$p.value, add_significance)

# Filter out non-significant comparisons
significant_comparisons <- significant_comparisons[significant_comparisons$significance != "ns", ]

# Calculate x positions for the significance bars
iucn_levels <- c("LC", "NT", "VU", "EN", "CR")
x_positions <- seq_along(iucn_levels)
names(x_positions) <- iucn_levels

significant_comparisons$x1 <- x_positions[significant_comparisons$group1]
significant_comparisons$x2 <- x_positions[significant_comparisons$group2]

# Sort comparisons based on the difference between group indices
significant_comparisons$group_diff <- abs(significant_comparisons$x2 - significant_comparisons$x1)
significant_comparisons <- significant_comparisons[order(significant_comparisons$group_diff, decreasing = TRUE), ]

# Calculate y positions for the sorted comparisons using sqrt transformation
max_y <- max(sqrt(results_IUCN_filtered$weighted_protection), na.rm = TRUE)
significant_comparisons$y.position <- seq(max_y + 0.05, 
                                        by = 0.1, 
                                        length.out = nrow(significant_comparisons))

# Create the base violin plot with scale_y_sqrt
violin_plot_FUSE_01 <- ggplot(results_IUCN_filtered, aes(x = factor(IUCN_status, levels = iucn_order), y = weighted_protection)) +
  geom_violin(aes(fill = IUCN_status, color = IUCN_status), trim = FALSE, alpha = 0.5) +
  geom_jitter(width = 0.1, size = 0.5, alpha = 0.5, color = "darkgray") +
  geom_boxplot(width = 0.1, fill = "white", color = "black", outlier.shape = NA, alpha = 0.8) +
  labs(x = "IUCN Status", 
       y = "Weighted Protection") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5), legend.position = "none") +
  scale_x_discrete(limits = iucn_order) +
  scale_fill_manual(values = iucn_colors) +
  scale_color_manual(values = iucn_colors) +
  scale_y_sqrt(limits = c(0,1.2))

# Recalculate max_y for significance bars (no need for sqrt here as scale_y_sqrt handles it)
max_y <- max(results_IUCN_filtered$weighted_protection, na.rm = TRUE)
significant_comparisons$y.position <- seq(max_y + 0.05, 
                                        by = 0.1, 
                                        length.out = nrow(significant_comparisons))

# Add significance bars and labels
violin_plot_with_significance_FUSE_01 <- violin_plot_FUSE_01 +
  geom_segment(data = significant_comparisons,
               aes(x = x1, xend = x2, y = y.position, yend = y.position),
               inherit.aes = FALSE,
               color = "black", size = 0.5) +
  geom_segment(data = significant_comparisons,
               aes(x = x1, xend = x1, y = y.position, yend = y.position - 0.02),
               inherit.aes = FALSE,
               color = "black", size = 0.5) +
  geom_segment(data = significant_comparisons,
               aes(x = x2, xend = x2, y = y.position, yend = y.position - 0.02),
               inherit.aes = FALSE,
               color = "black", size = 0.5) +
  geom_text(data = significant_comparisons,
            aes(x = (x1 + x2) / 2, y = y.position, label = significance),
            inherit.aes = FALSE,
            vjust = -0.2, size = 3)

# Display the updated plot
print(violin_plot_with_significance_FUSE_01)

# Summary statistics with both raw and transformed values
summary_stats <- results_IUCN_filtered %>%
  group_by(IUCN_status) %>%
  summarise(
    count = n(),
    mean_raw = mean(weighted_protection, na.rm = TRUE),
    median_raw = median(weighted_protection, na.rm = TRUE),
    sd_raw = sd(weighted_protection, na.rm = TRUE),
    mean_sqrt = mean(sqrt(weighted_protection), na.rm = TRUE),
    median_sqrt = median(sqrt(weighted_protection), na.rm = TRUE),
    sd_sqrt = sd(sqrt(weighted_protection), na.rm = TRUE)
  ) %>%
  arrange(factor(IUCN_status, levels = iucn_order))

print(summary_stats)

# Save the results
saveRDS(results_IUCN_filtered, file = here::here("Data", "results_IUCN_filtered_FUSE_01.rds"))
```

### EDGE 0.3 budget

```{r}
# Read the data
combined_protection_EDGE_03 <- readRDS(here::here("Data", "combined_protection_EDGE_03.rds"))

# EDGE2 0.3 budget 
IUCN <- readRDS(here::here("Data","GAP analyses","sharks_iucn_final.RDS"))
# Remove underscores from species names
IUCN$species <- gsub("_", " ", IUCN$Species)

# Join with combined_protection_EDGE_03
results_IUCN <- left_join(IUCN, combined_protection_EDGE_03, by=c("species" = "species_name"))

library(ggplot2)
library(dplyr)

# Convert iucn_GE to a factor for better plotting
results_IUCN$iucn_GE <- as.factor(results_IUCN$iucn_GE)

results_IUCN <- results_IUCN %>%
  mutate(IUCN_status = case_when(
    iucn_GE == 0 ~ "LC",
    iucn_GE == 1 ~ "NT",
    iucn_GE == 2 ~ "VU",
    iucn_GE == 3 ~ "EN",
    iucn_GE == 4 ~ "CR",
    TRUE ~ "Unknown"
  ))

# Filter out the "Unknown" category
results_IUCN_filtered <- results_IUCN %>%
  filter(IUCN_status != "Unknown")

# Define IUCN colors and order
iucn_colors <- c(
  "CR" = "#D81E05",  # Red
  "EN" = "#FC7F3F",  # Orange
  "VU" = "#FEC748",  # Yellow
  "NT" = "#58AFFF",  # Light Blue
  "LC" = "#38AB38"   # Green
)

iucn_order <- c("LC", "NT", "VU", "EN", "CR")

library(ggplot2)
library(dplyr)
library(dunn.test)

# Perform Kruskal-Wallis test with sqrt transformation
kruskal_result <- kruskal.test(sqrt(weighted_protection) ~ IUCN_status, data = results_IUCN_filtered)

# Perform Dunn's test for pairwise comparisons with sqrt transformation and capture the output
invisible(capture.output(
  dunn_result <- dunn.test(sqrt(results_IUCN_filtered$weighted_protection), 
                           results_IUCN_filtered$IUCN_status, 
                           method = "bonferroni")
))

# Create a function to add significance levels to the plot
add_significance <- function(p.value) {
  if(p.value <= 0.001) return("***")
  else if(p.value <= 0.01) return("**")
  else if(p.value <= 0.05) return("*")
  else return("ns")
}

# Create a data frame with pairwise comparisons and their significance
significant_comparisons <- data.frame(
  group1 = sapply(strsplit(dunn_result$comparisons, " - "), `[`, 1),
  group2 = sapply(strsplit(dunn_result$comparisons, " - "), `[`, 2),
  p.value = dunn_result$P.adjusted,
  stringsAsFactors = FALSE
)

# Add significance levels to the data frame
significant_comparisons$significance <- sapply(significant_comparisons$p.value, add_significance)

# Filter out non-significant comparisons
significant_comparisons <- significant_comparisons[significant_comparisons$significance != "ns", ]

# Calculate x positions for the significance bars
iucn_levels <- c("LC", "NT", "VU", "EN", "CR")
x_positions <- seq_along(iucn_levels)
names(x_positions) <- iucn_levels

significant_comparisons$x1 <- x_positions[significant_comparisons$group1]
significant_comparisons$x2 <- x_positions[significant_comparisons$group2]

# Sort comparisons based on the difference between group indices
significant_comparisons$group_diff <- abs(significant_comparisons$x2 - significant_comparisons$x1)
significant_comparisons <- significant_comparisons[order(significant_comparisons$group_diff, decreasing = TRUE), ]

# Calculate y positions for the sorted comparisons using sqrt transformation
max_y <- max(sqrt(results_IUCN_filtered$weighted_protection), na.rm = TRUE)
significant_comparisons$y.position <- seq(max_y + 0.05, 
                                        by = 0.1, 
                                        length.out = nrow(significant_comparisons))

# Create the base violin plot with scale_y_sqrt
violin_plot_EDGE_03 <- ggplot(results_IUCN_filtered, aes(x = factor(IUCN_status, levels = iucn_order), y = weighted_protection)) +
  geom_violin(aes(fill = IUCN_status, color = IUCN_status), trim = FALSE, alpha = 0.5) +
  geom_jitter(width = 0.1, size = 0.5, alpha = 0.5, color = "darkgray") +
  geom_boxplot(width = 0.1, fill = "white", color = "black", outlier.shape = NA, alpha = 0.8) +
  labs(x = "IUCN Status", 
       y = "Weighted Protection") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5), legend.position = "none") +
  scale_x_discrete(limits = iucn_order) +
  scale_fill_manual(values = iucn_colors) +
  scale_color_manual(values = iucn_colors) +
  scale_y_sqrt(limits = c(0,1.2))

# Recalculate max_y for significance bars (no need for sqrt here as scale_y_sqrt handles it)
max_y <- max(results_IUCN_filtered$weighted_protection, na.rm = TRUE)
significant_comparisons$y.position <- seq(max_y + 0.05, 
                                        by = 0.1, 
                                        length.out = nrow(significant_comparisons))

# Add significance bars and labels
violin_plot_with_significance_EDGE_03 <- violin_plot_EDGE_03 +
  geom_segment(data = significant_comparisons,
               aes(x = x1, xend = x2, y = y.position, yend = y.position),
               inherit.aes = FALSE,
               color = "black", size = 0.5) +
  geom_segment(data = significant_comparisons,
               aes(x = x1, xend = x1, y = y.position, yend = y.position - 0.02),
               inherit.aes = FALSE,
               color = "black", size = 0.5) +
  geom_segment(data = significant_comparisons,
               aes(x = x2, xend = x2, y = y.position, yend = y.position - 0.02),
               inherit.aes = FALSE,
               color = "black", size = 0.5) +
  geom_text(data = significant_comparisons,
            aes(x = (x1 + x2) / 2, y = y.position, label = significance),
            inherit.aes = FALSE,
            vjust = -0.2, size = 3)

# Display the updated plot
print(violin_plot_with_significance_EDGE_03)

# Summary statistics with both raw and transformed values
summary_stats <- results_IUCN_filtered %>%
  group_by(IUCN_status) %>%
  summarise(
    count = n(),
    mean_raw = mean(weighted_protection, na.rm = TRUE),
    median_raw = median(weighted_protection, na.rm = TRUE),
    sd_raw = sd(weighted_protection, na.rm = TRUE),
    mean_sqrt = mean(sqrt(weighted_protection), na.rm = TRUE),
    median_sqrt = median(sqrt(weighted_protection), na.rm = TRUE),
    sd_sqrt = sd(sqrt(weighted_protection), na.rm = TRUE)
  ) %>%
  arrange(factor(IUCN_status, levels = iucn_order))

print(summary_stats)

# Save the results
saveRDS(results_IUCN_filtered, file = here::here("Data", "results_IUCN_filtered_EDGE_03.rds"))
```

### EDGE 0.1 budget

```{r}
# Read the data
combined_protection_EDGE_01 <- readRDS(here::here("Data", "combined_protection_EDGE_01.rds"))

# EDGE2 0.1 budget 
IUCN <- readRDS(here::here("Data","GAP analyses","sharks_iucn_final.RDS"))
# Remove underscores from species names
IUCN$species <- gsub("_", " ", IUCN$Species)

# Join with combined_protection_EDGE_01
results_IUCN <- left_join(IUCN, combined_protection_EDGE_01, by=c("species" = "species_name"))

library(ggplot2)
library(dplyr)

# Convert iucn_GE to a factor for better plotting
results_IUCN$iucn_GE <- as.factor(results_IUCN$iucn_GE)

results_IUCN <- results_IUCN %>%
  mutate(IUCN_status = case_when(
    iucn_GE == 0 ~ "LC",
    iucn_GE == 1 ~ "NT",
    iucn_GE == 2 ~ "VU",
    iucn_GE == 3 ~ "EN",
    iucn_GE == 4 ~ "CR",
    TRUE ~ "Unknown"
  ))

# Filter out the "Unknown" category
results_IUCN_filtered <- results_IUCN %>%
  filter(IUCN_status != "Unknown")

# Define IUCN colors and order
iucn_colors <- c(
  "CR" = "#D81E05",  # Red
  "EN" = "#FC7F3F",  # Orange
  "VU" = "#FEC748",  # Yellow
  "NT" = "#58AFFF",  # Light Blue
  "LC" = "#38AB38"   # Green
)

iucn_order <- c("LC", "NT", "VU", "EN", "CR")

library(ggplot2)
library(dplyr)
library(dunn.test)

# Perform Kruskal-Wallis test with sqrt transformation
kruskal_result <- kruskal.test(sqrt(weighted_protection) ~ IUCN_status, data = results_IUCN_filtered)

# Perform Dunn's test for pairwise comparisons with sqrt transformation and capture the output
invisible(capture.output(
  dunn_result <- dunn.test(sqrt(results_IUCN_filtered$weighted_protection), 
                           results_IUCN_filtered$IUCN_status, 
                           method = "bonferroni")
))

# Create a function to add significance levels to the plot
add_significance <- function(p.value) {
  if(p.value <= 0.001) return("***")
  else if(p.value <= 0.01) return("**")
  else if(p.value <= 0.05) return("*")
  else return("ns")
}

# Create a data frame with pairwise comparisons and their significance
significant_comparisons <- data.frame(
  group1 = sapply(strsplit(dunn_result$comparisons, " - "), `[`, 1),
  group2 = sapply(strsplit(dunn_result$comparisons, " - "), `[`, 2),
  p.value = dunn_result$P.adjusted,
  stringsAsFactors = FALSE
)

# Add significance levels to the data frame
significant_comparisons$significance <- sapply(significant_comparisons$p.value, add_significance)

# Filter out non-significant comparisons
significant_comparisons <- significant_comparisons[significant_comparisons$significance != "ns", ]

# Calculate x positions for the significance bars
iucn_levels <- c("LC", "NT", "VU", "EN", "CR")
x_positions <- seq_along(iucn_levels)
names(x_positions) <- iucn_levels

significant_comparisons$x1 <- x_positions[significant_comparisons$group1]
significant_comparisons$x2 <- x_positions[significant_comparisons$group2]

# Sort comparisons based on the difference between group indices
significant_comparisons$group_diff <- abs(significant_comparisons$x2 - significant_comparisons$x1)
significant_comparisons <- significant_comparisons[order(significant_comparisons$group_diff, decreasing = TRUE), ]

# Calculate y positions for the sorted comparisons using sqrt transformation
max_y <- max(sqrt(results_IUCN_filtered$weighted_protection), na.rm = TRUE)
significant_comparisons$y.position <- seq(max_y + 0.05, 
                                        by = 0.1, 
                                        length.out = nrow(significant_comparisons))

# Create the base violin plot with scale_y_sqrt
violin_plot_EDGE_01 <- ggplot(results_IUCN_filtered, aes(x = factor(IUCN_status, levels = iucn_order), y = weighted_protection)) +
  geom_violin(aes(fill = IUCN_status, color = IUCN_status), trim = FALSE, alpha = 0.5) +
  geom_jitter(width = 0.1, size = 0.5, alpha = 0.5, color = "darkgray") +
  geom_boxplot(width = 0.1, fill = "white", color = "black", outlier.shape = NA, alpha = 0.8) +
  labs(x = "IUCN Status", 
       y = "Weighted Protection") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5), legend.position = "none") +
  scale_x_discrete(limits = iucn_order) +
  scale_fill_manual(values = iucn_colors) +
  scale_color_manual(values = iucn_colors) +
  scale_y_sqrt(limits = c(0,1.2))

# Recalculate max_y for significance bars (no need for sqrt here as scale_y_sqrt handles it)
max_y <- max(results_IUCN_filtered$weighted_protection, na.rm = TRUE)
significant_comparisons$y.position <- seq(max_y + 0.05, 
                                        by = 0.1, 
                                        length.out = nrow(significant_comparisons))

# Add significance bars and labels
violin_plot_with_significance_EDGE_01 <- violin_plot_EDGE_01 +
  geom_segment(data = significant_comparisons,
               aes(x = x1, xend = x2, y = y.position, yend = y.position),
               inherit.aes = FALSE,
               color = "black", size = 0.5) +
  geom_segment(data = significant_comparisons,
               aes(x = x1, xend = x1, y = y.position, yend = y.position - 0.02),
               inherit.aes = FALSE,
               color = "black", size = 0.5) +
  geom_segment(data = significant_comparisons,
               aes(x = x2, xend = x2, y = y.position, yend = y.position - 0.02),
               inherit.aes = FALSE,
               color = "black", size = 0.5) +
  geom_text(data = significant_comparisons,
            aes(x = (x1 + x2) / 2, y = y.position, label = significance),
            inherit.aes = FALSE,
            vjust = -0.2, size = 3)

# Display the updated plot
print(violin_plot_with_significance_EDGE_01)

# Summary statistics with both raw and transformed values
summary_stats <- results_IUCN_filtered %>%
  group_by(IUCN_status) %>%
  summarise(
    count = n(),
    mean_raw = mean(weighted_protection, na.rm = TRUE),
    median_raw = median(weighted_protection, na.rm = TRUE),
    sd_raw = sd(weighted_protection, na.rm = TRUE),
    mean_sqrt = mean(sqrt(weighted_protection), na.rm = TRUE),
    median_sqrt = median(sqrt(weighted_protection), na.rm = TRUE),
    sd_sqrt = sd(sqrt(weighted_protection), na.rm = TRUE)
  ) %>%
  arrange(factor(IUCN_status, levels = iucn_order))

print(summary_stats)

# Save the results
saveRDS(results_IUCN_filtered, file = here::here("Data", "results_IUCN_filtered_EDGE_01.rds"))
```

### Combine six plots in a grid

```{r}
# Then combine them using patchwork:
library(patchwork)
combined_plot <- (violin_plot_with_significance_all + violin_plot_with_significance_nt) /
                 (violin_plot_with_significance_FUSE_01 + violin_plot_with_significance_FUSE_03) /
                 (violin_plot_with_significance_EDGE_01 + violin_plot_with_significance_EDGE_03) +
  plot_annotation(tag_levels = 'A')

# Save the combined plot
ggsave(here::here("combined_violin_plots_six_plots.png"), combined_plot, width = 12, height = 5*3, units = "in")

```

### Ridgeline chart

```{r}
library(tidyverse)
library(ggridges)

# 1. First prepare the IUCN data and function
prepare_iucn_data <- function(species_data, species_col) {
  IUCN <- readRDS(here::here("Data","GAP analyses","sharks_iucn_final.RDS"))
  IUCN$species <- gsub("_", " ", IUCN$Species)
  
  # Rename the species column in the input data to match
  species_data <- species_data %>%
    dplyr::rename(species = all_of(species_col))
  
  results_IUCN <- left_join(IUCN, species_data, by="species") %>%
    mutate(IUCN_status = case_when(
      iucn_GE == 0 ~ "LC",
      iucn_GE == 1 ~ "NT",
      iucn_GE == 2 ~ "VU",
      iucn_GE == 3 ~ "EN",
      iucn_GE == 4 ~ "CR",
      TRUE ~ "Unknown"
    )) %>%
    filter(IUCN_status != "Unknown")
  
  return(results_IUCN)
}

# 2. Prepare all datasets
mpa_data <- results %>%
  dplyr::select(species, percentage_in_ALL_MPA, percentage_in_NT_MPA) %>%
  dplyr::rename(Species = species)

fuse01_data <- readRDS(here::here("Data", "combined_protection_FUSE_01.rds"))
fuse03_data <- readRDS(here::here("Data", "combined_protection_FUSE_03.rds"))
edge01_data <- readRDS(here::here("Data", "combined_protection_EDGE_01.rds"))
edge03_data <- readRDS(here::here("Data", "combined_protection_EDGE_03.rds"))

# 3. Create separate dataframes with IUCN status
# Modify the MPA data scenario names
mpa_iucn <- prepare_iucn_data(mpa_data, "Species") %>%
  dplyr::select(species, IUCN_status, percentage_in_ALL_MPA, percentage_in_NT_MPA) %>%
  pivot_longer(cols = c(percentage_in_ALL_MPA, percentage_in_NT_MPA),
               names_to = "scenario",
               values_to = "protection") %>%
  mutate(scenario = case_when(
    scenario == "percentage_in_NT_MPA" ~ "Current no-take MPAs overlaps",
    scenario == "percentage_in_ALL_MPA" ~ "Current all MPAs overlaps"
  ))

# Modify FUSE scenarios names
fuse01_iucn <- prepare_iucn_data(fuse01_data, "Species") %>%
  dplyr::select(species, IUCN_status, weighted_protection) %>%
  mutate(protection = weighted_protection * 100,
         scenario = "FUSE scenario, budget 10%") %>%
  dplyr::select(-weighted_protection)

fuse03_iucn <- prepare_iucn_data(fuse03_data, "Species") %>%
  dplyr::select(species, IUCN_status, weighted_protection) %>%
  mutate(protection = weighted_protection * 100,
         scenario = "FUSE scenario, budget 30%") %>%
  dplyr::select(-weighted_protection)

# Modify EDGE2 scenarios names
edge01_iucn <- prepare_iucn_data(edge01_data, "species_name") %>%
  dplyr::select(species, IUCN_status, weighted_protection) %>%
  mutate(protection = weighted_protection * 100,
         scenario = "EDGE2 scenario, budget 10%") %>%
  dplyr::select(-weighted_protection)

edge03_iucn <- prepare_iucn_data(edge03_data, "species_name") %>%
  dplyr::select(species, IUCN_status, weighted_protection) %>%
  mutate(protection = weighted_protection * 100,
         scenario = "EDGE2 scenario, budget 30%") %>%
  dplyr::select(-weighted_protection)

# Combine all data
combined_data <- bind_rows(
  mpa_iucn,
  fuse01_iucn,
  fuse03_iucn,
  edge01_iucn,
  edge03_iucn
)

# Update factor levels with new names
combined_data$scenario <- factor(combined_data$scenario,
                               levels = c("Current no-take MPAs overlaps", 
                                        "Current all MPAs overlaps",
                                        "FUSE scenario, budget 10%", 
                                        "FUSE scenario, budget 30%",
                                        "EDGE2 scenario, budget 10%", 
                                        "EDGE2 scenario, budget 30%"))
# 6. Create the plot
iucn_colors <- c(
  "CR" = "#D81E05",
  "EN" = "#FC7F3F",
  "VU" = "#FEC748",
  "NT" = "#58AFFF",
  "LC" = "#38AB38"
)

iucn_order <- c("LC", "NT", "VU", "EN", "CR")

# Modify the plot
rdplot = ggplot(combined_data, 
       aes(x = factor(IUCN_status, levels = iucn_order), 
           y = protection)) +
  geom_violin(aes(fill = IUCN_status, color = IUCN_status), 
              trim = FALSE, 
              alpha = 0.5) +
  geom_jitter(width = 0.1, 
              size = 0.4, 
              alpha = 0.5, 
              color = "darkgray") +
  geom_boxplot(width = 0.1, 
               fill = "white", 
               color = "black", 
               outlier.shape = NA, 
               alpha = 0.8) +
  facet_wrap(~scenario, ncol = 3, nrow= 2, dir = "v") +  # Single column arrangement
  labs(x = "IUCN Red List threat status", 
       y = "Range protected (%)") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5),
    legend.position = "none",
    strip.text = element_text(face = "bold", color = "white"),
    strip.background = element_rect(fill = "black"),
    panel.grid.major.x = element_blank()
  ) +
  scale_x_discrete(limits = iucn_order) +
  scale_fill_manual(values = iucn_colors) +
  scale_color_manual(values = iucn_colors) +
  scale_y_continuous(limits = c(0, 100),
                    breaks = seq(0, 100, 25))
rdplot

# Add white background to the plot
rdplot_white = rdplot + 
  theme(
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "white", color = NA)
  )

# Save only PNG with white background
ggsave(
  filename = here::here("scenarios_IUCN_protection_3cols.png"),
  plot = rdplot_white,
  width = 8,
  height = 5,
  dpi = 300,
  bg = "white"  # This ensures white background in the saved file
)

```

# Relate to species traits

Relate the percentage of species range overlapped by MPAs to the trait space of species. 1) Use Pearson correlation tests between the axes of the trait space and MPA coverage. 2) Predict relationships from a GAM into the kernel density gridded trait space.

```{r}
# Relate to species traits ----
load(here::here("Data", "GAP analyses", "coords_1005.Rdata"))
load(here::here("Data", "GAP analyses", "grids_commonspecies_corrected_021024.Rdata"))

# Load the necessary library
library(tibble)
# Convert to tibble and add row names as the first column
coords <- tibble::rownames_to_column(coords, var = "Species")

colnames(results)[1]="Species"

results_coords=left_join(coords, results)


library(Hmisc)
library(dplyr)
library(tidyr)

# Calculate correlation matrix with p-values
cor_matrix_with_p <- rcorr(as.matrix(results_coords[, c("A1", "A2", "A3", "percentage_in_ALL_MPA", "percentage_in_NT_MPA")]))

# Extract correlation coefficients and p-values
cor_coefficients <- cor_matrix_with_p$r
p_values <- cor_matrix_with_p$P

# Create a function to format the results
format_cor_p <- function(cor, p) {
  sprintf("%.3f (p = %.3f)", cor, p)
}

# Create a data frame with formatted results
result_df <- data.frame(
  Predictor = c("A1", "A2", "A3"),
  `percentage_in_ALL_MPA` = format_cor_p(cor_coefficients["percentage_in_ALL_MPA", c("A1", "A2", "A3")], 
                                         p_values["percentage_in_ALL_MPA", c("A1", "A2", "A3")]),
  `percentage_in_NT_MPA` = format_cor_p(cor_coefficients["percentage_in_NT_MPA", c("A1", "A2", "A3")], 
                                        p_values["percentage_in_NT_MPA", c("A1", "A2", "A3")])
)

library(knitr)
library(kableExtra)

format_correlation_table <- function(result_df) {
  kable(result_df, format = "html", escape = FALSE,
        col.names = c("Predictor", "ALL MPA", "NT MPA"),
        caption = "Pearson Correlation Results") %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"),
                  full_width = FALSE) %>%
    column_spec(1, bold = TRUE) %>%
    add_header_above(c(" " = 1, "Percentage in MPA" = 2)) %>%
    footnote(general = "Values shown as: correlation coefficient (p-value)",
             general_title = "Note:")
}

# Usage:
formatted_table <- format_correlation_table(result_df)
formatted_table

library(gridExtra)

# Scatter plot for A1 vs percentage in ALL MPA
plot_A1 <- ggplot(results_coords, aes(x = A1, y = percentage_in_ALL_MPA)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "lm", color = "red", se = TRUE) +
  theme_minimal() +
  labs(title = "A1 vs Percentage in ALL MPA",
       x = "A1",
       y = "Percentage in ALL MPA")

# Scatter plot for A2 vs percentage in ALL MPA
plot_A2 <- ggplot(results_coords, aes(x = A2, y = percentage_in_ALL_MPA)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "lm", color = "blue", se = TRUE) +
  theme_minimal() +
  labs(title = "A2 vs Percentage in ALL MPA",
       x = "A2",
       y = "Percentage in ALL MPA")

# Set a common aspect ratio for both plots
plot_A1 <- plot_A1 + theme(aspect.ratio = 1)
plot_A2 <- plot_A2 + theme(aspect.ratio = 1)

# Create the combined plot
combined_plot <- grid.arrange(plot_A1, plot_A2, ncol = 2)
#Create kernel density of the trait space 
# Load required packages
library(BAT)

# Assuming 'coords' is your dataframe
# Extract the first two columns (A1 and A2)
load(here::here("Data", "GAP analyses", "coords_1005.Rdata"))
trait_space <- coords[, 1:2]
sp_df=grids.fd_new

# Get the species names from the trait space
trait_species <- rownames(coords)

# Subset the sp_df to keep only the columns (species) found in the trait space
sp_df_filtered <- sp_df[, colnames(sp_df) %in% trait_species]

# Replace all NA values with 0
sp_df_filtered[is.na(sp_df_filtered)] <- 0

# Create a global community matrix
global_comm <- matrix(1, nrow = 1, ncol = ncol(sp_df_filtered))
colnames(global_comm) <- colnames(sp_df_filtered)
rownames(global_comm) <- "global"

global_kernel <- 
  BAT::kernel.build(comm = global_comm, 
                    trait = trait_space,
                    method = "gaussian")

# Extract coordinates (trait values)
trait_coords <- global_kernel@Data

# Extract random points and their corresponding density values
random_points <- global_kernel@RandomPoints
density_values <- global_kernel@ValueAtRandomPoints

# Create a data frame for the density plot
plot_data <- data.frame(
  A1 = random_points[,1],
  A2 = random_points[,2],
  Density = density_values
)

# Create a data frame for the original trait points
trait_data <- data.frame(
  A1 = trait_coords[,1],
  A2 = trait_coords[,2]
)

#Build the GAM 
library(mgcv)
library(dplyr)

# Prepare data for GAM
gam_data <- results_coords %>%
  dplyr::select(Species, A1, A2, percentage_in_ALL_MPA) %>%
  filter(!is.na(percentage_in_ALL_MPA))  # Remove any rows with NA in the response variable

# Build GAM
gam_model <- gam(percentage_in_ALL_MPA ~ s(A1, A2), data = gam_data, method = "REML")
summary(gam_model)

# Make predictions
plot_data$predicted <- predict(gam_model, newdata = plot_data, type = "response")

library(ggplot2)
library(viridis)
# Plot predictions
gam_plot <- ggplot() +
  geom_point(data = plot_data, aes(x = A1, y = A2, color = predicted), alpha = 0.5) +
  #geom_point(data = gam_data, aes(x = A1, y = A2), color = "red", size = 2) +
  scale_color_viridis_c(name = "Predicted % MPA Coverage") +
  theme_minimal() +
  labs(title = "GAM Predictions: Percentage in ALL MPA",
       x = "Trait Axis 1",
       y = "Trait Axis 2")

print(gam_plot)

# Create a smoother surface plot
# Create custom breaks at 10% intervals
custom_breaks <- seq(0, 100, by = 10)

# Custom colors for each 10% increment
custom_colors <- c(
  "#440154", # 0-10%
  "#414487", # 10-20%
  "#2A788E", # 20-30%
  "#22A884", # 30-40%
  "#7AD151", # 40-50%
  "#FDE725", # 50-60%
  "#FCA50A", # 60-70%
  "#F47B07", # 70-80%
  "#E85110", # 80-90%
  "#DC2F1F"  # 90-100%
)

gam_density_plot_GAP_all_MPAs <- ggplot(plot_data, aes(x = A1, y = A2, z = predicted)) +
  stat_summary_2d(fun = mean, bins = 50) +
  scale_fill_gradientn(
    name = "MPA Coverage (%)",
    colors = custom_colors,
    breaks = custom_breaks,
    limits = c(0, 100),
    oob = scales::squish
  ) +
  theme_minimal() +
  labs(title = "GAM Predictions: Percentage in ALL MPA",
       x = "Trait Axis 1",
       y = "Trait Axis 2")

print(gam_density_plot_GAP_all_MPAs)
```

**Key message:** There is a significant, relationship between the percentage of the range of sharks and rays covered by MPAs and axis 1 & 2 of the trait space. Species located in the bottom right corner of the trait space tend to be more protected, this relationship is highly significant, however, very week (R2 = 0.04, p \< 0.001).

## Relate to CAPTAIN protect fraction : FUSE 0.3

```{r}
# Read the data
combined_protection_FUSE_03 <- readRDS(here::here("Data", "combined_protection_FUSE_03.rds"))
combined_protection_FUSE_01 <- readRDS(here::here("Data", "combined_protection_FUSE_01.rds"))

# Load and prepare data
load(here::here("Data", "GAP analyses", "coords_1005.Rdata"))
load(here::here("Data", "GAP analyses", "grids_commonspecies_corrected_021024.Rdata"))

# Convert to tibble and add row names as the first column
coords <- tibble::rownames_to_column(coords, var = "Species")

# Merge with FUSE data
library(dplyr)
results_coords <- left_join(coords, combined_protection_FUSE_01, by = "Species") %>%
  rename(FUSE_01_protection = weighted_protection) %>%
  left_join(combined_protection_FUSE_03, by = "Species") %>%
  rename(FUSE_03_protection = weighted_protection)

# Calculate correlation matrix
cor_matrix_with_p <- rcorr(as.matrix(results_coords[, c("A1", "A2", "A3", "FUSE_03_protection", "FUSE_01_protection")]))

# Extract correlation coefficients and p-values
cor_coefficients <- cor_matrix_with_p$r
p_values <- cor_matrix_with_p$P

# Format results
format_cor_p <- function(cor, p) {
  sprintf("%.3f (p = %.3f)", cor, p)
}

result_df <- data.frame(
  Predictor = c("A1", "A2", "A3"),
  `FUSE_03_protection` = format_cor_p(cor_coefficients["FUSE_03_protection", c("A1", "A2", "A3")], 
                                     p_values["FUSE_03_protection", c("A1", "A2", "A3")]),
  `FUSE_01_protection` = format_cor_p(cor_coefficients["FUSE_01_protection", c("A1", "A2", "A3")], 
                                     p_values["FUSE_01_protection", c("A1", "A2", "A3")])
)

# Format table
format_correlation_table <- function(result_df) {
  kable(result_df, format = "html", escape = FALSE,
        col.names = c("Predictor", "FUSE 03", "FUSE 01"),
        caption = "Pearson Correlation Results") %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"),
                  full_width = FALSE) %>%
    column_spec(1, bold = TRUE) %>%
    add_header_above(c(" " = 1, "Weighted Protection" = 2)) %>%
    footnote(general = "Values shown as: correlation coefficient (p-value)",
             general_title = "Note:")
}

formatted_table <- format_correlation_table(result_df)
formatted_table

# Scatter plots
# FUSE 03
plot_A1 <- ggplot(results_coords, aes(x = A1, y = FUSE_03_protection)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "lm", color = "red", se = TRUE) +
  theme_minimal() +
  labs(title = "A1 vs FUSE 03 Protection",
       x = "A1",
       y = "FUSE 03 Protection")

plot_A2 <- ggplot(results_coords, aes(x = A2, y = FUSE_03_protection)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "lm", color = "blue", se = TRUE) +
  theme_minimal() +
  labs(title = "A2 vs FUSE 03 Protection",
       x = "A2",
       y = "FUSE 03 Protection")

plot_A1 <- plot_A1 + theme(aspect.ratio = 1)
plot_A2 <- plot_A2 + theme(aspect.ratio = 1)

combined_plot_FUSE_03 <- grid.arrange(plot_A1, plot_A2, ncol = 2)

# FUSE 01
plot_A1 <- ggplot(results_coords, aes(x = A1, y = FUSE_01_protection)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "lm", color = "red", se = TRUE) +
  theme_minimal() +
  labs(title = "A1 vs FUSE 01 Protection",
       x = "A1",
       y = "FUSE 01 Protection")

plot_A2 <- ggplot(results_coords, aes(x = A2, y = FUSE_01_protection)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "lm", color = "blue", se = TRUE) +
  theme_minimal() +
  labs(title = "A2 vs FUSE 01 Protection",
       x = "A2",
       y = "FUSE 01 Protection")

plot_A1 <- plot_A1 + theme(aspect.ratio = 1)
plot_A2 <- plot_A2 + theme(aspect.ratio = 1)

combined_plot_FUSE_01 <- grid.arrange(plot_A1, plot_A2, ncol = 2)

# Now proceed with GAM analysis: FUSE 03
gam_data <- results_coords %>%
  dplyr::select(Species, A1, A2, FUSE_03_protection) %>%
  filter(!is.na(FUSE_03_protection))

gam_model <- gam(FUSE_03_protection ~ s(A1, A2), data = gam_data, method = "REML")
summary(gam_model)

# Make predictions and plot
plot_data$predicted_FUSE_03 <- predict(gam_model, newdata = plot_data, type = "response")

# Create the plots
gam_plot <- ggplot() +
  geom_point(data = plot_data, aes(x = A1, y = A2, color = predicted_FUSE_03), alpha = 0.5) +
  scale_color_viridis_c(name = "Predicted FUSE 03 Protection") +
  theme_minimal() +
  labs(title = "GAM Predictions: FUSE 03 Protection",
       x = "Trait Axis 1",
       y = "Trait Axis 2")

print(gam_plot)

# Create custom breaks at 10% intervals
custom_breaks <- seq(0, 100, by = 10)

# Custom colors for each 10% increment
custom_colors <- c(
  "#440154", # 0-10%
  "#414487", # 10-20%
  "#2A788E", # 20-30%
  "#22A884", # 30-40%
  "#7AD151", # 40-50%
  "#FDE725", # 50-60%
  "#FCA50A", # 60-70%
  "#F47B07", # 70-80%
  "#E85110", # 80-90%
  "#DC2F1F"  # 90-100%
)

gam_density_plot_FUSE_03 <- ggplot(plot_data, aes(x = A1, y = A2, z = predicted_FUSE_03*100)) +
  stat_summary_2d(fun = mean, bins = 50) +
  scale_fill_gradientn(
    name = "Protection (%)",
    colors = custom_colors,
    breaks = custom_breaks,
    limits = c(0, 100),
    oob = scales::squish
  ) +
  theme_minimal() +
  labs(title = "GAM Predictions: FUSE 03 Protection",
       x = "Trait Axis 1",
       y = "Trait Axis 2")

print(gam_density_plot_FUSE_03)

# Now proceed with GAM analysis: FUSE 01
gam_data <- results_coords %>%
  dplyr::select(Species, A1, A2, FUSE_01_protection) %>%
  filter(!is.na(FUSE_01_protection))

gam_model <- gam(FUSE_01_protection ~ s(A1, A2), data = gam_data, method = "REML")
summary(gam_model)

# Make predictions and plot
plot_data$predicted_FUSE_01 <- predict(gam_model, newdata = plot_data, type = "response")

# Create the plots
gam_plot <- ggplot() +
  geom_point(data = plot_data, aes(x = A1, y = A2, color = predicted_FUSE_01), alpha = 0.5) +
  scale_color_viridis_c(name = "Predicted FUSE 01 Protection", limits= c(0,1)) +
  theme_minimal() +
  labs(title = "GAM Predictions: FUSE 01 Protection",
       x = "Trait Axis 1",
       y = "Trait Axis 2")

print(gam_plot)

# Create custom breaks at 10% intervals
custom_breaks <- seq(0, 100, by = 10)

# Create custom colors for each 10% increment
custom_colors <- c(
  "#440154", # 0-10%
  "#414487", # 10-20%
  "#2A788E", # 20-30%
  "#22A884", # 30-40%
  "#7AD151", # 40-50%
  "#FDE725", # 50-60%
  "#FCA50A", # 60-70%
  "#F47B07", # 70-80%
  "#E85110", # 80-90%
  "#DC2F1F"  # 90-100%
)

gam_density_plot_FUSE_01 <- ggplot(plot_data, aes(x = A1, y = A2, z = predicted_FUSE_01*100)) +
  stat_summary_2d(fun = mean, bins = 50) +
  scale_fill_gradientn(
    name = "Protection (%)",
    colors = custom_colors,
    breaks = custom_breaks,
    limits = c(0, 100),
    oob = scales::squish
  ) +
  theme_minimal() +
  labs(title = "GAM Predictions: FUSE 01 Protection",
       x = "Trait Axis 1",
       y = "Trait Axis 2")

print(gam_density_plot_FUSE_01)

```

### Combine three FD spaces in a grid

```{r}
# Create breaks at 10% increments
custom_breaks <- seq(0, 70, by = 10)  # Now in percentages

# Same custom colors
custom_colors <- c(
  "#440154", # Dark purple
  "#414487", 
  "#2A788E", 
  "#22A884", 
  "#7AD151", 
  "#FDE725", 
  "#FCA50A", 
  "#F47B07", 
  "#E85110", 
  "#DC2F1F"  # Dark red
)

# Common theme to remove individual legends
no_legend_theme <- theme_minimal() +
  theme(legend.position = "none")

# Theme for the middle plot with modified legend
middle_plot_theme <- theme_minimal() +
  theme(
    legend.position = "right",
    legend.key.height = unit(1, "cm"),  # Make legend longer
    legend.key.width = unit(0.6, "cm"),   # Make legend wider
    legend.title = element_text(size = 12)
  )

# Update each plot with percentage values, no titles, and no individual legends
gam_density_plot_GAP_all_MPAs <- ggplot(plot_data, aes(x = A1, y = A2, z = predicted)) +
  stat_summary_2d(fun = mean, bins = 50) +
  scale_fill_gradientn(
    name = "Range protected (%)",
    colors = custom_colors,
    breaks = custom_breaks,
    limits = c(0, 70),
    oob = scales::squish
  ) +
  no_legend_theme +
  labs(x = "Trait Axis 1",
       y = "Trait Axis 2")

gam_density_plot_FUSE_01 <- ggplot(plot_data, aes(x = A1, y = A2, z = predicted_FUSE_01 * 100)) +
  stat_summary_2d(fun = mean, bins = 50) +
  scale_fill_gradientn(
    name = "Range protected (%)",
    colors = custom_colors,
    breaks = custom_breaks,
    limits = c(0, 70),
    oob = scales::squish
  ) +
  middle_plot_theme +  # Apply the modified theme with larger legend
  labs(x = "Trait Axis 1",
       y = "Trait Axis 2")

gam_density_plot_FUSE_03 <- ggplot(plot_data, aes(x = A1, y = A2, z = predicted_FUSE_03 * 100)) +
  stat_summary_2d(fun = mean, bins = 50) +
  scale_fill_gradientn(
    name = "",
    colors = custom_colors,
    breaks = custom_breaks,
    limits = c(0, 70),
    oob = scales::squish
  ) +
  no_legend_theme +
  labs(x = "Trait Axis 1",
       y = "Trait Axis 2")

# Combine plots
library(patchwork)

# Combine plots
combined_plot <- (gam_density_plot_GAP_all_MPAs / 
                 gam_density_plot_FUSE_01 / 
                 gam_density_plot_FUSE_03) +
  plot_annotation(tag_levels = 'A') +
  plot_layout(ncol = 1)

print(combined_plot)

# Save the combined plot
ggsave(here::here("combined_functional_spaces_with_predictions.png"), combined_plot, width = 8*0.9, height = 18*0.8, units = "in")
```

# Relate to phylogeny : GAP analysis results

Relate the percentage of species range overlapped by MPAs to the phylogenetic tree of species, with tests of phylogenetic signal and plots of trees with the variable mapped onto the tree.

```{r}
# Relate to phylogeny ----

# For percentage range in ALL MPAs 
library(phytools)
library(here)
library(dplyr)
library(purrr)
library(ape)
library(stringr)

# Load the list of trees
load(here::here("Data", "GAP analyses", "list_tree_sharks_p.Rdata"))

# Function to modify species names
modify_species_name <- function(name) {
  str_replace(name, " ", "_")
}

# Modify species names in the results dataframe
results_IUCN_filtered <- results_IUCN_filtered %>%
  mutate(species_modified = modify_species_name(species))

compute_phylo_signal <- function(tree, data) {
  # Ensure the data is in the same order as the tree tips and remove NAs
  matched_data <- data %>%
    filter(species_modified %in% tree$tip.label) %>%
    filter(!is.na(percentage_in_ALL_MPA)) %>%
    arrange(match(species_modified, tree$tip.label))
  
  n_species_after_matching <- nrow(matched_data)
  
  # Prune the tree to match the available data
  pruned_tree <- keep.tip(tree, matched_data$species_modified)
  
  n_tips_pruned_tree <- length(pruned_tree$tip.label)
  
  # Compute phylogenetic signal using Pagel's lambda, capturing any output
  signal <- tryCatch({
    captured_output <- capture.output({
      result <- phylosig(pruned_tree, matched_data$percentage_in_ALL_MPA, method = "lambda", test = TRUE)
    })
    result$captured_output <- captured_output
    result
  }, error = function(e) {
    error_message <- paste("Error in phylosig:", e$message)
    return(list(lambda = NA, P = NA, error = error_message, captured_output = NA))
  })
  
  # Return all information
  return(list(
    lambda = signal$lambda,
    p_value = signal$P,
    n_species = n_species_after_matching,
    n_tips_pruned_tree = n_tips_pruned_tree,
    error = if(!is.null(signal$error)) signal$error else NA,
    captured_output = paste(signal$captured_output, collapse = "\n")
  ))
}

# Apply the function to all trees: using the first two only for the moment to save time
results <- map_dfr(list_tree_sharks_p[1:2], ~compute_phylo_signal(.x, results_IUCN_filtered), .id = "tree")

# Now, create the kable separately
library(knitr)
library(dplyr)
library(kableExtra)

results %>%
  select(1:4) %>%
  kable(caption = "Phylogenetic Signal Results for all MPAs",
        col.names = c("Tree", "Lambda", "P-value", "Number of Species"),
        digits = 3,
        align = c('l', 'c', 'c', 'c')) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))

# Compute summary statistics
summary_stats <- results %>%
  summarise(
    mean_lambda = mean(lambda, na.rm = TRUE),
    median_lambda = median(lambda, na.rm = TRUE),
    sd_lambda = sd(lambda, na.rm = TRUE),
    mean_p = mean(p_value, na.rm = TRUE),
    median_p = median(p_value, na.rm = TRUE),
    sd_p = sd(p_value, na.rm = TRUE),
    mean_n_species = mean(n_species, na.rm = TRUE),
    min_n_species = min(n_species, na.rm = TRUE),
    max_n_species = max(n_species, na.rm = TRUE)
  )

#print(summary_stats)

# For percentage range in no-take MPAs 
library(phytools)
library(here)
library(dplyr)
library(purrr)
library(ape)
library(stringr)

# Load the list of trees
load(here::here("Data", "GAP analyses", "list_tree_sharks_p.Rdata"))

# Function to modify species names
modify_species_name <- function(name) {
  str_replace(name, " ", "_")
}

# Modify species names in the results dataframe
results_IUCN_filtered <- results_IUCN_filtered %>%
  mutate(species_modified = modify_species_name(species))

compute_phylo_signal <- function(tree, data) {
  # Ensure the data is in the same order as the tree tips and remove NAs
  matched_data <- data %>%
    filter(species_modified %in% tree$tip.label) %>%
    filter(!is.na(percentage_in_NT_MPA)) %>%
    arrange(match(species_modified, tree$tip.label))
  
  n_species_after_matching <- nrow(matched_data)
  
  # Prune the tree to match the available data
  pruned_tree <- keep.tip(tree, matched_data$species_modified)
  
  n_tips_pruned_tree <- length(pruned_tree$tip.label)
  
  # Compute phylogenetic signal using Pagel's lambda, capturing any output
  signal <- tryCatch({
    captured_output <- capture.output({
      result <- phylosig(pruned_tree, matched_data$percentage_in_NT_MPA, method = "lambda", test = TRUE)
    })
    result$captured_output <- captured_output
    result
  }, error = function(e) {
    error_message <- paste("Error in phylosig:", e$message)
    return(list(lambda = NA, P = NA, error = error_message, captured_output = NA))
  })
  
  # Return all information
  return(list(
    lambda = signal$lambda,
    p_value = signal$P,
    n_species = n_species_after_matching,
    n_tips_pruned_tree = n_tips_pruned_tree,
    error = if(!is.null(signal$error)) signal$error else NA,
    captured_output = paste(signal$captured_output, collapse = "\n")
  ))
}

# Apply the function to all trees: use only the first two trees for the moment to save time
results <- map_dfr(list_tree_sharks_p[1:2], ~compute_phylo_signal(.x, results_IUCN_filtered), .id = "tree")

# Now, create the kable separately
library(knitr)
library(dplyr)
library(kableExtra)

results %>%
  select(1:4) %>%
  kable(caption = "Phylogenetic Signal Results for no-take MPAs",
        col.names = c("Tree", "Lambda", "P-value", "Number of Species"),
        digits = 3,
        align = c('l', 'c', 'c', 'c')) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))

# Compute summary statistics
summary_stats <- results %>%
  summarise(
    mean_lambda = mean(lambda, na.rm = TRUE),
    median_lambda = median(lambda, na.rm = TRUE),
    sd_lambda = sd(lambda, na.rm = TRUE),
    mean_p = mean(p_value, na.rm = TRUE),
    median_p = median(p_value, na.rm = TRUE),
    sd_p = sd(p_value, na.rm = TRUE),
    mean_n_species = mean(n_species, na.rm = TRUE),
    min_n_species = min(n_species, na.rm = TRUE),
    max_n_species = max(n_species, na.rm = TRUE)
  )

#print(summary_stats)


#Plot the tree with color gradient on terminal branches 
library(ggtree)
library(ggplot2)
library(dplyr)
library(RColorBrewer)
library(tidytree)

# Function to get a color palette
get_color_palette <- function(n) {
  colorRampPalette(brewer.pal(9, "YlGnBu"))(n)  # Changed to YlGnBu
}

# All MPAs 
# Function to plot the circular tree
plot_circular_colored_tree <- function(tree, data) {
  # Ensure the data is in the same order as the tree tips and remove NAs
  matched_data <- data %>%
    filter(species_modified %in% tree$tip.label) %>%
    filter(!is.na(percentage_in_ALL_MPA)) %>%
    arrange(match(species_modified, tree$tip.label))
  
  # Print summary of percentage_in_ALL_MPA for debugging
  #print(summary(matched_data$percentage_in_ALL_MPA))
  
  # Prune the tree to match the available data
  pruned_tree <- ape::keep.tip(tree, matched_data$species_modified)
  
  # Create color palette
  n_colors <- 100
  color_palette <- get_color_palette(n_colors)
  
  # Convert tree to tidy format and add percentage data
  tree_data <- as_tibble(pruned_tree) %>%
    left_join(matched_data, by = c("label" = "species_modified"))
  
  # Plot the circular tree
  p <- ggtree(pruned_tree, layout="circular", aes(color=percentage_in_ALL_MPA), size =0.3) %<+% tree_data
  
  # Color the branches
  p <- p + 
    scale_color_gradientn(colours = color_palette, 
                          name = "% Range within all MPAs",
                          limits = c(0, 100),
                          na.value = "grey50") +
    theme(legend.position = "right")
  
  # Remove default labels and add a title
  p <- p + theme(plot.title = element_text(hjust = 0.5)) 
  
  return(p)
}

# Plot the first tree
tree_plot_ALL <- plot_circular_colored_tree(list_tree_sharks_p[[1]], results_IUCN_filtered)

# Display the plot
print(tree_plot_ALL)

# No-take MPAs 
# Function to plot the circular tree
plot_circular_colored_tree <- function(tree, data) {
  # Ensure the data is in the same order as the tree tips and remove NAs
  matched_data <- data %>%
    filter(species_modified %in% tree$tip.label) %>%
    filter(!is.na(percentage_in_NT_MPA)) %>%
    arrange(match(species_modified, tree$tip.label))
  
  # Print summary of percentage_in_ALL_MPA for debugging
  #print(summary(matched_data$percentage_in_NT_MPA))
  
  # Prune the tree to match the available data
  pruned_tree <- ape::keep.tip(tree, matched_data$species_modified)
  
  # Create color palette
  n_colors <- 100
  color_palette <- get_color_palette(n_colors)
  
  # Convert tree to tidy format and add percentage data
  tree_data <- as_tibble(pruned_tree) %>%
    left_join(matched_data, by = c("label" = "species_modified"))
  
  # Plot the circular tree
  p <- ggtree(pruned_tree, layout="circular", aes(color=percentage_in_NT_MPA), size =0.3) %<+% tree_data
  
  # Color the branches
  p <- p + 
    scale_color_gradientn(colours = color_palette, 
                          name = "% Range within no-take MPAs",
                          limits = c(0, 100),
                          na.value = "grey50") +
    theme(legend.position = "right")
  
  # Remove default labels and add a title
  p <- p + theme(plot.title = element_text(hjust = 0.5)) 
  
  return(p)
}

# Plot the first tree
tree_plot_NT <- plot_circular_colored_tree(list_tree_sharks_p[[1]], results_IUCN_filtered)

# Display the plot
print(tree_plot_NT)

#ggpubr::ggarrange(tree_plot_ALL, tree_plot_NT, common.legend = T, legend = "bottom")
```

**Key message:** There are significant phylogenetic signals with the percentage of MPA coverage for all MPAs (lambda= 0.12-0.17; \< 0.05), and for no-take MPAs, this relationship is almost significant (lambda = 0.04; 0.08 \> p \> 0.05). However, patterns are not obvious on the trees. Analyses were ran for two trees only but can be replicated to all 100 trees.

### Combine all trees in a single one : GAP analysis only

```{r}
library(tibble)
plot_combined_circular_tree <- function(tree, data) {
  library(ggplot2)
  library(ggtree)
  
  # Ensure the data is in the same order as the tree tips
  matched_data <- data %>%
    filter(species_modified %in% tree$tip.label) %>%
    arrange(match(species_modified, tree$tip.label))
  
  # Create a data frame specifically for the heatmap
  # Reordering columns to put no-take MPAs first
  heatmap_data <- matched_data %>%
    select(species_modified, percentage_in_NT_MPA, percentage_in_ALL_MPA) %>%  # Reordered columns
    # Convert to numeric explicitly to avoid any type issues
    mutate(
      percentage_in_NT_MPA = as.numeric(percentage_in_NT_MPA),
      percentage_in_ALL_MPA = as.numeric(percentage_in_ALL_MPA)
    )
  
  # Set row names manually
  heatmap_matrix <- as.matrix(heatmap_data[, -1])  # Remove species column and convert to matrix
  rownames(heatmap_matrix) <- heatmap_data$species_modified  # Set the row names
  
  # Prune the tree to match the available data
  pruned_tree <- ape::keep.tip(tree, rownames(heatmap_matrix))
  
  # Create color palette
  n_colors <- 100
  color_palette <- get_color_palette(n_colors)
  
  # Base circular tree plot with light grey for tree lines
  p <- ggtree(pruned_tree, layout="circular", size=0.3, color="lightgrey")
  
  # Add heatmap rings without column names
  p <- gheatmap(p, heatmap_matrix, 
                width=0.2,
                offset=0.1, 
                colnames=FALSE,  # No column names
                font.size=3) + 
    scale_fill_gradientn(
      colours=color_palette, 
      name="Range Coverage (%)",
      limits=c(0, 100),
      na.value="grey80",
      oob=scales::squish
    )
  
  # No title as requested
  p <- p + theme(
    plot.margin = margin(t=10, r=10, b=10, l=10, unit="pt")  # Keep some margin for readability
  )
  
  return(p)
}

#Call the function to create the plot
combined_tree_plot <- plot_combined_circular_tree(list_tree_sharks_p[[1]], results_IUCN_filtered)

# Display the plot
combined_tree_plot
# or
print(combined_tree_plot)

# Alternative with geom_fruit()
library(ggtree)
library(ggnewscale)
library(dplyr)
library(ggtreeExtra)

plot_dual_ring_tree <- function(tree, data) {
  # Make a copy of the data to avoid modifying the original
  plot_data <- data %>%
    filter(species_modified %in% tree$tip.label)
  
  # Check if we have any valid data
  if(all(is.na(plot_data$percentage_in_ALL_MPA)) && all(is.na(plot_data$percentage_in_NT_MPA))) {
    stop("No valid percentage data available for visualization")
  }
  
  # Convert percentage columns to numeric if they aren't already
  plot_data$percentage_in_ALL_MPA <- as.numeric(plot_data$percentage_in_ALL_MPA)
  plot_data$percentage_in_NT_MPA <- as.numeric(plot_data$percentage_in_NT_MPA)
  
  # Prune the tree to match the available data
  pruned_tree <- ape::keep.tip(tree, plot_data$species_modified)
  
  # Create color palette
  n_colors <- 100
  color_palette <- get_color_palette(n_colors)
  
  # Create the base tree
  p <- ggtree(pruned_tree, layout="circular", size=0.3)
  
  # Debug information
  cat("Number of species in tree:", length(pruned_tree$tip.label), "\n")
  cat("Number of species in data:", nrow(plot_data), "\n")
  cat("ALL MPA data range:", range(plot_data$percentage_in_ALL_MPA, na.rm=TRUE), "\n")
  cat("NT MPA data range:", range(plot_data$percentage_in_NT_MPA, na.rm=TRUE), "\n")
  
  # Add first ring for ALL MPAs (only if we have valid data)
  if(!all(is.na(plot_data$percentage_in_ALL_MPA))) {
    p <- p + 
      geom_fruit(
        data=plot_data,
        geom=geom_col,
        mapping=aes(y=species_modified, x=percentage_in_ALL_MPA, fill=percentage_in_ALL_MPA),
        orientation="y",
        offset=0.1,
        width=0.08,
        pwidth=0.3,
        axis.params=list(axis="x", text.size=2, vjust=0.5, hjust=1)
      ) + 
      scale_fill_gradientn(
        colors=color_palette,
        name="% Range in\nAll MPAs",
        limits=c(0, 100),
        na.value="grey80",
        oob=scales::squish
      )
  }
  
  # Add second ring for NT MPAs (only if we have valid data)
  if(!all(is.na(plot_data$percentage_in_NT_MPA))) {
    p <- p + 
      new_scale_fill() +
      geom_fruit(
        data=plot_data,
        geom=geom_col,
        mapping=aes(y=species_modified, x=percentage_in_NT_MPA, fill=percentage_in_NT_MPA),
        orientation="y",
        offset=0.25,
        width=0.08,
        pwidth=0.3,
        axis.params=list(axis="x", text.size=2, vjust=0.5, hjust=1)
      ) + 
      scale_fill_gradientn(
        colors=color_palette,
        name="% Range in\nNo-Take MPAs",
        limits=c(0, 100),
        na.value="grey80",
        oob=scales::squish
      )
  }
  
  # Add title
  p <- p + 
    ggtitle("Phylogenetic Distribution of MPA Coverage") +
    theme(plot.title = element_text(hjust=0.5, size=14))
  
  return(p)
}

# Plot the modified version
dual_ring_tree <- plot_dual_ring_tree(list_tree_sharks_p[[1]], results_IUCN_filtered)
```

## Relate to phylogeny : CAPTAIN results

Relate the protected fraction of species ranges to the phylogenetic tree of species, with tests of phylogenetic signal and plots of trees with the variable mapped onto the tree.

```{r}
library(phytools)
library(here)
library(dplyr)
library(purrr)
library(ape)
library(stringr)

# Load the list of trees
load(here::here("Data", "GAP analyses", "list_tree_sharks_p.Rdata"))

# Function to modify species names
modify_species_name <- function(name) {
  str_replace(name, " ", "_")
}

# Modify species names in the EDGE dataframes
combined_protection_EDGE_03 <- combined_protection_EDGE_03 %>%
  mutate(species_modified = modify_species_name(species_name))

combined_protection_EDGE_01 <- combined_protection_EDGE_01 %>%
  mutate(species_modified = modify_species_name(species_name))

# Function to compute phylogenetic signal for EDGE_03
compute_phylo_signal_03 <- function(tree, data) {
  # Match data and remove NAs
  matched_data <- data %>%
    filter(species_modified %in% tree$tip.label) %>%
    filter(!is.na(weighted_protection)) %>%
    arrange(match(species_modified, tree$tip.label))
  
  n_species_after_matching <- nrow(matched_data)
  
  # Prune tree
  pruned_tree <- keep.tip(tree, matched_data$species_modified)
  
  n_tips_pruned_tree <- length(pruned_tree$tip.label)
  
  # Compute phylogenetic signal
  signal <- tryCatch({
    captured_output <- capture.output({
      result <- phylosig(pruned_tree, matched_data$weighted_protection, method = "lambda", test = TRUE)
    })
    result$captured_output <- captured_output
    result
  }, error = function(e) {
    return(list(lambda = NA, P = NA, error = e$message, captured_output = NA))
  })
  
  return(list(
    lambda = signal$lambda,
    p_value = signal$P,
    n_species = n_species_after_matching,
    n_tips_pruned_tree = n_tips_pruned_tree,
    error = if(!is.null(signal$error)) signal$error else NA,
    captured_output = paste(signal$captured_output, collapse = "\n")
  ))
}

# Apply function to trees for EDGE_03
results_03 <- map_dfr(list_tree_sharks_p[1:2], ~compute_phylo_signal_03(.x, combined_protection_EDGE_03), .id = "tree")

# Function to format p-values (vectorized version)
format_p_value <- function(p) {
  sapply(p, function(x) {
    if (is.na(x)) return(NA)
    if (x < 0.001) return("p < 0.001")
    if (x < 0.01) return(sprintf("p = %.3f", x))
    return(sprintf("p = %.3f", x))
  })
}

# Create table for EDGE_03 results with formatted p-values
results_03 %>%
  dplyr::select(1:4) %>%
  mutate(p_value = format_p_value(p_value)) %>%
  kable(caption = "Phylogenetic Signal Results for EDGE_03 Protection",
        col.names = c("Tree", "Lambda", "P-value", "Number of Species"),
        digits = 3,
        align = c('l', 'c', 'c', 'c')) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))

# Repeat for EDGE_01
results_01 <- map_dfr(list_tree_sharks_p[1:2], ~compute_phylo_signal_03(.x, combined_protection_EDGE_01), .id = "tree")

results_01 %>%
  dplyr::select(1:4) %>%
  mutate(p_value = format_p_value(p_value)) %>%
  kable(caption = "Phylogenetic Signal Results for EDGE_03 Protection",
        col.names = c("Tree", "Lambda", "P-value", "Number of Species"),
        digits = 3,
        align = c('l', 'c', 'c', 'c')) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))

# Plot circular trees
library(ggtree)
library(ggplot2)
library(RColorBrewer)
library(tidytree)

# Function to get color palette
get_color_palette <- function(n) {
  colorRampPalette(brewer.pal(9, "YlGnBu"))(n)
}

# Function to plot circular tree
plot_circular_colored_tree_EDGE <- function(tree, data) {
  matched_data <- data %>%
    filter(species_modified %in% tree$tip.label) %>%
    filter(!is.na(weighted_protection)) %>%
    arrange(match(species_modified, tree$tip.label))
  
  pruned_tree <- ape::keep.tip(tree, matched_data$species_modified)
  
  n_colors <- 100
  color_palette <- get_color_palette(n_colors)
  
  tree_data <- as_tibble(pruned_tree) %>%
    left_join(matched_data, by = c("label" = "species_modified"))
  
  p <- ggtree(pruned_tree, layout="circular", aes(color=weighted_protection), size=0.3) %<+% tree_data
  
  p <- p + 
    scale_color_gradientn(colours = color_palette, 
                         name = "Weighted Protection",
                         na.value = "grey50", limits = c(0,1)) +
    theme(legend.position = "right",
          plot.title = element_text(hjust = 0.5))
  
  return(p)
}

# Plot trees for both EDGE_03 and EDGE_01
tree_plot_03 <- plot_circular_colored_tree_EDGE(list_tree_sharks_p[[1]], combined_protection_EDGE_03)
print(tree_plot_03)

tree_plot_01 <- plot_circular_colored_tree_EDGE(list_tree_sharks_p[[1]], combined_protection_EDGE_01)
print(tree_plot_01)

#Identify clades with higher prioritisation 
# Modified function with improved visualization
plot_and_analyze_clades <- function(tree, data, title = "") {
  matched_data <- data %>%
    filter(species_modified %in% tree$tip.label) %>%
    filter(!is.na(weighted_protection)) %>%
    arrange(match(species_modified, tree$tip.label))
  
  pruned_tree <- ape::keep.tip(tree, matched_data$species_modified)
  
  # Calculate mean protection value for each genus
  genus_data <- matched_data %>%
    mutate(genus = str_extract(species_modified, "^[^_]+")) %>%
    group_by(genus) %>%
    summarize(
      mean_protection = mean(weighted_protection),
      n_species = n()
    ) %>%
    filter(mean_protection > quantile(mean_protection, 0.75)) %>%
    arrange(desc(mean_protection))
  
  # Create tree plot without grey borders
  p <- ggtree(pruned_tree, layout="circular", size=0.2) 
  
  # Add the data to the tree without borders
  p <- p %<+% matched_data + 
    geom_tippoint(aes(color=weighted_protection), size=2, shape=16) +  # shape=16 gives solid dots without borders
    scale_color_gradientn(
      colours = colorRampPalette(brewer.pal(9, "YlOrRd"))(100),
      name = "Protection Priority",
      limits = c(0, 1)
    ) +
    ggtitle(title) +
    theme(
      plot.title = element_text(hjust = 0.5, size = 14),
      legend.position = "right",
      panel.background = element_blank(),
      plot.background = element_blank()
    )
  
  # Highlight high-priority genera with more transparent highlights
  top_genera <- genus_data$genus[1:5]
  for(genus in top_genera) {
    tips <- matched_data %>%
      filter(str_detect(species_modified, paste0("^", genus))) %>%
      pull(species_modified)
    
    if(length(tips) > 0) {
      p <- p + geom_hilight(node = MRCA(p, tips), fill = "blue", alpha = 0.1)
    }
  }
  
  return(list(
    plot = p,
    high_priority_genera = genus_data
  ))
}

# Create plots for both scenarios
analysis_03 <- plot_and_analyze_clades(
  list_tree_sharks_p[[1]], 
  combined_protection_EDGE_03, 
  "EDGE Protection Priority (0.3 budget)"
)

analysis_01 <- plot_and_analyze_clades(
  list_tree_sharks_p[[1]], 
  combined_protection_EDGE_01, 
  "EDGE Protection Priority (0.1 budget)"
)

# Display combined plot
grid.arrange(
  analysis_03$plot, 
  analysis_01$plot, 
  ncol = 2
)

# Print results
print("Top priority genera (EDGE 0.3):")
print(analysis_03$high_priority_genera %>% head(10))
print("\nTop priority genera (EDGE 0.1):")
print(analysis_01$high_priority_genera %>% head(10))

```

### Combine four trees in a grid

```{r}
# Then combine them using patchwork:
library(patchwork)
combined_plot <- (tree_plot_NT + tree_plot_ALL) /
  (tree_plot_01 + tree_plot_03) + 
  plot_annotation(tag_levels = 'A')

# Save the combined plot
ggsave(here::here("combined_phylogenetic_trees.png"), combined_plot, 
       width = 12, height = 8, units = "in")

```

### Combine all trees in a single one : GAP analysis and EDGE 2 values -\> heatmap approach

```{r}
plot_combined_circular_tree <- function(tree, data, edge_data_01, edge_data_03) {
  library(ggplot2)
  library(ggtree)
  library(dplyr)
  
  # Ensure all datasets have common species
  common_species <- Reduce(intersect, list(
    data$species_modified[data$species_modified %in% tree$tip.label],
    edge_data_01$species_modified[edge_data_01$species_modified %in% tree$tip.label & !is.na(edge_data_01$weighted_protection)],
    edge_data_03$species_modified[edge_data_03$species_modified %in% tree$tip.label & !is.na(edge_data_03$weighted_protection)]
  ))
  
  # Filter and arrange all datasets
  matched_data <- data %>%
    filter(species_modified %in% common_species) %>%
    arrange(match(species_modified, common_species))
  
  matched_data_01 <- edge_data_01 %>%
    filter(species_modified %in% common_species) %>%
    arrange(match(species_modified, common_species))
  
  matched_data_03 <- edge_data_03 %>%
    filter(species_modified %in% common_species) %>%
    arrange(match(species_modified, common_species))
  
  # Create a dataframe for MPA percentages
  mpa_data <- matched_data %>%
    select(species_modified, percentage_in_NT_MPA, percentage_in_ALL_MPA) %>%
    mutate(
      percentage_in_NT_MPA = as.numeric(percentage_in_NT_MPA),
      percentage_in_ALL_MPA = as.numeric(percentage_in_ALL_MPA)
    )
  
  # Create a separate dataframe for EDGE weighted protection, 
  # converting from proportion (0-1) to percentage (0-100)
  edge_data <- data.frame(
    species_modified = matched_data_01$species_modified,
    weighted_protection_01 = matched_data_01$weighted_protection * 100,  # Convert to percentage
    weighted_protection_03 = matched_data_03$weighted_protection * 100   # Convert to percentage
  )
  
  # Set row names manually and create matrices
  mpa_matrix <- as.matrix(mpa_data[, -1])
  rownames(mpa_matrix) <- mpa_data$species_modified
  
  edge_matrix <- as.matrix(edge_data[, -1]) 
  rownames(edge_matrix) <- edge_data$species_modified
  
  # Combine into one matrix with desired ring order
  combined_matrix <- cbind(
    "NTake MPA" = mpa_matrix[, "percentage_in_NT_MPA"],
    "All MPA" = mpa_matrix[, "percentage_in_ALL_MPA"],
    "EDGE 01" = edge_matrix[, "weighted_protection_01"],
    "EDGE 03" = edge_matrix[, "weighted_protection_03"]
  )
  
  # Prune the tree to match the available data
  pruned_tree <- ape::keep.tip(tree, rownames(combined_matrix))
  
  # Create color palette
  n_colors <- 100
  color_palette <- get_color_palette(n_colors)
  
  # Base circular tree plot with light grey for tree lines
  p <- ggtree(pruned_tree, layout="circular", size=0.3, color="lightgrey")
  
  # Add heatmap rings without column names
  p <- gheatmap(p, combined_matrix, 
                width=0.4,  # Wider to accommodate 4 rings
                offset=0.1, 
                colnames=FALSE,
                font.size=3) + 
    scale_fill_gradientn(
      colours=color_palette, 
      name="Range protected (%)",  # Updated legend title
      limits=c(0, 100),
      na.value="grey80",
      oob=scales::squish
    )
  
  # Keep clean layout
  p <- p + theme(
    plot.margin = margin(t=10, r=10, b=10, l=10, unit="pt")
  )
  
  return(p)
}

combined_tree_plot <- plot_combined_circular_tree(
  list_tree_sharks_p[[1]], 
  results_IUCN_filtered,
  combined_protection_EDGE_01,
  combined_protection_EDGE_03
)

# Display the plot
combined_tree_plot

# Save the plot as PNG
ggsave(
  here::here("combined_tree_plot_heatmap.png"),  # Filename (include path if needed)
  plot = combined_tree_plot,
  width = 10,                # Width in inches
  height = 10,               # Height in inches
  dpi = 300                  # Resolution (dots per inch)
)
```

# Relate to FUSE and EDGE2

Relate the percentage of species range overlapped by MPAs to FUSE and EDGE2

```{r}
library(jsonlite)
library(here)
library(ggplot2)
library(dplyr)
library(purrr)
library(patchwork)
library(knitr)
library(kableExtra)

# Read the JSON file
data <- fromJSON(here("Data", "shark_conservation_metrics_no_freshwater.json"))

# Function to process data and create plot
process_and_plot <- function(metric_name) {
  # Merge and process data
  combined_data <- data[[metric_name]]$info %>%
    left_join(results_coords, by = "Species") %>%
    mutate(across(where(is.list), unlist),
           across(where(is.character), as.factor),
           !!metric_name := pmin(pmax(!!sym(metric_name), 0), 1))
  
  # Create plot
  plot <- ggplot(combined_data, aes_string(x = metric_name, y = "percentage_in_ALL_MPA")) +
    geom_point(alpha = 0.6) +
    geom_smooth(method = "lm", color = "red", se = TRUE) +
    theme_minimal() +
    labs(title = paste(metric_name, "vs % Range Protected"),
         x = metric_name,
         y = "% Range Protected") +
    scale_x_continuous(limits = c(0, 1), breaks = seq(0, 1, 0.2)) +
    scale_y_continuous(limits = c(0, 100), breaks = seq(0, 100, 20)) +
    theme(aspect.ratio = 1)
  
  # Calculate correlation
  cor_test <- cor.test(combined_data[[metric_name]], combined_data$percentage_in_ALL_MPA, use = "complete.obs")
  
  return(list(plot = plot, cor_test = cor_test))
}

# Process and plot for EDGE2 and FUSE
edge2_results <- process_and_plot("EDGE2") 
fuse_results <- process_and_plot("FUSE") 

# Combine plots in a grid with 2 columns
combined_plot <- edge2_results$plot + fuse_results$plot +
  plot_layout(ncol = 2) +
  plot_annotation(
    title = NULL,
    theme = theme(plot.title = element_text(hjust = 0.5, size = 16))
  )

# Print the combined plot
print(combined_plot)

# Create a data frame with correlation test results
correlation_results <- data.frame(
  Metric = c("EDGE2", "FUSE"),
  Correlation = c(edge2_results$cor_test$estimate, fuse_results$cor_test$estimate),
  P_value = c(edge2_results$cor_test$p.value, fuse_results$cor_test$p.value)
)

# Create and print the kable table
kable_table <- kable(correlation_results, 
                     col.names = c("Metric", "Correlation", "P-value"),
                     digits = c(0, 3, 4),
                     caption = "Correlation Test Results") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
                full_width = FALSE)

kable_table
```

**Key message:** There is significant negative relationship between EDGE2 and FUSE with the % of range protected. Species with high FUSE or high EDGE2 tend to be less protected than those with low EDGE2 or FUSE.
