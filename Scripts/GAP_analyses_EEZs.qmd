---
title: "GAP analyses"
author: "Th√©ophile L. Mouton"
date: "October 9, 2024"
format:
  html:
    toc: true
    toc-location: right
    css: custom.css
    output-file: "GAP_analyses_EEZs.html"
    self-contained: true
    code-fold: true
    code-tools: true
editor: visual
execute:
  warning: false
  message: false
  echo: true
---

# Load the data

Load the grid and the MPA raster layers

```{r}
# Load necessary libraries
library(raster)
library(here)
library(sp)
library(dplyr)
library(tidyr)

# Load the data ----
load(here::here("Data", "GAP analyses", "puvsp_marine.Rdata"))

# Load the raster layers
mpa_ALL <- raster::raster(here::here("Data", "GAP analyses", "mpa_ALL_binary.tif"))
mpa_NT <- raster::raster(here::here("Data", "GAP analyses", "mpa_NT_binary.tif"))

```

# GAP analyses

GAP analyses of shark and ray range overlaps with Marine Protected Areas

```{r}
# Convert species dataframe to spatial points
species_points <- SpatialPointsDataFrame(coords = puvsp_marine[, c("lon", "lat")], 
                                         data = puvsp_marine, 
                                         proj4string = CRS(projection(mpa_ALL)))

# Extract MPA values for each species point
mpa_ALL_values <- raster::extract(mpa_ALL, species_points)
mpa_NT_values <- raster::extract(mpa_NT, species_points)

# Add MPA values to the species dataframe
puvsp_marine$mpa_ALL_present <- mpa_ALL_values
puvsp_marine$mpa_NT_present <- mpa_NT_values

# Function to calculate percentage of range in MPA
calculate_mpa_percentage <- function(species_column, mpa_column) {
  species_presence <- species_column == 1  # Assuming 1 indicates species presence
  total_range <- sum(species_presence, na.rm = TRUE)
  range_in_mpa <- sum(species_presence & mpa_column == 1, na.rm = TRUE)
  
  if (total_range == 0) {
    return(NA)  # Return NA if the species is not present anywhere
  }
  
  percentage <- (range_in_mpa / total_range) * 100
  return(percentage)
}

# Apply function to all species columns for both MPA types
species_columns <- 4:(ncol(puvsp_marine) - 2)  # Assuming species columns start at 4
mpa_ALL_percentages <- sapply(puvsp_marine[, species_columns], 
                              function(x) calculate_mpa_percentage(x, puvsp_marine$mpa_ALL_present))
mpa_NT_percentages <- sapply(puvsp_marine[, species_columns], 
                             function(x) calculate_mpa_percentage(x, puvsp_marine$mpa_NT_present))

# Create a dataframe with results
results <- data.frame(
  species = names(mpa_ALL_percentages),
  percentage_in_ALL_MPA = mpa_ALL_percentages,
  percentage_in_NT_MPA = mpa_NT_percentages
)

# Remove any NA results
results <- results[!is.na(results$percentage_in_ALL_MPA) & !is.na(results$percentage_in_NT_MPA), ]

# Sort results by percentage in ALL MPAs (descending)
results <- results[order(-results$percentage_in_ALL_MPA), ]

# Display top 10 species
#print(head(results, 10))

# Summary statistics
cat("\nSummary Statistics for ALL MPAs:\n")
print(summary(results$percentage_in_ALL_MPA))
print(sd(results$percentage_in_ALL_MPA))

cat("\nSummary Statistics for No-Take MPAs:\n")
print(summary(results$percentage_in_NT_MPA))
print(sd(results$percentage_in_NT_MPA))

# Save results to CSV
write.csv(results, here::here("Data","species_mpa_coverage_ALL_and_NT.csv"), row.names = FALSE)
```

# Null model of MPA placement within EEZs

Null model of MPA placement and overlaps with the range of sharks and rays

```{r}
library(raster)
library(here)
library(sp)
library(sf)
library(parallel)
library(pbapply)

# Load the bathymetry raster
Bathy <- raster(here::here("Data", "bathymetry-0.1deg-adjusted.tif"))

# Create marine mask from bathymetry (areas < 0)
marine_mask <- Bathy < 0

# Resample marine mask to match MPA raster resolution
marine_mask_resampled <- raster::resample(marine_mask, mpa_ALL, method = "ngb")

# Ensure marine_mask_resampled is binary (0 or 1)
marine_mask_resampled <- raster::reclassify(marine_mask_resampled, c(-Inf, 0.5, 0, 0.5, Inf, 1))

# Load the EEZ shapefile
eez <- st_read(here("Data", "World_EEZ_v12_20231025", "eez_v12.shp"), quiet = TRUE)

# Function to create a raster mask of EEZs with unique values for each country
create_eez_mask <- function(template_raster) {
  # Ensure EEZ has a unique identifier for each country
  eez$country_id <- as.numeric(as.factor(eez$SOVEREIGN1))
  
  # Rasterize the EEZ shapefile using the country_id
  eez_raster <- rasterize(eez, template_raster, field = "country_id")
  
  return(eez_raster)
}

# Updated create_random_mpa function to randomize within each country's EEZ
create_random_mpa <- function(template_raster, marine_mask, eez_mask) {
  # Ensure template_raster is binary
  template_raster <- raster::reclassify(template_raster, c(-Inf, 0.5, 0, 0.5, Inf, 1))
  
  # Combine marine_mask and eez_mask
  combined_mask <- marine_mask * (eez_mask > 0)
  
  # Get unique country IDs
  country_ids <- unique(eez_mask[!is.na(eez_mask)])
  country_ids <- country_ids[country_ids > 0]
  
  # Initialize random raster
  random_raster <- template_raster
  random_raster[] <- NA
  
  for (country_id in country_ids) {
    # Create mask for current country
    country_mask <- eez_mask == country_id
    
    # Count original marine MPA cells within current country's EEZ
    original_mpa_cells <- sum(template_raster[] == 1 & country_mask[] & !is.na(combined_mask[]), na.rm = TRUE)
    
    # Get all valid cells for current country (marine areas within EEZ)
    valid_cells <- which(country_mask[] & !is.na(combined_mask[]))
    total_valid_cells <- length(valid_cells)
    
    if (original_mpa_cells > 0 && total_valid_cells > 0) {
      if (original_mpa_cells > total_valid_cells) {
        warning(paste("More MPA cells than valid marine cells for country ID", country_id, ". Adjusting MPA cell count."))
        original_mpa_cells <- total_valid_cells
      }
      
      # Randomly select valid cells to be MPAs for current country
      mpa_cells <- sample(valid_cells, size = min(original_mpa_cells, total_valid_cells), replace = FALSE)
      
      # Update random raster
      random_raster[valid_cells] <- 0
      random_raster[mpa_cells] <- 1
    }
  }
  
  return(random_raster)
}

# Calculate MPA percentage function
calculate_mpa_percentage <- function(species_values, mpa_values) {
  total_cells <- sum(!is.na(species_values))
  mpa_cells <- sum(mpa_values == 1 & !is.na(species_values), na.rm = TRUE)
  percentage <- (mpa_cells / total_cells) * 100
  return(percentage)
}

# Main analysis function
run_random_mpa_analysis <- function(species_data, mpa_raster, marine_mask, eez_mask, n_iterations = 100) {
  # Convert species dataframe to spatial points
  species_points <- sp::SpatialPointsDataFrame(coords = species_data[, c("lon", "lat")], 
                                               data = species_data, 
                                               proj4string = sp::CRS(raster::projection(mpa_raster)))
  
  # Prepare results storage
  species_columns <- 4:(ncol(species_data) - 1)  # Adjust if needed
  all_results <- matrix(nrow = length(species_columns), ncol = n_iterations)
  rownames(all_results) <- names(species_data)[species_columns]
  
  # Use pblapply for parallel processing with a progress bar
  all_results <- pblapply(1:n_iterations, function(i) {
    set.seed(i)  # Set seed for reproducibility
    random_mpa <- create_random_mpa(mpa_raster, marine_mask, eez_mask)
    random_mpa_values <- raster::extract(random_mpa, species_points)
    sapply(species_data[, species_columns], 
           function(x) calculate_mpa_percentage(x, random_mpa_values))
  }, cl = detectCores() - 1)  # Use one less than available cores
  
  all_results <- do.call(cbind, all_results)
  
  # Calculate mean and standard deviation for each species
  mean_percentages <- rowMeans(all_results, na.rm = TRUE)
  sd_percentages <- apply(all_results, 1, sd, na.rm = TRUE)
  
  results <- data.frame(
    species = rownames(all_results),
    mean_percentage = mean_percentages,
    sd_percentage = sd_percentages
  )
  
  return(results)
}

# Function to process results
process_results <- function(results, mpa_type) {
  # Sort results by mean_percentage in descending order
  results <- results[order(-results$mean_percentage), ]
  
  # Calculate summary statistics
  summary_stats <- summary(results$mean_percentage)
  
  # Write results to CSV
  write.csv(results, here::here("Outputs",paste0("species_random_", mpa_type, "_coverage.csv")), row.names = FALSE)
  
  # Return a list containing the processed data
  return(list(
    top_10 = head(results, 10),
    summary_stats = summary_stats,
    all_results = results
  ))
}

# Create the EEZ mask with unique country IDs
eez_mask <- create_eez_mask(mpa_ALL)

# Run the analysis with the country-specific EEZ constraint
tryCatch({
  random_results_ALL <- run_random_mpa_analysis(puvsp_marine, mpa_ALL, marine_mask_resampled, eez_mask, n_iterations = 100)
  print("Analysis for ALL MPAs completed successfully.")
}, error = function(e) {
  print(paste("Error in ALL MPAs analysis:", e$message))
})

tryCatch({
  random_results_NT <- run_random_mpa_analysis(puvsp_marine, mpa_NT, marine_mask_resampled, eez_mask, n_iterations = 100)
  print("Analysis for No-Take MPAs completed successfully.")
}, error = function(e) {
  print(paste("Error in No-Take MPAs analysis:", e$message))
})

# Process results for both MPA types
processed_results <- list()

if (exists("random_results_ALL")) {
  processed_results[["ALL MPAs"]] <- process_results(random_results_ALL, "ALL MPAs")
}

if (exists("random_results_NT")) {
  processed_results[["No-take MPAs"]] <- process_results(random_results_NT, "No-take MPAs")
}
```

**Important note:** This NULL model randomly distributes protected grid cells at a 0.5-degree resolution within country's EEZs. However, it does not preserve MPA shape.

# Compare results

Compare results between the MPA network and the Null model of MPA placement

```{r}
# Compare results ---- 
library(dplyr)
library(tidyr)
library(ggplot2)

# Load actual MPA coverage data
actual_coverage <- read.csv(here::here("Outputs", "species_mpa_coverage_ALL_and_NT.csv"))
colnames(actual_coverage)[2:3]=c("ALL","NT")

# Load random MPA coverage results
random_ALL <- read.csv(here::here("Outputs", "species_random_ALL MPAs_coverage.csv"))
random_NT <- read.csv(here::here("Outputs", "species_random_No-take MPAs_coverage.csv"))

# Reshape actual coverage data to long format
actual_long <- actual_coverage %>%
  pivot_longer(cols = c(ALL, NT), 
               names_to = "mpa_type", 
               values_to = "actual_percentage")

# Function to merge and compare actual vs random data
compare_coverage <- function(actual_data, random_data, mpa_type) {
  comparison <- actual_data %>%
    filter(mpa_type == !!mpa_type) %>%
    left_join(random_data, by = "species") %>%
    mutate(difference = actual_percentage - mean_percentage,
           z_score = (actual_percentage - mean_percentage) / sd_percentage)
  return(comparison)
}

# Create comparison dataframes
comparison_ALL <- compare_coverage(actual_long, random_ALL, "ALL")
comparison_NT <- compare_coverage(actual_long, random_NT, "NT")

# Function to summarize and print results
library(knitr)
library(kableExtra)

summarize_results <- function(comparison_data, mpa_type) {
  over_represented <- mean(comparison_data$difference > 0, na.rm=TRUE) * 100
  under_represented <- mean(comparison_data$difference < 0, na.rm=TRUE) * 100
  equally_represented <- 100 - over_represented - under_represented
  
  summary_df <- data.frame(
    Representation = c("Over-represented", "Under-represented", "Equally represented"),
    Percentage = round(c(over_represented, under_represented, equally_represented), 2)
  )
  
  kable(summary_df, format = "html", col.names = c("Representation", "Percentage (%)"),
        caption = paste("Summary for", mpa_type, "MPAs")) %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"),
                  full_width = FALSE) %>%
    column_spec(2, width = "100px") %>%
    row_spec(0, bold = TRUE) %>%
    add_header_above(c(" " = 1, "Species" = 1)) %>%
    footnote(general = "Percentages may not sum to 100% due to rounding.")
}

# Summarize results
summarize_results(comparison_ALL, "ALL")
summarize_results(comparison_NT, "No-Take")

# Identify significantly over/under-represented species
library(dplyr)

significant_species <- function(comparison_data, mpa_type, z_threshold = 1.96) {
  over_represented <- comparison_data %>% 
    filter(z_score > z_threshold) %>% 
    arrange(desc(z_score))
  
  under_represented <- comparison_data %>% 
    filter(z_score < -z_threshold) %>% 
    arrange(z_score)
  
  top_5_over <- over_represented %>% 
    dplyr::select(species, actual_percentage, mean_percentage, difference, z_score) %>% 
    head(5)
  
  top_5_under <- under_represented %>% 
    dplyr::select(species, actual_percentage, mean_percentage, difference, z_score) %>% 
    head(5)
  
  combined_table <- bind_rows(
    mutate(top_5_over, representation = "Over-represented"),
    mutate(top_5_under, representation = "Under-represented")
  ) %>%
    mutate(across(where(is.numeric), ~round(., 2)))
  
  kable_output <- kable(combined_table, format = "html", 
        col.names = c("Species", "Actual %", "Random %", "Difference", "Z-score", "Representation"),
        caption = paste("Top 5 Significantly Over/Under-represented Species in", mpa_type, "MPAs")) %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"),
                  full_width = FALSE) %>%
    column_spec(1, width = "200px") %>%
    column_spec(2:5, width = "100px") %>%
    column_spec(6, width = "150px") %>%
    row_spec(0, bold = TRUE) %>%
    pack_rows("Over-represented", 1, 5, label_row_css = "background-color: #e6f3ff; color: #000;") %>%
    pack_rows("Under-represented", 6, 10, label_row_css = "background-color: #fff0e6; color: #000;")
  
  footnote_text <- paste(
    "Total significantly over-represented species:", nrow(over_represented), "\n",
    "Total significantly under-represented species:", nrow(under_represented)
  )
  
  kable_output %>%
    footnote(general = footnote_text, general_title = "Note:")
}

# Identify significant species
significant_species(comparison_ALL, "ALL")
significant_species(comparison_NT, "No-Take")
```

**Key message:** \>60% of species are under-represented by the global MPA network (i.e. less protected by the current MPA network than by a random placement of MPAs).

# Breakdown of under-represented species 

```{r}
# Identify under-represented species (where actual coverage is less than random)
under_represented_ALL <- comparison_ALL %>% 
  filter(difference < 0) %>% 
  arrange(difference) %>%
  dplyr::select(species, actual_percentage, mean_percentage, difference, z_score)

under_represented_NT <- comparison_NT %>% 
  filter(difference < 0) %>% 
  arrange(difference) %>%
  dplyr::select(species, actual_percentage, mean_percentage, difference, z_score)

# Count the number of under-represented species
n_under_ALL <- nrow(under_represented_ALL)
n_under_NT <- nrow(under_represented_NT)

# Print the counts and percentages
cat(paste("Under-represented species in ALL MPAs:", n_under_ALL, 
          "(", round(n_under_ALL/nrow(comparison_ALL)*100, 1), "% of all species)\n"))
cat(paste("Under-represented species in No-take MPAs:", n_under_NT, 
          "(", round(n_under_NT/nrow(comparison_NT)*100, 1), "% of all species)\n"))

# Find species that are under-represented in both MPA types
under_represented_both <- inner_join(
  under_represented_ALL %>% dplyr::select(species),
  under_represented_NT %>% dplyr::select(species),
  by = "species"
)

n_under_both <- nrow(under_represented_both)
cat(paste("Species under-represented in both ALL and No-take MPAs:", n_under_both, "\n"))

# Save the lists of under-represented species to CSV files
write.csv(under_represented_ALL, here::here("Outputs", "under_represented_species_ALL_MPAs.csv"), row.names = FALSE)
write.csv(under_represented_NT, here::here("Outputs", "under_represented_species_NT_MPAs.csv"), row.names = FALSE)
write.csv(under_represented_both, here::here("Outputs", "under_represented_species_BOTH_MPAs.csv"), row.names = FALSE)

# Create summary data frames with additional information
under_rep_ALL_summary <- under_represented_ALL %>%
  mutate(protection_gap = mean_percentage - actual_percentage,
         representation_ratio = actual_percentage / mean_percentage) %>%
  arrange(desc(protection_gap))

under_rep_NT_summary <- under_represented_NT %>%
  mutate(protection_gap = mean_percentage - actual_percentage,
         representation_ratio = actual_percentage / mean_percentage) %>%
  arrange(desc(protection_gap))

# Save the enhanced summary data
write.csv(under_rep_ALL_summary, here::here("Outputs", "under_represented_species_ALL_MPAs_summary.csv"), row.names = FALSE)
write.csv(under_rep_NT_summary, here::here("Outputs", "under_represented_species_NT_MPAs_summary.csv"), row.names = FALSE)

# Create a Venn diagram to visualize the overlap
library(ggVennDiagram)
library(ggplot2)

species_sets <- list(
  "All MPAs" = under_represented_ALL$species,
  "No-take MPAs" = under_represented_NT$species
)

venn_plot <- ggVennDiagram(species_sets, 
                          category.names = c("All MPAs", "No-take MPAs"),
                          label = "count") +
  scale_fill_gradient(low = "white", high = "steelblue") +
  labs(title = "Overlap of Under-represented Species",
       subtitle = paste("All MPAs:", n_under_ALL, "species |",
                       "No-take MPAs:", n_under_NT, "species |",
                       "Both:", n_under_both, "species"),
       fill = "Count") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"),
        plot.subtitle = element_text(hjust = 0.5))

# Display the Venn diagram
print(venn_plot)

# Optional: Save the Venn diagram
ggsave(here::here("Outputs", "under_represented_species_venn.png"), 
       venn_plot, width = 8, height = 6, dpi = 300)

## Compare with IUCN data 
# Define the function to prepare IUCN data
prepare_iucn_data <- function(species_data, species_col) {
  IUCN <- readRDS(here::here("Data","GAP analyses","sharks_iucn_final.RDS"))
  IUCN$species <- gsub("_", " ", IUCN$Species)
  
  # Rename the species column in the input data to match
  species_data_renamed <- species_data %>%
    dplyr::rename(species = all_of(species_col))
  
  # Ensure we're only joining based on the species name
  species_data_slim <- species_data_renamed %>%
    dplyr::select(species)
  
  results_IUCN <- inner_join(IUCN, species_data_slim, by="species") %>%
    mutate(IUCN_status = case_when(
      iucn_GE == 0 ~ "LC",
      iucn_GE == 1 ~ "NT",
      iucn_GE == 2 ~ "VU",
      iucn_GE == 3 ~ "EN",
      iucn_GE == 4 ~ "CR",
      TRUE ~ "Unknown"
    )) %>%
    filter(IUCN_status != "Unknown")
  
  return(results_IUCN)
}

# Get species lists for each category
all_species <- actual_coverage %>% dplyr::select(species)
under_rep_ALL_species <- under_represented_ALL %>% dplyr::select(species)
under_rep_NT_species <- under_represented_NT %>% dplyr::select(species)

# Use the prepare_iucn_data function to get IUCN statuses for each group separately
all_species_iucn <- prepare_iucn_data(all_species, "species")
under_rep_ALL_iucn <- prepare_iucn_data(under_rep_ALL_species, "species")
under_rep_NT_iucn <- prepare_iucn_data(under_rep_NT_species, "species")

# Print count of species with IUCN data in each group
cat("Total species with IUCN data:", nrow(all_species_iucn), "\n")
cat("Under-represented ALL MPAs species with IUCN data:", nrow(under_rep_ALL_iucn), "\n")
cat("Under-represented No-take MPAs species with IUCN data:", nrow(under_rep_NT_iucn), "\n")

# Function to summarize IUCN status distribution
summarize_iucn <- function(data, title) {
  # Count species by IUCN status
  iucn_counts <- data %>%
    group_by(IUCN_status) %>%
    summarise(
      count = n(),
      .groups = "drop"
    ) %>%
    mutate(
      percentage = count / sum(count) * 100,
      title = title
    )
  
  # Order IUCN statuses correctly
  iucn_counts$IUCN_status <- factor(iucn_counts$IUCN_status, 
                                    levels = c("LC", "NT", "VU", "EN", "CR"))
  
  return(iucn_counts)
}

# Get IUCN summaries for each dataset
all_iucn_summary <- summarize_iucn(all_species_iucn, "All Species")
under_ALL_iucn_summary <- summarize_iucn(under_rep_ALL_iucn, "Under-represented (All MPAs)")
under_NT_iucn_summary <- summarize_iucn(under_rep_NT_iucn, "Under-represented (No-take MPAs)")

# Print summaries to check
print(all_iucn_summary)
print(under_ALL_iucn_summary)
print(under_NT_iucn_summary)

# Combine all summaries
combined_iucn_summary <- bind_rows(
  all_iucn_summary,
  under_ALL_iucn_summary,
  under_NT_iucn_summary
)

# Create a bar plot comparing IUCN distributions
iucn_plot <- ggplot(combined_iucn_summary, aes(x = IUCN_status, y = percentage, fill = title)) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_text(aes(label = paste0(round(percentage, 1), "%")), 
            position = position_dodge(width = 0.9), 
            vjust = -0.5, 
            size = 3) +
  scale_fill_manual(values = c("All Species" = "grey70", 
                               "Under-represented (All MPAs)" = "steelblue", 
                               "Under-represented (No-take MPAs)" = "darkred")) +
  labs(
    title = "IUCN Status Distribution Comparison",
    subtitle = "All Species vs. Under-represented Species",
    x = "IUCN Red List Status",
    y = "Percentage of Species",
    fill = ""
  ) +
  theme_classic() +  # Using theme_classic() for a white background with minimal elements
  theme(
    legend.position = "bottom",
    panel.background = element_rect(fill = "white", color = NA),  # Ensure white background
    plot.background = element_rect(fill = "white", color = NA),   # White background for the entire plot
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5)
  )

# Display the plot
print(iucn_plot)

# Save the plot
ggsave(here::here("Outputs", "under_represented_species_iucn_comparison.png"), 
       iucn_plot, width = 10, height = 6, dpi = 300)

# For no-take MPAs only 
library(ggplot2)

# Filter out the "Under-represented (All MPAs)" category from the dataset
filtered_data <- combined_iucn_summary %>%
  dplyr::filter(title != "Under-represented (All MPAs)")

# Create a bar plot comparing IUCN distributions (excluding "Under-represented (All MPAs)")
iucn_plot_NT <- ggplot(filtered_data, aes(x = IUCN_status, y = percentage, fill = title)) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_text(aes(label = paste0(round(percentage, 1), "%")), 
            position = position_dodge(width = 0.9), 
            vjust = -0.5, 
            size = 3) +
  scale_fill_manual(values = c("All Species" = "grey70", 
                               "Under-represented (No-take MPAs)" = "darkred")) +
  labs(
    title = "IUCN Status Distribution Comparison",
    subtitle = "All Species vs. Under-represented (No-take MPAs)",
    x = "IUCN Red List Status",
    y = "Percentage of Species",
    fill = ""
  ) +
  theme_classic() +  # Using theme_classic() for a white background with minimal elements
  theme(
    legend.position = "bottom",
    panel.background = element_rect(fill = "white", color = NA),  # Ensure white background
    plot.background = element_rect(fill = "white", color = NA),   # White background for the entire plot
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5)
  )

# Print the plot
print(iucn_plot_NT)

# Save the plot
ggsave(here::here("Outputs", "under_represented_species_iucn_comparison_NT_only.png"), 
       iucn_plot_NT, width = 10, height = 6, dpi = 300)

# Statistical test: Chi-square test to determine if there are significant differences
# in IUCN status distribution between all species and under-represented species

# Prepare contingency tables
prepare_contingency <- function(summary_df1, summary_df2) {
  # Ensure all IUCN categories are present in both datasets
  all_categories <- c("LC", "NT", "VU", "EN", "CR")
  
  # Fill in missing categories with zero
  for (cat in all_categories) {
    if (!cat %in% summary_df1$IUCN_status) {
      summary_df1 <- bind_rows(summary_df1, 
                              data.frame(IUCN_status = cat, count = 0, 
                                         percentage = 0, title = unique(summary_df1$title)))
    }
    if (!cat %in% summary_df2$IUCN_status) {
      summary_df2 <- bind_rows(summary_df2, 
                              data.frame(IUCN_status = cat, count = 0, 
                                         percentage = 0, title = unique(summary_df2$title)))
    }
  }
  
  # Order and extract counts
  df1_ordered <- summary_df1 %>%
    arrange(factor(IUCN_status, levels = all_categories)) %>%
    pull(count)
  
  df2_ordered <- summary_df2 %>%
    arrange(factor(IUCN_status, levels = all_categories)) %>%
    pull(count)
  
  # Create contingency table
  return(rbind(df1_ordered, df2_ordered))
}

# Perform chi-square tests
contingency_ALL <- prepare_contingency(all_iucn_summary, under_ALL_iucn_summary)
rownames(contingency_ALL) <- c("All Species", "Under-represented (All MPAs)")
colnames(contingency_ALL) <- c("LC", "NT", "VU", "EN", "CR")

contingency_NT <- prepare_contingency(all_iucn_summary, under_NT_iucn_summary)
rownames(contingency_NT) <- c("All Species", "Under-represented (No-take MPAs)")
colnames(contingency_NT) <- c("LC", "NT", "VU", "EN", "CR")

# Print contingency tables
cat("Contingency Table - All MPAs:\n")
print(contingency_ALL)
cat("\n")

cat("Contingency Table - No-take MPAs:\n")
print(contingency_NT)
cat("\n")

# Run chi-square tests
chi_test_ALL <- chisq.test(contingency_ALL)
chi_test_NT <- chisq.test(contingency_NT)

# Print results
cat("Chi-square Test - All MPAs vs. All Species:\n")
print(chi_test_ALL)
cat("\n")

cat("Chi-square Test - No-take MPAs vs. All Species:\n")
print(chi_test_NT)
cat("\n")

# Now join the under-represented species with their actual protection data
under_rep_ALL_full <- under_rep_ALL_iucn %>%
  left_join(under_represented_ALL, by = "species")

under_rep_NT_full <- under_rep_NT_iucn %>%
  left_join(under_represented_NT, by = "species")

# Calculate protection gaps by IUCN status
iucn_protection_gap_ALL <- under_rep_ALL_full %>%
  group_by(IUCN_status) %>%
  summarise(
    mean_protection_gap = mean(mean_percentage - actual_percentage, na.rm = TRUE),
    mean_actual_coverage = mean(actual_percentage, na.rm = TRUE),
    mean_expected_coverage = mean(mean_percentage, na.rm = TRUE),
    n_species = n(),
    .groups = "drop"
  ) %>%
  mutate(MPA_Type = "All MPAs")

iucn_protection_gap_NT <- under_rep_NT_full %>%
  group_by(IUCN_status) %>%
  summarise(
    mean_protection_gap = mean(mean_percentage - actual_percentage, na.rm = TRUE),
    mean_actual_coverage = mean(actual_percentage, na.rm = TRUE),
    mean_expected_coverage = mean(mean_percentage, na.rm = TRUE),
    n_species = n(),
    .groups = "drop"
  ) %>%
  mutate(MPA_Type = "No-take MPAs")

# Combine the protection gap data
combined_protection_gap <- bind_rows(iucn_protection_gap_ALL, iucn_protection_gap_NT)

# Ensure consistent IUCN status ordering before plotting
combined_protection_gap$IUCN_status <- factor(combined_protection_gap$IUCN_status, 
                                             levels = c("LC", "NT", "VU", "EN", "CR"),
                                             ordered = TRUE)

# Create a plot showing mean protection gap by IUCN status
protection_gap_plot <- ggplot(combined_protection_gap, 
                             aes(x = IUCN_status, y = mean_protection_gap, fill = MPA_Type)) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_text(aes(label = paste0(round(mean_protection_gap, 1), "%")),
            position = position_dodge(width = 0.9),
            vjust = -0.5,
            size = 3) +
  scale_fill_manual(values = c("All MPAs" = "steelblue", "No-take MPAs" = "darkred")) +
  labs(
    title = "Mean Protection Gap by IUCN Status",
    subtitle = "For Under-represented Species",
    x = "IUCN Red List Status",
    y = "Mean Protection Gap (%)",
    fill = ""
  ) +
  theme_classic() +  # Using theme_classic() for a white background
  theme(
    legend.position = "bottom",
    panel.background = element_rect(fill = "white", color = NA),
    plot.background = element_rect(fill = "white", color = NA),
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5)
  )

# Display the plot
print(protection_gap_plot)

# Save the plot
ggsave(here::here("Outputs", "under_represented_species_protection_gap_by_iucn.png"), 
       protection_gap_plot, width = 10, height = 6, dpi = 300)

# Create a summary table with the IUCN distribution
iucn_summary_table <- combined_iucn_summary %>%
  pivot_wider(
    id_cols = IUCN_status,
    names_from = title,
    values_from = c(count, percentage)
  ) %>%
  arrange(factor(IUCN_status, levels = c("LC", "NT", "VU", "EN", "CR")))

# Save the summary tables
write.csv(iucn_summary_table, 
          here::here("Outputs", "under_represented_species_iucn_summary.csv"), 
          row.names = FALSE)

write.csv(combined_protection_gap, 
          here::here("Outputs", "under_represented_species_protection_gap_by_iucn.csv"), 
          row.names = FALSE)

```

Protection Gap Analysis by IUCN Status

The protection gap plot reveals important conservation biases related to shark species' threat levels.

What is the Protection Gap?

The protection gap represents how much less protection a species is receiving compared to what would be expected if protection was randomly distributed:

$$\text{Protection Gap} = \text{Expected Random Coverage} - \text{Actual Coverage}$$

This measures the "shortfall" in protection for each under-represented species, expressed as a percentage.

Interpretation of the Plot:

1. **X-axis**: IUCN Red List status categories (from least threatened "LC" to most threatened "CR")

2. **Y-axis**: Mean protection gap (%)

3. **Bar colors**: Comparing protection gaps between:
   - All MPAs (blue)
   - No-take MPAs (dark red)

4. **Key insights**:
   - Higher bars indicate larger protection gaps (greater under-representation)
   - The pattern across threat categories reveals whether more threatened species (VU, EN, CR) have larger or smaller protection gaps than less threatened species (LC, NT)

Significance for Conservation:

This analysis directly addresses whether threatened shark species are adequately represented in marine protected areas. If threatened species (VU, EN, CR) have larger protection gaps, it suggests a concerning bias where species that need protection most are receiving less than expected random coverage.

The comparison between All MPAs and No-take MPAs shows whether the highest level of protection (No-take) displays different biases than the broader set of protected areas.

# Map results of the GAP analyses

Map Standardised Effect Sizes of MPA coverage

```{r}
#For ALL MPAs 
difference_sp=comparison_ALL[,c(1,3,6)]

#Plot the difference 
# Load necessary libraries
library(dplyr)
library(tidyr)
library(ggplot2)

#SES:
# Step 1: Calculate SES for each species in comparison_ALL
comparison_ALL <- comparison_ALL %>%
  mutate(SES = (actual_percentage - mean_percentage) / sd_percentage)

# Assuming you have a similar species-to-grid-cell mapping like puvsp_marine
# Reshape puvsp_marine from wide to long format (if needed)
puvsp_long <- puvsp_marine %>%
  pivot_longer(cols = -c(id, lon, lat), names_to = "species", values_to = "presence") %>%
  filter(!is.na(presence) & presence == 1)  # Only keep rows where species is present

# Join SES data (comparison_ALL) to puvsp_long
combined_data <- puvsp_long %>%
  left_join(comparison_ALL, by = c("species" = "species"))

# Step 3: Group by grid cell (id, lon, lat) and calculate mean SES
mean_ses_per_cell <- combined_data %>%
  group_by(id, lon, lat) %>%
  summarise(mean_SES = mean(SES, na.rm = TRUE)) %>%
  ungroup()

# Load necessary libraries
library(ggplot2)
library(rnaturalearth)
library(sf)

# Step 1: Get land polygons from rnaturalearth
land <- ne_countries(scale = "medium", returnclass = "sf")

# Step 2: Plot the mean SES with a diverging color scale
g_ses_1 = ggplot() +
  geom_tile(data = mean_ses_per_cell, aes(x = lon, y = lat, fill = mean_SES)) +
  geom_sf(data = land, fill = "darkgrey", color = NA) +  # Add land in dark grey
  scale_fill_gradient2(
    low = "#2166ac", mid = "#f0f0f0", high = "#b2182b", midpoint = 0  # Blue-White-Red gradient, with midpoint at 0
  ) +
  coord_sf(xlim = c(-180, 180), ylim = c(-90, 90), expand = FALSE) +  # Set global coordinates
  theme_minimal() +
  theme(
    legend.position = "bottom",            # Position the legend at the bottom
    legend.title = element_text(hjust = 0.5),  # Center the legend title
    legend.key.width = unit(3, "cm"),      # Adjust width of the legend bar
    legend.key.height = unit(0.5, "cm")    # Adjust height of the legend bar
  ) +
  guides(
    fill = guide_colorbar(
      direction = "horizontal",            # Make the legend horizontal
      title.position = "top",              # Move the title to the top of the legend
      title.hjust = 0.5                    # Center the title horizontally
    )
  ) +
  labs(title = "Standardized Effect Size (SES) of Observed vs. Null MPA Coverage",
       x = "Longitude",
       y = "Latitude",
       fill = "Mean SES")
print(g_ses_1)

#For No-take MPAs 
difference_sp=comparison_NT[,c(1,3,6)]

#SES
# Step 1: Calculate SES for each species in comparison_ALL
comparison_NT <- comparison_NT %>%
  mutate(SES = (actual_percentage - mean_percentage) / sd_percentage)

# Assuming you have a similar species-to-grid-cell mapping like puvsp_marine
# Reshape puvsp_marine from wide to long format (if needed)
puvsp_long <- puvsp_marine %>%
  pivot_longer(cols = -c(id, lon, lat), names_to = "species", values_to = "presence") %>%
  filter(!is.na(presence) & presence == 1)  # Only keep rows where species is present

# Join SES data (comparison_ALL) to puvsp_long
combined_data <- puvsp_long %>%
  left_join(comparison_NT, by = c("species" = "species"))

# Step 3: Group by grid cell (id, lon, lat) and calculate mean SES
mean_ses_per_cell <- combined_data %>%
  group_by(id, lon, lat) %>%
  summarise(mean_SES = mean(SES, na.rm = TRUE)) %>%
  ungroup()

# Load necessary libraries
library(ggplot2)
library(rnaturalearth)
library(sf)

# Step 1: Get land polygons from rnaturalearth
land <- ne_countries(scale = "medium", returnclass = "sf")

# Step 2: Plot the mean SES with a diverging color scale
g_ses_2 = ggplot() +
  geom_tile(data = mean_ses_per_cell, aes(x = lon, y = lat, fill = mean_SES)) +
  geom_sf(data = land, fill = "darkgrey", color = NA) +  # Add land in dark grey
  scale_fill_gradient2(
    low = "#2166ac", mid = "#f0f0f0", high = "#b2182b", midpoint = 0  # Blue-White-Red gradient, with midpoint at 0
  ) +
  coord_sf(xlim = c(-180, 180), ylim = c(-90, 90), expand = FALSE) +  # Set global coordinates
  theme_minimal() +
  theme(
    legend.position = "bottom",            # Position the legend at the bottom
    legend.title = element_text(hjust = 0.5),  # Center the legend title
    legend.key.width = unit(3, "cm"),      # Adjust width of the legend bar
    legend.key.height = unit(0.5, "cm")    # Adjust height of the legend bar
  ) +
  guides(
    fill = guide_colorbar(
      direction = "horizontal",            # Make the legend horizontal
      title.position = "top",              # Move the title to the top of the legend
      title.hjust = 0.5                    # Center the title horizontally
    )
  ) +
  labs(title = "Standardized Effect Size (SES) of Observed vs. Null no-take MPA Coverage",
       x = "Longitude",
       y = "Latitude",
       fill = "Mean SES")
print(g_ses_2)

# Load the patchwork library for combining plots
library(patchwork)

# Combine the plots side by side
combined_plots <- g_ses_1 + g_ses_2

# Save the combined plot
# Adjust width and height as needed for your desired output
ggsave(here::here("SES_maps_comparison.png"), 
       combined_plots,
       width = 16,  # Width in inches
       height = 8,  # Height in inches
       dpi = 300)   # Resolution

```

**Key message:** Northern Pacific, Northern Atlantic, Southern Pacific, Southern Atlantic and global coastal/continental sharks and rays are less protected by MPAs than expected under a random placement of MPAs. This is even more the case for no-take MPAs.

# Maps for the manuscript

Map Standardised Effect Sizes of MPA coverage with Mcbryde Thomas 2 projection

```{r}
library(ggplot2)
library(dplyr)
library(sf)
library(rnaturalearth)
library(patchwork)
library(smoothr)

# Step 1: Calculate SES for each species in comparison_ALL
comparison_ALL <- comparison_ALL %>%
  mutate(SES = (actual_percentage - mean_percentage) / sd_percentage)

# Reshape puvsp_marine to long format
puvsp_long <- puvsp_marine %>%
  pivot_longer(cols = -c(id, lon, lat), names_to = "species", values_to = "presence") %>%
  filter(!is.na(presence) & presence == 1)

# Join SES data to puvsp_long
combined_data <- puvsp_long %>%
  left_join(comparison_ALL, by = c("species" = "species"))

# Calculate mean SES per cell
mean_ses_per_cell <- combined_data %>%
  group_by(id, lon, lat) %>%
  summarise(mean_SES = mean(SES, na.rm = TRUE)) %>%
  ungroup()

# Define the projection
mcbryde_thomas_2 <- "+proj=mbt_s"

# Convert data to sf object and project
mean_ses_per_cell_sf <- mean_ses_per_cell %>%
  st_as_sf(coords = c("lon", "lat"), crs = 4326) %>%
  st_transform(crs = mcbryde_thomas_2)

# Get and project land
land_projected <- ne_countries(scale = "medium", returnclass = "sf") %>%
  st_transform(crs = mcbryde_thomas_2)

# Create the globe border
globe_bbox <- rbind(c(-180, -90), c(-180, 90), 
                    c(180, 90), c(180, -90), c(-180, -90))

globe_border <- st_polygon(list(globe_bbox)) %>%
  st_sfc(crs = 4326) %>%
  st_sf(data.frame(rgn = 'globe', geom = .)) %>%
  smoothr::densify(max_distance = 0.5) %>%
  st_transform(crs = mcbryde_thomas_2)

# Create base theme
my_theme <- theme_minimal() +
  theme(
    legend.position = "bottom",
    legend.direction = "horizontal",
    legend.box = "vertical",
    legend.margin = margin(t = 20, r = 0, b = 0, l = 0),
    legend.title = element_text(margin = margin(b = 10)),
    panel.background = element_rect(fill = "white", color = NA),
    plot.background = element_rect(fill = "white", color = NA),
    panel.grid = element_blank()
  )

# Plot for All MPAs (now g_ses_2)
g_ses_2 = ggplot() +
  geom_sf(data = mean_ses_per_cell_sf, aes(color = mean_SES), size = 0.5, alpha = 0.7) +
  geom_sf(data = land_projected, fill = "lightgrey", color = "lightgrey", size = 0.1) +
  geom_sf(data = globe_border, fill = NA, color = "black", size = 0.5) +
  scale_color_gradient2(
    low = "#2166ac", mid = "#f0f0f0", high = "#b2182b", 
    midpoint = 0,
    name = "Mean SES",
    guide = guide_colorbar(barwidth = 20, barheight = 0.5, 
                         title.position = "top", title.hjust = 0.5)
  ) +
  coord_sf() +
  labs(x = NULL, y = NULL) +
  annotate("text", x = -Inf, y = Inf, label = "(B)", 
           hjust = -1, vjust = 2, size = 6, fontface = "bold") +
  my_theme

# Repeat process for No-take MPAs
comparison_NT <- comparison_NT %>%
  mutate(SES = (actual_percentage - mean_percentage) / sd_percentage)

combined_data_NT <- puvsp_long %>%
  left_join(comparison_NT, by = c("species" = "species"))

mean_ses_per_cell_NT <- combined_data_NT %>%
  group_by(id, lon, lat) %>%
  summarise(mean_SES = mean(SES, na.rm = TRUE)) %>%
  ungroup()

mean_ses_per_cell_sf_NT <- mean_ses_per_cell_NT %>%
  st_as_sf(coords = c("lon", "lat"), crs = 4326) %>%
  st_transform(crs = mcbryde_thomas_2)

# Plot for No-take MPAs (now g_ses_1)
g_ses_1 = ggplot() +
  geom_sf(data = mean_ses_per_cell_sf_NT, aes(color = mean_SES), size = 0.5, alpha = 0.7) +
  geom_sf(data = land_projected, fill = "lightgrey", color = "lightgrey", size = 0.1) +
  geom_sf(data = globe_border, fill = NA, color = "black", size = 0.5) +
  scale_color_gradient2(
    low = "#2166ac", mid = "#f0f0f0", high = "#b2182b", 
    midpoint = 0,
    name = "Mean SES",
    guide = guide_colorbar(barwidth = 20, barheight = 0.5, 
                         title.position = "top", title.hjust = 0.5)
  ) +
  coord_sf() +
  labs(x = NULL, y = NULL) +
  annotate("text", x = -Inf, y = Inf, label = "(A)", 
           hjust = -1, vjust = 2, size = 6, fontface = "bold") +
  my_theme

# Create layout matrix for two plots in a column
layout <- matrix(c(1, 2), ncol = 1)

# Combine plots using grid.arrange
combined_plot <- gridExtra::grid.arrange(
  g_ses_1,
  g_ses_2,
  layout_matrix = layout,
  heights = unit(c(6, 6), "inches")  # Equal height for both plots
)

# Save the combined plot
ggsave(here::here("SES_maps_comparison.png"), 
       combined_plot,
       width = 10,    # adjusted for single column
       height = 12,  # adjusted for two rows
       dpi = 300,
       bg = "white")
```

# GAP analyses maps, divide between continental waters and highseas 

```{r}
# GAP analyses maps: divide between continental waters and high seas using raster approach
library(ggplot2)
library(dplyr)
library(sf)
library(rnaturalearth)
library(patchwork)
library(smoothr)
library(terra)  # For raster operations

# Load high seas polygon data
High_seas = st_read(here::here("Data", "World_High_Seas_v2_20241010", "High_Seas_v2.shp"))

# Create template raster
template_raster <- rast(ext(High_seas), resolution = 0.5)

# Rasterize high seas polygon
highseas_raster <- rasterize(vect(High_seas), template_raster, field = 1, background = 0)

# Plot to verify
plot(highseas_raster, 
     main = "High Seas (1) vs Continental Waters (0)",
     col = c("lightblue", "darkblue"))

# Step 2: Calculate SES for each species in comparison_ALL
comparison_ALL <- comparison_ALL %>%
  mutate(SES = (actual_percentage - mean_percentage) / sd_percentage)

# Reshape puvsp_marine to long format
puvsp_long <- puvsp_marine %>%
  pivot_longer(cols = -c(id, lon, lat), names_to = "species", values_to = "presence") %>%
  filter(!is.na(presence) & presence == 1)

# Join SES data to puvsp_long
combined_data <- puvsp_long %>%
  left_join(comparison_ALL, by = c("species" = "species"))

# Calculate mean SES per cell
mean_ses_per_cell <- combined_data %>%
  group_by(id, lon, lat) %>%
  summarise(mean_SES = mean(SES, na.rm = TRUE)) %>%
  ungroup()

# Convert to terra SpatVector for extraction
ses_points <- vect(as.data.frame(mean_ses_per_cell), 
                   geom = c("lon", "lat"), 
                   crs = crs(highseas_raster))

# Extract values from highseas raster
highseas_values <- terra::extract(highseas_raster, ses_points)

# Add highseas classification back to the dataframe
mean_ses_per_cell$is_highseas <- highseas_values[, 2]
mean_ses_per_cell$is_highseas[is.na(mean_ses_per_cell$is_highseas)] <- 0  # Set NA to 0 (continental)

# Convert to sf objects for mapping
mean_ses_sf <- st_as_sf(mean_ses_per_cell, coords = c("lon", "lat"), crs = 4326)

# Split into high seas and continental waters
high_seas_points <- mean_ses_sf[mean_ses_sf$is_highseas == 1, ]
continental_points <- mean_ses_sf[mean_ses_sf$is_highseas == 0, ]

# Define the projection
mcbryde_thomas_2 <- "+proj=mbt_s"

# Project all datasets
high_seas_projected <- st_transform(high_seas_points, crs = mcbryde_thomas_2)
continental_projected <- st_transform(continental_points, crs = mcbryde_thomas_2)
land_projected <- ne_countries(scale = "medium", returnclass = "sf") %>%
  st_transform(crs = mcbryde_thomas_2)

# Create the globe border
globe_bbox <- rbind(c(-180, -90), c(-180, 90), 
                    c(180, 90), c(180, -90), c(-180, -90))

globe_border <- st_polygon(list(globe_bbox)) %>%
  st_sfc(crs = 4326) %>%
  st_sf(data.frame(rgn = 'globe', geom = .)) %>%
  smoothr::densify(max_distance = 0.5) %>%
  st_transform(crs = mcbryde_thomas_2)

# Create base theme
my_theme <- theme_minimal() +
  theme(
    legend.position = "bottom",
    legend.direction = "horizontal",
    legend.box = "vertical",
    legend.margin = margin(t = 20, r = 0, b = 0, l = 0),
    legend.title = element_text(margin = margin(b = 10)),
    panel.background = element_rect(fill = "white", color = NA),
    plot.background = element_rect(fill = "white", color = NA),
    panel.grid = element_blank()
  )

# Create plot for continental waters
continental_plot <- ggplot() +
  geom_sf(data = continental_projected, aes(color = mean_SES), size = 0.5, alpha = 0.7) +
  geom_sf(data = land_projected, fill = "lightgrey", color = "lightgrey", size = 0.1) +
  geom_sf(data = globe_border, fill = NA, color = "black", size = 0.5) +
  scale_color_gradient2(
    low = "#2166ac", mid = "#f0f0f0", high = "#b2182b", 
    midpoint = 0,
    name = "Mean SES",
    guide = guide_colorbar(barwidth = 20, barheight = 0.5, 
                         title.position = "top", title.hjust = 0.5)
  ) +
  coord_sf() +
  labs(title = "Standardized Effect Size (SES) in Continental Waters",
       subtitle = "All MPAs",
       x = NULL, y = NULL) +
  my_theme

# Create plot for high seas
high_seas_plot <- ggplot() +
  geom_sf(data = high_seas_projected, aes(color = mean_SES), size = 0.5, alpha = 0.7) +
  geom_sf(data = land_projected, fill = "lightgrey", color = "lightgrey", size = 0.1) +
  geom_sf(data = globe_border, fill = NA, color = "black", size = 0.5) +
  scale_color_gradient2(
    low = "#2166ac", mid = "#f0f0f0", high = "#b2182b", 
    midpoint = 0,
    name = "Mean SES",
    guide = guide_colorbar(barwidth = 20, barheight = 0.5, 
                         title.position = "top", title.hjust = 0.5)
  ) +
  coord_sf() +
  labs(title = "Standardized Effect Size (SES) in High Seas",
       subtitle = "All MPAs",
       x = NULL, y = NULL) +
  my_theme

# Save individual plots
ggsave(here::here("outputs","SES_map_continental_ALL.png"), 
       continental_plot,
       width = 10,
       height = 6,
       dpi = 300,
       bg = "white")

ggsave(here::here("outputs","SES_map_highseas_ALL.png"), 
       high_seas_plot,
       width = 10,
       height = 6,
       dpi = 300,
       bg = "white")

# Now repeat for No-take MPAs
# Calculate SES for No-take
comparison_NT <- comparison_NT %>%
  mutate(SES = (actual_percentage - mean_percentage) / sd_percentage)

combined_data_NT <- puvsp_long %>%
  left_join(comparison_NT, by = c("species" = "species"))

mean_ses_per_cell_NT <- combined_data_NT %>%
  group_by(id, lon, lat) %>%
  summarise(mean_SES = mean(SES, na.rm = TRUE)) %>%
  ungroup()

# Convert to terra SpatVector for extraction
ses_points_NT <- vect(as.data.frame(mean_ses_per_cell_NT), 
                      geom = c("lon", "lat"), 
                      crs = crs(highseas_raster))

# Extract values from highseas raster
highseas_values_NT <- terra::extract(highseas_raster, ses_points_NT)

# Add highseas classification back to the dataframe
mean_ses_per_cell_NT$is_highseas <- highseas_values_NT[, 2]
mean_ses_per_cell_NT$is_highseas[is.na(mean_ses_per_cell_NT$is_highseas)] <- 0  # Set NA to 0 (continental)

# Convert to sf for mapping
mean_ses_sf_NT <- st_as_sf(mean_ses_per_cell_NT, coords = c("lon", "lat"), crs = 4326)

# Split into high seas and continental waters
high_seas_points_NT <- mean_ses_sf_NT[mean_ses_sf_NT$is_highseas == 1, ]
continental_points_NT <- mean_ses_sf_NT[mean_ses_sf_NT$is_highseas == 0, ]

# Project
high_seas_projected_NT <- st_transform(high_seas_points_NT, crs = mcbryde_thomas_2)
continental_projected_NT <- st_transform(continental_points_NT, crs = mcbryde_thomas_2)

# Create plot for continental waters - No-take MPAs
continental_plot_NT <- ggplot() +
  geom_sf(data = continental_projected_NT, aes(color = mean_SES), size = 0.5, alpha = 0.7) +
  geom_sf(data = land_projected, fill = "lightgrey", color = "lightgrey", size = 0.1) +
  geom_sf(data = globe_border, fill = NA, color = "black", size = 0.5) +
  scale_color_gradient2(
    low = "#2166ac", mid = "#f0f0f0", high = "#b2182b", 
    midpoint = 0,
    name = "Mean SES",
    guide = guide_colorbar(barwidth = 20, barheight = 0.5, 
                         title.position = "top", title.hjust = 0.5)
  ) +
  coord_sf() +
  labs(title = "Standardized Effect Size (SES) in Continental Waters",
       subtitle = "No-take MPAs",
       x = NULL, y = NULL) +
  my_theme

# Create plot for high seas - No-take MPAs
high_seas_plot_NT <- ggplot() +
  geom_sf(data = high_seas_projected_NT, aes(color = mean_SES), size = 0.5, alpha = 0.7) +
  geom_sf(data = land_projected, fill = "lightgrey", color = "lightgrey", size = 0.1) +
  geom_sf(data = globe_border, fill = NA, color = "black", size = 0.5) +
  scale_color_gradient2(
    low = "#2166ac", mid = "#f0f0f0", high = "#b2182b", 
    midpoint = 0,
    name = "Mean SES",
    guide = guide_colorbar(barwidth = 20, barheight = 0.5, 
                         title.position = "top", title.hjust = 0.5)
  ) +
  coord_sf() +
  labs(title = "Standardized Effect Size (SES) in High Seas",
       subtitle = "No-take MPAs",
       x = NULL, y = NULL) +
  my_theme

# Save individual No-take plots
ggsave(here::here("outputs","SES_map_continental_NT.png"), 
       continental_plot_NT,
       width = 10,
       height = 6,
       dpi = 300,
       bg = "white")

ggsave(here::here("outputs","SES_map_highseas_NT.png"), 
       high_seas_plot_NT,
       width = 10,
       height = 6,
       dpi = 300,
       bg = "white")
```

# Relate to IUCN status

1.  Relate the percentage of species range overlapped by MPAs to the IUCN Red List status with difference tests between categories

```{r}
IUCN <- readRDS(here::here("Data","GAP analyses","sharks_iucn_final.RDS"))
# Remove underscores from species names
IUCN$species <- gsub("_", " ", IUCN$Species)

# Read the CSV file and assign it to "results"
results <- read.csv(here::here("Data", "species_mpa_coverage_ALL_and_NT.csv"))

results_IUCN=left_join(IUCN, results, by=c("species"))

library(ggplot2)
library(dplyr)

# Convert iucn_GE to a factor for better plotting
results_IUCN$iucn_GE <- as.factor(results_IUCN$iucn_GE)

results_IUCN <- results_IUCN %>%
  mutate(IUCN_status = case_when(
    iucn_GE == 0 ~ "LC",
    iucn_GE == 1 ~ "NT",
    iucn_GE == 2 ~ "VU",
    iucn_GE == 3 ~ "EN",
    iucn_GE == 4 ~ "CR",
    TRUE ~ "Unknown"
  ))

# Filter out the "Unknown" category
results_IUCN_filtered <- results_IUCN %>%
  filter(IUCN_status != "Unknown")

# Define IUCN colors and order
iucn_colors <- c(
  "CR" = "#D81E05",  # Red
  "EN" = "#FC7F3F",  # Orange
  "VU" = "#FEC748",  # Yellow
  "NT" = "#58AFFF",  # Light Blue
  "LC" = "#38AB38"   # Green
)

iucn_order <- c("LC", "NT", "VU", "EN", "CR")

library(ggplot2)
library(dplyr)
library(dunn.test)

# Perform Kruskal-Wallis test
kruskal_result <- kruskal.test(percentage_in_ALL_MPA ~ IUCN_status, data = results_IUCN_filtered)

# Perform Dunn's test for pairwise comparisons and capture the output
invisible(capture.output(
  dunn_result <- dunn.test(results_IUCN_filtered$percentage_in_ALL_MPA, 
                           results_IUCN_filtered$IUCN_status, 
                           method = "bonferroni")
))

# Create a function to add significance levels to the plot
add_significance <- function(p.value) {
  if(p.value <= 0.001) return("***")
  else if(p.value <= 0.01) return("**")
  else if(p.value <= 0.05) return("*")
  else return("ns")
}

# Create a data frame with pairwise comparisons and their significance
significant_comparisons <- data.frame(
  group1 = sapply(strsplit(dunn_result$comparisons, " - "), `[`, 1),
  group2 = sapply(strsplit(dunn_result$comparisons, " - "), `[`, 2),
  p.value = dunn_result$P.adjusted,
  stringsAsFactors = FALSE
)

# Add significance levels to the data frame
significant_comparisons$significance <- sapply(significant_comparisons$p.value, add_significance)

# Filter out non-significant comparisons
significant_comparisons <- significant_comparisons[significant_comparisons$significance != "ns", ]

# Calculate x positions for the significance bars
iucn_levels <- c("LC", "NT", "VU", "EN", "CR")
x_positions <- seq_along(iucn_levels)
names(x_positions) <- iucn_levels

significant_comparisons$x1 <- x_positions[significant_comparisons$group1]
significant_comparisons$x2 <- x_positions[significant_comparisons$group2]

# Sort comparisons based on the difference between group indices
significant_comparisons$group_diff <- abs(significant_comparisons$x2 - significant_comparisons$x1)
significant_comparisons <- significant_comparisons[order(significant_comparisons$group_diff, decreasing = TRUE), ]

# Calculate y positions for the sorted comparisons
max_y <- max(results_IUCN_filtered$percentage_in_ALL_MPA, na.rm = TRUE)
significant_comparisons$y.position <- seq(max_y + 5, 
                                        by = 10, 
                                        length.out = nrow(significant_comparisons))

# Recreate the base violin plot
violin_plot_all <- ggplot(results_IUCN_filtered, aes(x = factor(IUCN_status, levels = iucn_order), y = percentage_in_ALL_MPA)) +
  geom_violin(aes(fill = IUCN_status, color = IUCN_status), trim = FALSE, alpha = 0.5) +
  geom_jitter(width = 0.1, size = 0.5, alpha = 0.5, color = "darkgray") +
  geom_boxplot(width = 0.1, fill = "white", color = "black", outlier.shape = NA, alpha = 0.8) +
  labs(x = "IUCN Status", y = "(%) Range within MPAs") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5), legend.position = "none") +
  scale_x_discrete(limits = iucn_order) +
  scale_fill_manual(values = iucn_colors) +
  scale_color_manual(values = iucn_colors)

# Add significance bars and labels
violin_plot_with_significance_all <- violin_plot_all +
  geom_segment(data = significant_comparisons,
               aes(x = x1, xend = x2, y = y.position, yend = y.position),
               inherit.aes = FALSE,
               color = "black", size = 0.5) +
  geom_segment(data = significant_comparisons,
               aes(x = x1, xend = x1, y = y.position, yend = y.position - 2),
               inherit.aes = FALSE,
               color = "black", size = 0.5) +
  geom_segment(data = significant_comparisons,
               aes(x = x2, xend = x2, y = y.position, yend = y.position - 2),
               inherit.aes = FALSE,
               color = "black", size = 0.5) +
  geom_text(data = significant_comparisons,
            aes(x = (x1 + x2) / 2, y = y.position, label = significance),
            inherit.aes = FALSE,
            vjust = -0.2, size = 3)

# Display the updated plot
print(violin_plot_with_significance_all)

# Save the plot
#ggsave("violin_plot_with_significance.pdf", violin_plot_with_significance, width = 10, height = 8, units = "in")

# Summary statistics
summary_stats <- results_IUCN_filtered %>%
  group_by(IUCN_status) %>%
  summarise(
    count = n(),
    mean = mean(percentage_in_ALL_MPA, na.rm = TRUE),
    median = median(percentage_in_ALL_MPA, na.rm = TRUE),
    sd = sd(percentage_in_ALL_MPA, na.rm = TRUE)
  ) %>%
  arrange(factor(IUCN_status, levels = iucn_order))

print(summary_stats)

#Now for no-take MPAs 
kruskal_result <- kruskal.test(sqrt(percentage_in_NT_MPA) ~ IUCN_status, data = results_IUCN_filtered)

# Perform Dunn's test for pairwise comparisons
# Perform Dunn's test for pairwise comparisons and capture the output
invisible(capture.output(
  dunn_result <- dunn.test(sqrt(results_IUCN_filtered$percentage_in_NT_MPA), 
                           results_IUCN_filtered$IUCN_status, 
                           method = "bonferroni")
))

# Create a function to add significance levels to the plot
add_significance <- function(p.value) {
  if(p.value <= 0.001) return("***")
  else if(p.value <= 0.01) return("**")
  else if(p.value <= 0.05) return("*")
  else return("ns")
}

# Create a data frame with pairwise comparisons and their significance
significant_comparisons <- data.frame(
  group1 = sapply(strsplit(dunn_result$comparisons, " - "), `[`, 1),
  group2 = sapply(strsplit(dunn_result$comparisons, " - "), `[`, 2),
  p.value = dunn_result$P.adjusted,
  stringsAsFactors = FALSE
)

# Add significance levels to the data frame
significant_comparisons$significance <- sapply(significant_comparisons$p.value, add_significance)

# Filter out non-significant comparisons
significant_comparisons <- significant_comparisons[significant_comparisons$significance != "ns", ]

# Calculate x positions for the significance bars
iucn_levels <- c("LC", "NT", "VU", "EN", "CR")
x_positions <- seq_along(iucn_levels)
names(x_positions) <- iucn_levels

significant_comparisons$x1 <- x_positions[significant_comparisons$group1]
significant_comparisons$x2 <- x_positions[significant_comparisons$group2]

# Sort comparisons based on the difference between group indices
significant_comparisons$group_diff <- abs(significant_comparisons$x2 - significant_comparisons$x1)
significant_comparisons <- significant_comparisons[order(significant_comparisons$group_diff, decreasing = TRUE), ]

# Calculate y positions for the sorted comparisons
significant_comparisons$y.position <- seq(max(results_IUCN_filtered$percentage_in_ALL_MPA, na.rm = TRUE) + 5, 
                                          by = 5, 
                                          length.out = nrow(significant_comparisons))

# Recreate the base violin plot
violin_plot_nt <- ggplot(results_IUCN_filtered, aes(x = factor(IUCN_status, levels = iucn_order), y = percentage_in_NT_MPA)) +
  geom_violin(aes(fill = IUCN_status, color = IUCN_status), trim = FALSE, alpha = 0.5) +
  geom_jitter(width = 0.1, size = 0.5, alpha = 0.5, color = "darkgray") +
  geom_boxplot(width = 0.1, fill = "white", color = "black", outlier.shape = NA, alpha = 0.8) +
  labs(x = "IUCN Status", y = "(%) Range within no-take MPAs") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5), legend.position = "none") +
  scale_x_discrete(limits = iucn_order) +
  scale_y_continuous(transform = "sqrt") +
  scale_fill_manual(values = iucn_colors) +
  scale_color_manual(values = iucn_colors)

# Add significance bars and labels
violin_plot_with_significance_nt <- violin_plot_nt +
  geom_segment(data = significant_comparisons,
               aes(x = x1, xend = x2, y = y.position, yend = y.position),
               inherit.aes = FALSE,
               color = "black", size = 0.5) +
  geom_segment(data = significant_comparisons,
               aes(x = x1, xend = x1, y = y.position, yend = y.position - 2),
               inherit.aes = FALSE,
               color = "black", size = 0.5) +
  geom_segment(data = significant_comparisons,
               aes(x = x2, xend = x2, y = y.position, yend = y.position - 2),
               inherit.aes = FALSE,
               color = "black", size = 0.5) +
  geom_text(data = significant_comparisons,
            aes(x = (x1 + x2) / 2, y = y.position, label = significance),
            inherit.aes = FALSE,
            vjust = -0.5, size = 3)

# Display the updated plot
print(violin_plot_with_significance_nt)

# Summary statistics
summary_stats <- results_IUCN_filtered %>%
  group_by(IUCN_status) %>%
  summarise(
    count = n(),
    mean = mean(percentage_in_NT_MPA, na.rm = TRUE),
    median = median(percentage_in_NT_MPA, na.rm = TRUE),
    sd = sd(percentage_in_NT_MPA, na.rm = TRUE)
  ) %>%
  arrange(factor(IUCN_status, levels = iucn_order))

print(summary_stats)

# Then combine them using patchwork:
library(patchwork)
combined_plot <- violin_plot_with_significance_all + violin_plot_with_significance_nt +
  plot_annotation(tag_levels = 'A')

# Save the combined plot
ggsave(here::here("combined_violin_plots_current_protection.png"), combined_plot, width = 12, height = 6, units = "in")

```

**Key message:** Least concerned species are significantly more protected by all MPAs than any other IUCN Red List threat status category. We also note a similar relationship (LC vs VU, EN & CR) for no-take MPAs, however, after p-value adjustment for multiple comparison, differences were not significant for no-take MPAs.

## Relate to IUCN status: proposed protection

### FUSE 0.3 budget

```{r}
# Read the data
combined_protection_FUSE_03 <- readRDS(here::here("Data", "combined_protection_FUSE_03.rds"))

# FUSE 0.3 budget 
IUCN <- readRDS(here::here("Data","GAP analyses","sharks_iucn_final.RDS"))

# Remove underscores from species names
IUCN$species <- gsub("_", " ", IUCN$Species)

# Join with combined_protection_FUSE_03
results_IUCN <- left_join(IUCN, combined_protection_FUSE_03, by=c("species" = "Species"))

library(ggplot2)
library(dplyr)

# Convert iucn_GE to a factor for better plotting
results_IUCN$iucn_GE <- as.factor(results_IUCN$iucn_GE)

results_IUCN <- results_IUCN %>%
  mutate(IUCN_status = case_when(
    iucn_GE == 0 ~ "LC",
    iucn_GE == 1 ~ "NT",
    iucn_GE == 2 ~ "VU",
    iucn_GE == 3 ~ "EN",
    iucn_GE == 4 ~ "CR",
    TRUE ~ "Unknown"
  ))

# Filter out the "Unknown" category
results_IUCN_filtered <- results_IUCN %>%
  filter(IUCN_status != "Unknown")

# Define IUCN colors and order
iucn_colors <- c(
  "CR" = "#D81E05",  # Red
  "EN" = "#FC7F3F",  # Orange
  "VU" = "#FEC748",  # Yellow
  "NT" = "#58AFFF",  # Light Blue
  "LC" = "#38AB38"   # Green
)

iucn_order <- c("LC", "NT", "VU", "EN", "CR")

library(ggplot2)
library(dplyr)
library(dunn.test)

# Perform Kruskal-Wallis test with sqrt transformation
kruskal_result <- kruskal.test(sqrt(weighted_protection) ~ IUCN_status, data = results_IUCN_filtered)

# Perform Dunn's test for pairwise comparisons with sqrt transformation and capture the output
invisible(capture.output(
  dunn_result <- dunn.test(sqrt(results_IUCN_filtered$weighted_protection), 
                           results_IUCN_filtered$IUCN_status, 
                           method = "bonferroni")
))

# Create a function to add significance levels to the plot
add_significance <- function(p.value) {
  if(p.value <= 0.001) return("***")
  else if(p.value <= 0.01) return("**")
  else if(p.value <= 0.05) return("*")
  else return("ns")
}

# Create a data frame with pairwise comparisons and their significance
significant_comparisons <- data.frame(
  group1 = sapply(strsplit(dunn_result$comparisons, " - "), `[`, 1),
  group2 = sapply(strsplit(dunn_result$comparisons, " - "), `[`, 2),
  p.value = dunn_result$P.adjusted,
  stringsAsFactors = FALSE
)

# Add significance levels to the data frame
significant_comparisons$significance <- sapply(significant_comparisons$p.value, add_significance)

# Filter out non-significant comparisons
significant_comparisons <- significant_comparisons[significant_comparisons$significance != "ns", ]

# Calculate x positions for the significance bars
iucn_levels <- c("LC", "NT", "VU", "EN", "CR")
x_positions <- seq_along(iucn_levels)
names(x_positions) <- iucn_levels

significant_comparisons$x1 <- x_positions[significant_comparisons$group1]
significant_comparisons$x2 <- x_positions[significant_comparisons$group2]

# Sort comparisons based on the difference between group indices
significant_comparisons$group_diff <- abs(significant_comparisons$x2 - significant_comparisons$x1)
significant_comparisons <- significant_comparisons[order(significant_comparisons$group_diff, decreasing = TRUE), ]

# Calculate y positions for the sorted comparisons using sqrt transformation
max_y <- max(sqrt(results_IUCN_filtered$weighted_protection), na.rm = TRUE)
significant_comparisons$y.position <- seq(max_y + 0.05, 
                                        by = 0.1, 
                                        length.out = nrow(significant_comparisons))

# Create the base violin plot with scale_y_sqrt
violin_plot_FUSE_03 <- ggplot(results_IUCN_filtered, aes(x = factor(IUCN_status, levels = iucn_order), y = weighted_protection)) +
  geom_violin(aes(fill = IUCN_status, color = IUCN_status), trim = FALSE, alpha = 0.5) +
  geom_jitter(width = 0.1, size = 0.5, alpha = 0.5, color = "darkgray") +
  geom_boxplot(width = 0.1, fill = "white", color = "black", outlier.shape = NA, alpha = 0.8) +
  labs(x = "IUCN Status", 
       y = "Weighted Protection") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5), legend.position = "none") +
  scale_x_discrete(limits = iucn_order) +
  scale_fill_manual(values = iucn_colors) +
  scale_color_manual(values = iucn_colors) +
  scale_y_sqrt(limits = c(0,1.2))

# Recalculate max_y for significance bars (no need for sqrt here as scale_y_sqrt handles it)
max_y <- max(results_IUCN_filtered$weighted_protection, na.rm = TRUE)
significant_comparisons$y.position <- seq(max_y + 0.05, 
                                        by = 0.1, 
                                        length.out = nrow(significant_comparisons))

# Add significance bars and labels
violin_plot_with_significance_FUSE_03 <- violin_plot_FUSE_03 +
  geom_segment(data = significant_comparisons,
               aes(x = x1, xend = x2, y = y.position, yend = y.position),
               inherit.aes = FALSE,
               color = "black", size = 0.5) +
  geom_segment(data = significant_comparisons,
               aes(x = x1, xend = x1, y = y.position, yend = y.position - 0.02),
               inherit.aes = FALSE,
               color = "black", size = 0.5) +
  geom_segment(data = significant_comparisons,
               aes(x = x2, xend = x2, y = y.position, yend = y.position - 0.02),
               inherit.aes = FALSE,
               color = "black", size = 0.5) +
  geom_text(data = significant_comparisons,
            aes(x = (x1 + x2) / 2, y = y.position, label = significance),
            inherit.aes = FALSE,
            vjust = -0.2, size = 3)

# Display the updated plot
print(violin_plot_with_significance_FUSE_03)

# Summary statistics with both raw and transformed values
summary_stats <- results_IUCN_filtered %>%
  group_by(IUCN_status) %>%
  summarise(
    count = n(),
    mean_raw = mean(weighted_protection, na.rm = TRUE),
    median_raw = median(weighted_protection, na.rm = TRUE),
    sd_raw = sd(weighted_protection, na.rm = TRUE),
    mean_sqrt = mean(sqrt(weighted_protection), na.rm = TRUE),
    median_sqrt = median(sqrt(weighted_protection), na.rm = TRUE),
    sd_sqrt = sd(sqrt(weighted_protection), na.rm = TRUE)
  ) %>%
  arrange(factor(IUCN_status, levels = iucn_order))

print(summary_stats)

# Save the results
saveRDS(results_IUCN_filtered, file = here::here("Data", "results_IUCN_filtered_FUSE_03.rds"))
```

### FUSE 0.1 budget

```{r}
# Read the data
combined_protection_FUSE_01 <- readRDS(here::here("Data", "combined_protection_FUSE_01.rds"))

# FUSE 0.1 budget 
IUCN <- readRDS(here::here("Data","GAP analyses","sharks_iucn_final.RDS"))
# Remove underscores from species names
IUCN$species <- gsub("_", " ", IUCN$Species)

# Join with combined_protection_FUSE_01
results_IUCN <- left_join(IUCN, combined_protection_FUSE_01, by=c("species" = "Species"))

library(ggplot2)
library(dplyr)

# Convert iucn_GE to a factor for better plotting
results_IUCN$iucn_GE <- as.factor(results_IUCN$iucn_GE)

results_IUCN <- results_IUCN %>%
  mutate(IUCN_status = case_when(
    iucn_GE == 0 ~ "LC",
    iucn_GE == 1 ~ "NT",
    iucn_GE == 2 ~ "VU",
    iucn_GE == 3 ~ "EN",
    iucn_GE == 4 ~ "CR",
    TRUE ~ "Unknown"
  ))

# Filter out the "Unknown" category
results_IUCN_filtered <- results_IUCN %>%
  filter(IUCN_status != "Unknown")

# Define IUCN colors and order
iucn_colors <- c(
  "CR" = "#D81E05",  # Red
  "EN" = "#FC7F3F",  # Orange
  "VU" = "#FEC748",  # Yellow
  "NT" = "#58AFFF",  # Light Blue
  "LC" = "#38AB38"   # Green
)

iucn_order <- c("LC", "NT", "VU", "EN", "CR")

library(ggplot2)
library(dplyr)
library(dunn.test)

# Perform Kruskal-Wallis test with sqrt transformation
kruskal_result <- kruskal.test(sqrt(weighted_protection) ~ IUCN_status, data = results_IUCN_filtered)

# Perform Dunn's test for pairwise comparisons with sqrt transformation and capture the output
invisible(capture.output(
  dunn_result <- dunn.test(sqrt(results_IUCN_filtered$weighted_protection), 
                           results_IUCN_filtered$IUCN_status, 
                           method = "bonferroni")
))

# Create a function to add significance levels to the plot
add_significance <- function(p.value) {
  if(p.value <= 0.001) return("***")
  else if(p.value <= 0.01) return("**")
  else if(p.value <= 0.05) return("*")
  else return("ns")
}

# Create a data frame with pairwise comparisons and their significance
significant_comparisons <- data.frame(
  group1 = sapply(strsplit(dunn_result$comparisons, " - "), `[`, 1),
  group2 = sapply(strsplit(dunn_result$comparisons, " - "), `[`, 2),
  p.value = dunn_result$P.adjusted,
  stringsAsFactors = FALSE
)

# Add significance levels to the data frame
significant_comparisons$significance <- sapply(significant_comparisons$p.value, add_significance)

# Filter out non-significant comparisons
significant_comparisons <- significant_comparisons[significant_comparisons$significance != "ns", ]

# Calculate x positions for the significance bars
iucn_levels <- c("LC", "NT", "VU", "EN", "CR")
x_positions <- seq_along(iucn_levels)
names(x_positions) <- iucn_levels

significant_comparisons$x1 <- x_positions[significant_comparisons$group1]
significant_comparisons$x2 <- x_positions[significant_comparisons$group2]

# Sort comparisons based on the difference between group indices
significant_comparisons$group_diff <- abs(significant_comparisons$x2 - significant_comparisons$x1)
significant_comparisons <- significant_comparisons[order(significant_comparisons$group_diff, decreasing = TRUE), ]

# Calculate y positions for the sorted comparisons using sqrt transformation
max_y <- max(sqrt(results_IUCN_filtered$weighted_protection), na.rm = TRUE)
significant_comparisons$y.position <- seq(max_y + 0.05, 
                                        by = 0.1, 
                                        length.out = nrow(significant_comparisons))

# Create the base violin plot with scale_y_sqrt
violin_plot_FUSE_01 <- ggplot(results_IUCN_filtered, aes(x = factor(IUCN_status, levels = iucn_order), y = weighted_protection)) +
  geom_violin(aes(fill = IUCN_status, color = IUCN_status), trim = FALSE, alpha = 0.5) +
  geom_jitter(width = 0.1, size = 0.5, alpha = 0.5, color = "darkgray") +
  geom_boxplot(width = 0.1, fill = "white", color = "black", outlier.shape = NA, alpha = 0.8) +
  labs(x = "IUCN Status", 
       y = "Weighted Protection") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5), legend.position = "none") +
  scale_x_discrete(limits = iucn_order) +
  scale_fill_manual(values = iucn_colors) +
  scale_color_manual(values = iucn_colors) +
  scale_y_sqrt(limits = c(0,1.2))

# Recalculate max_y for significance bars (no need for sqrt here as scale_y_sqrt handles it)
max_y <- max(results_IUCN_filtered$weighted_protection, na.rm = TRUE)
significant_comparisons$y.position <- seq(max_y + 0.05, 
                                        by = 0.1, 
                                        length.out = nrow(significant_comparisons))

# Add significance bars and labels
violin_plot_with_significance_FUSE_01 <- violin_plot_FUSE_01 +
  geom_segment(data = significant_comparisons,
               aes(x = x1, xend = x2, y = y.position, yend = y.position),
               inherit.aes = FALSE,
               color = "black", size = 0.5) +
  geom_segment(data = significant_comparisons,
               aes(x = x1, xend = x1, y = y.position, yend = y.position - 0.02),
               inherit.aes = FALSE,
               color = "black", size = 0.5) +
  geom_segment(data = significant_comparisons,
               aes(x = x2, xend = x2, y = y.position, yend = y.position - 0.02),
               inherit.aes = FALSE,
               color = "black", size = 0.5) +
  geom_text(data = significant_comparisons,
            aes(x = (x1 + x2) / 2, y = y.position, label = significance),
            inherit.aes = FALSE,
            vjust = -0.2, size = 3)

# Display the updated plot
print(violin_plot_with_significance_FUSE_01)

# Summary statistics with both raw and transformed values
summary_stats <- results_IUCN_filtered %>%
  group_by(IUCN_status) %>%
  summarise(
    count = n(),
    mean_raw = mean(weighted_protection, na.rm = TRUE),
    median_raw = median(weighted_protection, na.rm = TRUE),
    sd_raw = sd(weighted_protection, na.rm = TRUE),
    mean_sqrt = mean(sqrt(weighted_protection), na.rm = TRUE),
    median_sqrt = median(sqrt(weighted_protection), na.rm = TRUE),
    sd_sqrt = sd(sqrt(weighted_protection), na.rm = TRUE)
  ) %>%
  arrange(factor(IUCN_status, levels = iucn_order))

print(summary_stats)

# Save the results
saveRDS(results_IUCN_filtered, file = here::here("Data", "results_IUCN_filtered_FUSE_01.rds"))
```

### EDGE 0.3 budget

```{r}
# Read the data
combined_protection_EDGE_03 <- readRDS(here::here("Data", "combined_protection_EDGE_03.rds"))

# EDGE2 0.3 budget 
IUCN <- readRDS(here::here("Data","GAP analyses","sharks_iucn_final.RDS"))
# Remove underscores from species names
IUCN$species <- gsub("_", " ", IUCN$Species)

# Join with combined_protection_EDGE_03
results_IUCN <- left_join(IUCN, combined_protection_EDGE_03, by=c("species" = "species_name"))

library(ggplot2)
library(dplyr)

# Convert iucn_GE to a factor for better plotting
results_IUCN$iucn_GE <- as.factor(results_IUCN$iucn_GE)

results_IUCN <- results_IUCN %>%
  mutate(IUCN_status = case_when(
    iucn_GE == 0 ~ "LC",
    iucn_GE == 1 ~ "NT",
    iucn_GE == 2 ~ "VU",
    iucn_GE == 3 ~ "EN",
    iucn_GE == 4 ~ "CR",
    TRUE ~ "Unknown"
  ))

# Filter out the "Unknown" category
results_IUCN_filtered <- results_IUCN %>%
  filter(IUCN_status != "Unknown")

# Define IUCN colors and order
iucn_colors <- c(
  "CR" = "#D81E05",  # Red
  "EN" = "#FC7F3F",  # Orange
  "VU" = "#FEC748",  # Yellow
  "NT" = "#58AFFF",  # Light Blue
  "LC" = "#38AB38"   # Green
)

iucn_order <- c("LC", "NT", "VU", "EN", "CR")

library(ggplot2)
library(dplyr)
library(dunn.test)

# Perform Kruskal-Wallis test with sqrt transformation
kruskal_result <- kruskal.test(sqrt(weighted_protection) ~ IUCN_status, data = results_IUCN_filtered)

# Perform Dunn's test for pairwise comparisons with sqrt transformation and capture the output
invisible(capture.output(
  dunn_result <- dunn.test(sqrt(results_IUCN_filtered$weighted_protection), 
                           results_IUCN_filtered$IUCN_status, 
                           method = "bonferroni")
))

# Create a function to add significance levels to the plot
add_significance <- function(p.value) {
  if(p.value <= 0.001) return("***")
  else if(p.value <= 0.01) return("**")
  else if(p.value <= 0.05) return("*")
  else return("ns")
}

# Create a data frame with pairwise comparisons and their significance
significant_comparisons <- data.frame(
  group1 = sapply(strsplit(dunn_result$comparisons, " - "), `[`, 1),
  group2 = sapply(strsplit(dunn_result$comparisons, " - "), `[`, 2),
  p.value = dunn_result$P.adjusted,
  stringsAsFactors = FALSE
)

# Add significance levels to the data frame
significant_comparisons$significance <- sapply(significant_comparisons$p.value, add_significance)

# Filter out non-significant comparisons
significant_comparisons <- significant_comparisons[significant_comparisons$significance != "ns", ]

# Calculate x positions for the significance bars
iucn_levels <- c("LC", "NT", "VU", "EN", "CR")
x_positions <- seq_along(iucn_levels)
names(x_positions) <- iucn_levels

significant_comparisons$x1 <- x_positions[significant_comparisons$group1]
significant_comparisons$x2 <- x_positions[significant_comparisons$group2]

# Sort comparisons based on the difference between group indices
significant_comparisons$group_diff <- abs(significant_comparisons$x2 - significant_comparisons$x1)
significant_comparisons <- significant_comparisons[order(significant_comparisons$group_diff, decreasing = TRUE), ]

# Calculate y positions for the sorted comparisons using sqrt transformation
max_y <- max(sqrt(results_IUCN_filtered$weighted_protection), na.rm = TRUE)
significant_comparisons$y.position <- seq(max_y + 0.05, 
                                        by = 0.1, 
                                        length.out = nrow(significant_comparisons))

# Create the base violin plot with scale_y_sqrt
violin_plot_EDGE_03 <- ggplot(results_IUCN_filtered, aes(x = factor(IUCN_status, levels = iucn_order), y = weighted_protection)) +
  geom_violin(aes(fill = IUCN_status, color = IUCN_status), trim = FALSE, alpha = 0.5) +
  geom_jitter(width = 0.1, size = 0.5, alpha = 0.5, color = "darkgray") +
  geom_boxplot(width = 0.1, fill = "white", color = "black", outlier.shape = NA, alpha = 0.8) +
  labs(x = "IUCN Status", 
       y = "Weighted Protection") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5), legend.position = "none") +
  scale_x_discrete(limits = iucn_order) +
  scale_fill_manual(values = iucn_colors) +
  scale_color_manual(values = iucn_colors) +
  scale_y_sqrt(limits = c(0,1.2))

# Recalculate max_y for significance bars (no need for sqrt here as scale_y_sqrt handles it)
max_y <- max(results_IUCN_filtered$weighted_protection, na.rm = TRUE)
significant_comparisons$y.position <- seq(max_y + 0.05, 
                                        by = 0.1, 
                                        length.out = nrow(significant_comparisons))

# Add significance bars and labels
violin_plot_with_significance_EDGE_03 <- violin_plot_EDGE_03 +
  geom_segment(data = significant_comparisons,
               aes(x = x1, xend = x2, y = y.position, yend = y.position),
               inherit.aes = FALSE,
               color = "black", size = 0.5) +
  geom_segment(data = significant_comparisons,
               aes(x = x1, xend = x1, y = y.position, yend = y.position - 0.02),
               inherit.aes = FALSE,
               color = "black", size = 0.5) +
  geom_segment(data = significant_comparisons,
               aes(x = x2, xend = x2, y = y.position, yend = y.position - 0.02),
               inherit.aes = FALSE,
               color = "black", size = 0.5) +
  geom_text(data = significant_comparisons,
            aes(x = (x1 + x2) / 2, y = y.position, label = significance),
            inherit.aes = FALSE,
            vjust = -0.2, size = 3)

# Display the updated plot
print(violin_plot_with_significance_EDGE_03)

# Summary statistics with both raw and transformed values
summary_stats <- results_IUCN_filtered %>%
  group_by(IUCN_status) %>%
  summarise(
    count = n(),
    mean_raw = mean(weighted_protection, na.rm = TRUE),
    median_raw = median(weighted_protection, na.rm = TRUE),
    sd_raw = sd(weighted_protection, na.rm = TRUE),
    mean_sqrt = mean(sqrt(weighted_protection), na.rm = TRUE),
    median_sqrt = median(sqrt(weighted_protection), na.rm = TRUE),
    sd_sqrt = sd(sqrt(weighted_protection), na.rm = TRUE)
  ) %>%
  arrange(factor(IUCN_status, levels = iucn_order))

print(summary_stats)

# Save the results
saveRDS(results_IUCN_filtered, file = here::here("Data", "results_IUCN_filtered_EDGE_03.rds"))
```

### EDGE 0.1 budget

```{r}
# Read the data
combined_protection_EDGE_01 <- readRDS(here::here("Data", "combined_protection_EDGE_01.rds"))

# EDGE2 0.1 budget 
IUCN <- readRDS(here::here("Data","GAP analyses","sharks_iucn_final.RDS"))
# Remove underscores from species names
IUCN$species <- gsub("_", " ", IUCN$Species)

# Join with combined_protection_EDGE_01
results_IUCN <- left_join(IUCN, combined_protection_EDGE_01, by=c("species" = "species_name"))

library(ggplot2)
library(dplyr)

# Convert iucn_GE to a factor for better plotting
results_IUCN$iucn_GE <- as.factor(results_IUCN$iucn_GE)

results_IUCN <- results_IUCN %>%
  mutate(IUCN_status = case_when(
    iucn_GE == 0 ~ "LC",
    iucn_GE == 1 ~ "NT",
    iucn_GE == 2 ~ "VU",
    iucn_GE == 3 ~ "EN",
    iucn_GE == 4 ~ "CR",
    TRUE ~ "Unknown"
  ))

# Filter out the "Unknown" category
results_IUCN_filtered <- results_IUCN %>%
  filter(IUCN_status != "Unknown")

# Define IUCN colors and order
iucn_colors <- c(
  "CR" = "#D81E05",  # Red
  "EN" = "#FC7F3F",  # Orange
  "VU" = "#FEC748",  # Yellow
  "NT" = "#58AFFF",  # Light Blue
  "LC" = "#38AB38"   # Green
)

iucn_order <- c("LC", "NT", "VU", "EN", "CR")

library(ggplot2)
library(dplyr)
library(dunn.test)

# Perform Kruskal-Wallis test with sqrt transformation
kruskal_result <- kruskal.test(sqrt(weighted_protection) ~ IUCN_status, data = results_IUCN_filtered)

# Perform Dunn's test for pairwise comparisons with sqrt transformation and capture the output
invisible(capture.output(
  dunn_result <- dunn.test(sqrt(results_IUCN_filtered$weighted_protection), 
                           results_IUCN_filtered$IUCN_status, 
                           method = "bonferroni")
))

# Create a function to add significance levels to the plot
add_significance <- function(p.value) {
  if(p.value <= 0.001) return("***")
  else if(p.value <= 0.01) return("**")
  else if(p.value <= 0.05) return("*")
  else return("ns")
}

# Create a data frame with pairwise comparisons and their significance
significant_comparisons <- data.frame(
  group1 = sapply(strsplit(dunn_result$comparisons, " - "), `[`, 1),
  group2 = sapply(strsplit(dunn_result$comparisons, " - "), `[`, 2),
  p.value = dunn_result$P.adjusted,
  stringsAsFactors = FALSE
)

# Add significance levels to the data frame
significant_comparisons$significance <- sapply(significant_comparisons$p.value, add_significance)

# Filter out non-significant comparisons
significant_comparisons <- significant_comparisons[significant_comparisons$significance != "ns", ]

# Calculate x positions for the significance bars
iucn_levels <- c("LC", "NT", "VU", "EN", "CR")
x_positions <- seq_along(iucn_levels)
names(x_positions) <- iucn_levels

significant_comparisons$x1 <- x_positions[significant_comparisons$group1]
significant_comparisons$x2 <- x_positions[significant_comparisons$group2]

# Sort comparisons based on the difference between group indices
significant_comparisons$group_diff <- abs(significant_comparisons$x2 - significant_comparisons$x1)
significant_comparisons <- significant_comparisons[order(significant_comparisons$group_diff, decreasing = TRUE), ]

# Calculate y positions for the sorted comparisons using sqrt transformation
max_y <- max(sqrt(results_IUCN_filtered$weighted_protection), na.rm = TRUE)
significant_comparisons$y.position <- seq(max_y + 0.05, 
                                        by = 0.1, 
                                        length.out = nrow(significant_comparisons))

# Create the base violin plot with scale_y_sqrt
violin_plot_EDGE_01 <- ggplot(results_IUCN_filtered, aes(x = factor(IUCN_status, levels = iucn_order), y = weighted_protection)) +
  geom_violin(aes(fill = IUCN_status, color = IUCN_status), trim = FALSE, alpha = 0.5) +
  geom_jitter(width = 0.1, size = 0.5, alpha = 0.5, color = "darkgray") +
  geom_boxplot(width = 0.1, fill = "white", color = "black", outlier.shape = NA, alpha = 0.8) +
  labs(x = "IUCN Status", 
       y = "Weighted Protection") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5), legend.position = "none") +
  scale_x_discrete(limits = iucn_order) +
  scale_fill_manual(values = iucn_colors) +
  scale_color_manual(values = iucn_colors) +
  scale_y_sqrt(limits = c(0,1.2))

# Recalculate max_y for significance bars (no need for sqrt here as scale_y_sqrt handles it)
max_y <- max(results_IUCN_filtered$weighted_protection, na.rm = TRUE)
significant_comparisons$y.position <- seq(max_y + 0.05, 
                                        by = 0.1, 
                                        length.out = nrow(significant_comparisons))

# Add significance bars and labels
violin_plot_with_significance_EDGE_01 <- violin_plot_EDGE_01 +
  geom_segment(data = significant_comparisons,
               aes(x = x1, xend = x2, y = y.position, yend = y.position),
               inherit.aes = FALSE,
               color = "black", size = 0.5) +
  geom_segment(data = significant_comparisons,
               aes(x = x1, xend = x1, y = y.position, yend = y.position - 0.02),
               inherit.aes = FALSE,
               color = "black", size = 0.5) +
  geom_segment(data = significant_comparisons,
               aes(x = x2, xend = x2, y = y.position, yend = y.position - 0.02),
               inherit.aes = FALSE,
               color = "black", size = 0.5) +
  geom_text(data = significant_comparisons,
            aes(x = (x1 + x2) / 2, y = y.position, label = significance),
            inherit.aes = FALSE,
            vjust = -0.2, size = 3)

# Display the updated plot
print(violin_plot_with_significance_EDGE_01)

# Summary statistics with both raw and transformed values
summary_stats <- results_IUCN_filtered %>%
  group_by(IUCN_status) %>%
  summarise(
    count = n(),
    mean_raw = mean(weighted_protection, na.rm = TRUE),
    median_raw = median(weighted_protection, na.rm = TRUE),
    sd_raw = sd(weighted_protection, na.rm = TRUE),
    mean_sqrt = mean(sqrt(weighted_protection), na.rm = TRUE),
    median_sqrt = median(sqrt(weighted_protection), na.rm = TRUE),
    sd_sqrt = sd(sqrt(weighted_protection), na.rm = TRUE)
  ) %>%
  arrange(factor(IUCN_status, levels = iucn_order))

print(summary_stats)

# Save the results
saveRDS(results_IUCN_filtered, file = here::here("Data", "results_IUCN_filtered_EDGE_01.rds"))
```

### Combine six plots in a grid

```{r}
# Then combine them using patchwork:
library(patchwork)
combined_plot <- (violin_plot_with_significance_all + violin_plot_with_significance_nt) /
                 (violin_plot_with_significance_FUSE_01 + violin_plot_with_significance_FUSE_03) /
                 (violin_plot_with_significance_EDGE_01 + violin_plot_with_significance_EDGE_03) +
  plot_annotation(tag_levels = 'A')

# Save the combined plot
ggsave(here::here("combined_violin_plots_six_plots.png"), combined_plot, width = 12, height = 5*3, units = "in")

```

### Ridgeline chart : six charts 

```{r}
library(tidyverse)
library(ggridges)

# 1. First prepare the IUCN data and function
prepare_iucn_data <- function(species_data, species_col) {
  IUCN <- readRDS(here::here("Data","GAP analyses","sharks_iucn_final.RDS"))
  IUCN$species <- gsub("_", " ", IUCN$Species)
  
  # Rename the species column in the input data to match
  species_data <- species_data %>%
    dplyr::rename(species = all_of(species_col))
  
  results_IUCN <- left_join(IUCN, species_data, by="species") %>%
    mutate(IUCN_status = case_when(
      iucn_GE == 0 ~ "LC",
      iucn_GE == 1 ~ "NT",
      iucn_GE == 2 ~ "VU",
      iucn_GE == 3 ~ "EN",
      iucn_GE == 4 ~ "CR",
      TRUE ~ "Unknown"
    )) %>%
    filter(IUCN_status != "Unknown")
  
  return(results_IUCN)
}

# 2. Prepare all datasets
mpa_data <- results %>%
  dplyr::select(species, percentage_in_ALL_MPA, percentage_in_NT_MPA) %>%
  dplyr::rename(Species = species)

fuse01_data <- readRDS(here::here("Data", "combined_protection_FUSE_01.rds"))
fuse03_data <- readRDS(here::here("Data", "combined_protection_FUSE_03.rds"))
edge01_data <- readRDS(here::here("Data", "combined_protection_EDGE_01.rds"))
edge03_data <- readRDS(here::here("Data", "combined_protection_EDGE_03.rds"))

# 3. Create separate dataframes with IUCN status
# Modify the MPA data scenario names
mpa_iucn <- prepare_iucn_data(mpa_data, "Species") %>%
  dplyr::select(species, IUCN_status, percentage_in_ALL_MPA, percentage_in_NT_MPA) %>%
  pivot_longer(cols = c(percentage_in_ALL_MPA, percentage_in_NT_MPA),
               names_to = "scenario",
               values_to = "protection") %>%
  mutate(scenario = case_when(
    scenario == "percentage_in_NT_MPA" ~ "Current no-take MPAs overlaps",
    scenario == "percentage_in_ALL_MPA" ~ "Current all MPAs overlaps"
  ))

# Modify FUSE scenarios names
fuse01_iucn <- prepare_iucn_data(fuse01_data, "Species") %>%
  dplyr::select(species, IUCN_status, weighted_protection) %>%
  mutate(protection = weighted_protection * 100,
         scenario = "FUSE scenario, budget 10%") %>%
  dplyr::select(-weighted_protection)

fuse03_iucn <- prepare_iucn_data(fuse03_data, "Species") %>%
  dplyr::select(species, IUCN_status, weighted_protection) %>%
  mutate(protection = weighted_protection * 100,
         scenario = "FUSE scenario, budget 30%") %>%
  dplyr::select(-weighted_protection)

# Modify EDGE2 scenarios names
edge01_iucn <- prepare_iucn_data(edge01_data, "species_name") %>%
  dplyr::select(species, IUCN_status, weighted_protection) %>%
  mutate(protection = weighted_protection * 100,
         scenario = "EDGE2 scenario, budget 10%") %>%
  dplyr::select(-weighted_protection)

edge03_iucn <- prepare_iucn_data(edge03_data, "species_name") %>%
  dplyr::select(species, IUCN_status, weighted_protection) %>%
  mutate(protection = weighted_protection * 100,
         scenario = "EDGE2 scenario, budget 30%") %>%
  dplyr::select(-weighted_protection)

# Combine all data
combined_data <- bind_rows(
  mpa_iucn,
  fuse01_iucn,
  fuse03_iucn,
  edge01_iucn,
  edge03_iucn
)

# Update factor levels with new names
combined_data$scenario <- factor(combined_data$scenario,
                               levels = c("Current no-take MPAs overlaps", 
                                        "Current all MPAs overlaps",
                                        "FUSE scenario, budget 10%", 
                                        "FUSE scenario, budget 30%",
                                        "EDGE2 scenario, budget 10%", 
                                        "EDGE2 scenario, budget 30%"))
# 6. Create the plot
iucn_colors <- c(
  "CR" = "#D81E05",
  "EN" = "#FC7F3F",
  "VU" = "#FEC748",
  "NT" = "#58AFFF",
  "LC" = "#38AB38"
)

iucn_order <- c("LC", "NT", "VU", "EN", "CR")

# Modify the plot
rdplot = ggplot(combined_data, 
       aes(x = factor(IUCN_status, levels = iucn_order), 
           y = protection)) +
  geom_violin(aes(fill = IUCN_status, color = IUCN_status), 
              trim = FALSE, 
              alpha = 0.5) +
  geom_jitter(width = 0.1, 
              size = 0.4, 
              alpha = 0.5, 
              color = "darkgray") +
  geom_boxplot(width = 0.1, 
               fill = "white", 
               color = "black", 
               outlier.shape = NA, 
               alpha = 0.8) +
  facet_wrap(~scenario, ncol = 3, nrow= 2, dir = "v") +  # Single column arrangement
  labs(x = "IUCN Red List threat status", 
       y = "Range protected (%)") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5),
    legend.position = "none",
    strip.text = element_text(face = "bold", color = "white"),
    strip.background = element_rect(fill = "black"),
    panel.grid.major.x = element_blank()
  ) +
  scale_x_discrete(limits = iucn_order) +
  scale_fill_manual(values = iucn_colors) +
  scale_color_manual(values = iucn_colors) +
  scale_y_continuous(limits = c(0, 100),
                    breaks = seq(0, 100, 25))
rdplot

# Add white background to the plot
rdplot_white = rdplot + 
  theme(
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "white", color = NA)
  )

# Save only PNG with white background
ggsave(
  filename = here::here("scenarios_IUCN_protection_3cols.png"),
  plot = rdplot_white,
  width = 8,
  height = 5,
  dpi = 300,
  bg = "white"  # This ensures white background in the saved file
)

```

Comparing Protection Gap with Direct Protection Percentages

Two Different Analytical Approaches:

1. **Direct Protection Analysis** (your previous work):
   - Compared the actual percentage of range protected for each species against their IUCN status
   - Found that threatened species (VU, EN, CR) had lower percentages of their ranges protected than non-threatened species (LC, NT)
   - Measures the absolute level of protection

2. **Protection Gap Analysis** (current work):
   - Compares the difference between expected random protection and actual protection
   - Measures whether species are receiving less protection than would be expected by chance
   - Accounts for factors that might make some species naturally harder to protect

Key Differences:

- **Direct Protection** answers: "How much of each species' range is protected?"
- **Protection Gap** answers: "Are some species disproportionately under-protected relative to random expectation?"

The protection gap approach controls for factors like species' range sizes, geographic locations, and overlap with human activities that might affect their likelihood of being included in MPAs.

Which is More Relevant?

**Both analyses are valuable and complementary:**

1. **Direct Protection** is more intuitive and directly relevant to conservation targets (e.g., "30x30" initiatives aiming to protect 30% of the ocean by 2030).

2. **Protection Gap** provides stronger evidence of systematic bias in conservation planning, as it accounts for the "null expectation" of protection if MPAs were established without regard to species identity.

Together, these analyses tell a more complete story: threatened sharks not only have lower absolute protection (direct analysis) but are also receiving less protection than would be expected by random chance (protection gap).

This combined evidence strengthens the case for conservation planning that more explicitly prioritizes threatened shark species.

Interpreting Opposing Patterns in Protection Analyses

Key Finding: Contradictory Protection Patterns

Our two analytical approaches revealed an important paradox in shark conservation:

1. **Direct Protection Analysis** showed that threatened species (VU, EN, CR) have **less absolute protection** than non-threatened species.

2. **Protection Gap Analysis** suggests that threatened species have **smaller protection gaps** than non-threatened species.

What This Contradiction Means:

This apparent contradiction reveals a nuanced conservation situation:

**Threatened sharks receive less overall protection** (in absolute terms), but **what protection they do receive appears more targeted than random chance would predict**.

Possible Interpretations:

1. **Intentional Conservation Targeting:**
   - Conservation efforts may be specifically targeting threatened sharks within their limited ranges
   - Even though the absolute protection is lower, the placement of MPAs may be more strategic for threatened species

2. **Range Size Effect:**
   - Threatened species often have smaller or more restricted ranges
   - Smaller ranges might be easier to protect at higher-than-random rates, even if the absolute area protected remains small

3. **Geographic Concentration:**
   - Threatened sharks may be concentrated in regions where MPAs are more common
   - This would result in better-than-random representation despite lower total protection

Conservation Implications:

This complex pattern suggests that:

1. Current protection is insufficient in absolute terms for threatened species
2. Existing conservation efforts show some evidence of appropriate targeting
3. Expanding protection should build on this targeting while addressing the overall protection shortfall

This highlights the importance of using multiple analytical approaches to fully understand conservation patterns and avoid oversimplified conclusions about protection effectiveness.

### Ridgeline chart : six charts 

```{r}
library(tidyverse)
library(ggridges)

# 1. First prepare the IUCN data and function
prepare_iucn_data <- function(species_data, species_col) {
  IUCN <- readRDS(here::here("Data","GAP analyses","sharks_iucn_final.RDS"))
  IUCN$species <- gsub("_", " ", IUCN$Species)
  
  # Rename the species column in the input data to match
  species_data <- species_data %>%
    dplyr::rename(species = all_of(species_col))
  
  results_IUCN <- left_join(IUCN, species_data, by="species") %>%
    mutate(IUCN_status = case_when(
      iucn_GE == 0 ~ "LC",
      iucn_GE == 1 ~ "NT",
      iucn_GE == 2 ~ "VU",
      iucn_GE == 3 ~ "EN",
      iucn_GE == 4 ~ "CR",
      TRUE ~ "Unknown"
    )) %>%
    filter(IUCN_status != "Unknown")
  
  return(results_IUCN)
}

# 2. Prepare all datasets
mpa_data <- results %>%
  dplyr::select(species, percentage_in_ALL_MPA, percentage_in_NT_MPA) %>%
  dplyr::rename(Species = species)

# 3. Create separate dataframes with IUCN status
# Get only the no-take MPAs data directly
notake_mpa_iucn <- prepare_iucn_data(mpa_data, "Species") %>%
  dplyr::select(species, IUCN_status, percentage_in_NT_MPA) %>%
  rename(protection = percentage_in_NT_MPA)

# 6. Create the plot
iucn_colors <- c(
  "CR" = "#D81E05",
  "EN" = "#FC7F3F",
  "VU" = "#FEC748",
  "NT" = "#58AFFF",
  "LC" = "#38AB38"
)

iucn_order <- c("LC", "NT", "VU", "EN", "CR")

# Modify the plot - now without faceting since we only have one scenario
rdplot = ggplot(notake_mpa_iucn, 
       aes(x = factor(IUCN_status, levels = iucn_order), 
           y = protection)) +
  geom_violin(aes(fill = IUCN_status, color = IUCN_status), 
              trim = FALSE, 
              alpha = 0.5) +
  geom_jitter(width = 0.1, 
              size = 0.4, 
              alpha = 0.5, 
              color = "darkgray") +
  geom_boxplot(width = 0.1, 
               fill = "white", 
               color = "black", 
               outlier.shape = NA, 
               alpha = 0.8) +
  labs(x = "IUCN Red List threat status", 
       y = "Range protected (%)",
       title = "Current no-take MPAs overlaps") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    legend.position = "none",
    panel.grid.major.x = element_blank()
  ) +
  scale_x_discrete(limits = iucn_order) +
  scale_fill_manual(values = iucn_colors) +
  scale_color_manual(values = iucn_colors) +
  scale_y_continuous(limits = c(0, 65),
                    breaks = seq(0, 65, 20))
rdplot

# Add white background to the plot
rdplot_white = rdplot + 
  theme(
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "white", color = NA)
  )

# Save only PNG with white background
ggsave(
  filename = here::here("outputs","notake_mpa_protection.png"),
  plot = rdplot_white,
  width = 6,
  height = 5,
  dpi = 300,
  bg = "white"  # This ensures white background in the saved file
)
```
# Relate to species traits

Relate the percentage of species range overlapped by MPAs to the trait space of species. 1) Use Pearson correlation tests between the axes of the trait space and MPA coverage. 2) Predict relationships from a GAM into the kernel density gridded trait space.

```{r}
# Relate to species traits ----
load(here::here("Data", "GAP analyses", "coords_1005.Rdata"))
load(here::here("Data", "GAP analyses", "grids_commonspecies_corrected_021024.Rdata"))

# Load the necessary library
library(tibble)
# Convert to tibble and add row names as the first column
coords <- tibble::rownames_to_column(coords, var = "Species")

colnames(results)[1]="Species"

results_coords=left_join(coords, results)


library(Hmisc)
library(dplyr)
library(tidyr)

# Calculate correlation matrix with p-values
cor_matrix_with_p <- rcorr(as.matrix(results_coords[, c("A1", "A2", "A3", "percentage_in_ALL_MPA", "percentage_in_NT_MPA")]))

# Extract correlation coefficients and p-values
cor_coefficients <- cor_matrix_with_p$r
p_values <- cor_matrix_with_p$P

# Create a function to format the results
format_cor_p <- function(cor, p) {
  sprintf("%.3f (p = %.3f)", cor, p)
}

# Create a data frame with formatted results
result_df <- data.frame(
  Predictor = c("A1", "A2", "A3"),
  `percentage_in_ALL_MPA` = format_cor_p(cor_coefficients["percentage_in_ALL_MPA", c("A1", "A2", "A3")], 
                                         p_values["percentage_in_ALL_MPA", c("A1", "A2", "A3")]),
  `percentage_in_NT_MPA` = format_cor_p(cor_coefficients["percentage_in_NT_MPA", c("A1", "A2", "A3")], 
                                        p_values["percentage_in_NT_MPA", c("A1", "A2", "A3")])
)

library(knitr)
library(kableExtra)

format_correlation_table <- function(result_df) {
  kable(result_df, format = "html", escape = FALSE,
        col.names = c("Predictor", "ALL MPA", "NT MPA"),
        caption = "Pearson Correlation Results") %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"),
                  full_width = FALSE) %>%
    column_spec(1, bold = TRUE) %>%
    add_header_above(c(" " = 1, "Percentage in MPA" = 2)) %>%
    footnote(general = "Values shown as: correlation coefficient (p-value)",
             general_title = "Note:")
}

# Usage:
formatted_table <- format_correlation_table(result_df)
formatted_table

library(gridExtra)

# Scatter plot for A1 vs percentage in ALL MPA
plot_A1 <- ggplot(results_coords, aes(x = A1, y = percentage_in_ALL_MPA)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "lm", color = "red", se = TRUE) +
  theme_minimal() +
  labs(title = "A1 vs Percentage in ALL MPA",
       x = "A1",
       y = "Percentage in ALL MPA")

# Scatter plot for A2 vs percentage in ALL MPA
plot_A2 <- ggplot(results_coords, aes(x = A2, y = percentage_in_ALL_MPA)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "lm", color = "blue", se = TRUE) +
  theme_minimal() +
  labs(title = "A2 vs Percentage in ALL MPA",
       x = "A2",
       y = "Percentage in ALL MPA")

# Set a common aspect ratio for both plots
plot_A1 <- plot_A1 + theme(aspect.ratio = 1)
plot_A2 <- plot_A2 + theme(aspect.ratio = 1)

# Create the combined plot
combined_plot <- grid.arrange(plot_A1, plot_A2, ncol = 2)
#Create kernel density of the trait space 
# Load required packages
library(BAT)

# Assuming 'coords' is your dataframe
# Extract the first two columns (A1 and A2)
load(here::here("Data", "GAP analyses", "coords_1005.Rdata"))
trait_space <- coords[, 1:2]
sp_df=grids.fd_new

# Get the species names from the trait space
trait_species <- rownames(coords)

# Subset the sp_df to keep only the columns (species) found in the trait space
sp_df_filtered <- sp_df[, colnames(sp_df) %in% trait_species]

# Replace all NA values with 0
sp_df_filtered[is.na(sp_df_filtered)] <- 0

# Create a global community matrix
global_comm <- matrix(1, nrow = 1, ncol = ncol(sp_df_filtered))
colnames(global_comm) <- colnames(sp_df_filtered)
rownames(global_comm) <- "global"

global_kernel <- 
  BAT::kernel.build(comm = global_comm, 
                    trait = trait_space,
                    method = "gaussian")

# Extract coordinates (trait values)
trait_coords <- global_kernel@Data

# Extract random points and their corresponding density values
random_points <- global_kernel@RandomPoints
density_values <- global_kernel@ValueAtRandomPoints

# Create a data frame for the density plot
plot_data <- data.frame(
  A1 = random_points[,1],
  A2 = random_points[,2],
  Density = density_values
)

# Create a data frame for the original trait points
trait_data <- data.frame(
  A1 = trait_coords[,1],
  A2 = trait_coords[,2]
)

#Build the GAM 
library(mgcv)
library(dplyr)

# Prepare data for GAM
gam_data <- results_coords %>%
  dplyr::select(Species, A1, A2, percentage_in_ALL_MPA) %>%
  filter(!is.na(percentage_in_ALL_MPA))  # Remove any rows with NA in the response variable

# Build GAM
gam_model <- gam(percentage_in_ALL_MPA ~ s(A1, A2), data = gam_data, method = "REML")
summary(gam_model)

# Make predictions
plot_data$predicted <- predict(gam_model, newdata = plot_data, type = "response")

library(ggplot2)
library(viridis)
# Plot predictions
gam_plot <- ggplot() +
  geom_point(data = plot_data, aes(x = A1, y = A2, color = predicted), alpha = 0.5) +
  #geom_point(data = gam_data, aes(x = A1, y = A2), color = "red", size = 2) +
  scale_color_viridis_c(name = "Predicted % MPA Coverage") +
  theme_minimal() +
  labs(title = "GAM Predictions: Percentage in ALL MPA",
       x = "Trait Axis 1",
       y = "Trait Axis 2")

print(gam_plot)

# Create a smoother surface plot
# Create custom breaks at 10% intervals
custom_breaks <- seq(0, 100, by = 10)

# Custom colors for each 10% increment
custom_colors <- c(
  "#440154", # 0-10%
  "#414487", # 10-20%
  "#2A788E", # 20-30%
  "#22A884", # 30-40%
  "#7AD151", # 40-50%
  "#FDE725", # 50-60%
  "#FCA50A", # 60-70%
  "#F47B07", # 70-80%
  "#E85110", # 80-90%
  "#DC2F1F"  # 90-100%
)

gam_density_plot_GAP_all_MPAs <- ggplot(plot_data, aes(x = A1, y = A2, z = predicted)) +
  stat_summary_2d(fun = mean, bins = 50) +
  scale_fill_gradientn(
    name = "MPA Coverage (%)",
    colors = custom_colors,
    breaks = custom_breaks,
    limits = c(0, 100),
    oob = scales::squish
  ) +
  theme_minimal() +
  labs(title = "GAM Predictions: Percentage in ALL MPA",
       x = "Trait Axis 1",
       y = "Trait Axis 2")

print(gam_density_plot_GAP_all_MPAs)
```

**Key message:** There is a significant, relationship between the percentage of the range of sharks and rays covered by MPAs and axis 1 & 2 of the trait space. Species located in the bottom right corner of the trait space tend to be more protected, this relationship is highly significant, however, very week (R2 = 0.04, p \< 0.001).

## Relate to CAPTAIN protect fraction : FUSE 0.3

```{r}
# Read the data
combined_protection_FUSE_03 <- readRDS(here::here("Data", "combined_protection_FUSE_03.rds"))
combined_protection_FUSE_01 <- readRDS(here::here("Data", "combined_protection_FUSE_01.rds"))

# Load and prepare data
load(here::here("Data", "GAP analyses", "coords_1005.Rdata"))
load(here::here("Data", "GAP analyses", "grids_commonspecies_corrected_021024.Rdata"))

# Convert to tibble and add row names as the first column
coords <- tibble::rownames_to_column(coords, var = "Species")

# Merge with FUSE data
library(dplyr)
results_coords <- left_join(coords, combined_protection_FUSE_01, by = "Species") %>%
  rename(FUSE_01_protection = weighted_protection) %>%
  left_join(combined_protection_FUSE_03, by = "Species") %>%
  rename(FUSE_03_protection = weighted_protection)

# Calculate correlation matrix
cor_matrix_with_p <- rcorr(as.matrix(results_coords[, c("A1", "A2", "A3", "FUSE_03_protection", "FUSE_01_protection")]))

# Extract correlation coefficients and p-values
cor_coefficients <- cor_matrix_with_p$r
p_values <- cor_matrix_with_p$P

# Format results
format_cor_p <- function(cor, p) {
  sprintf("%.3f (p = %.3f)", cor, p)
}

result_df <- data.frame(
  Predictor = c("A1", "A2", "A3"),
  `FUSE_03_protection` = format_cor_p(cor_coefficients["FUSE_03_protection", c("A1", "A2", "A3")], 
                                     p_values["FUSE_03_protection", c("A1", "A2", "A3")]),
  `FUSE_01_protection` = format_cor_p(cor_coefficients["FUSE_01_protection", c("A1", "A2", "A3")], 
                                     p_values["FUSE_01_protection", c("A1", "A2", "A3")])
)

# Format table
format_correlation_table <- function(result_df) {
  kable(result_df, format = "html", escape = FALSE,
        col.names = c("Predictor", "FUSE 03", "FUSE 01"),
        caption = "Pearson Correlation Results") %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"),
                  full_width = FALSE) %>%
    column_spec(1, bold = TRUE) %>%
    add_header_above(c(" " = 1, "Weighted Protection" = 2)) %>%
    footnote(general = "Values shown as: correlation coefficient (p-value)",
             general_title = "Note:")
}

formatted_table <- format_correlation_table(result_df)
formatted_table

# Scatter plots
# FUSE 03
plot_A1 <- ggplot(results_coords, aes(x = A1, y = FUSE_03_protection)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "lm", color = "red", se = TRUE) +
  theme_minimal() +
  labs(title = "A1 vs FUSE 03 Protection",
       x = "A1",
       y = "FUSE 03 Protection")

plot_A2 <- ggplot(results_coords, aes(x = A2, y = FUSE_03_protection)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "lm", color = "blue", se = TRUE) +
  theme_minimal() +
  labs(title = "A2 vs FUSE 03 Protection",
       x = "A2",
       y = "FUSE 03 Protection")

plot_A1 <- plot_A1 + theme(aspect.ratio = 1)
plot_A2 <- plot_A2 + theme(aspect.ratio = 1)

combined_plot_FUSE_03 <- grid.arrange(plot_A1, plot_A2, ncol = 2)

# FUSE 01
plot_A1 <- ggplot(results_coords, aes(x = A1, y = FUSE_01_protection)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "lm", color = "red", se = TRUE) +
  theme_minimal() +
  labs(title = "A1 vs FUSE 01 Protection",
       x = "A1",
       y = "FUSE 01 Protection")

plot_A2 <- ggplot(results_coords, aes(x = A2, y = FUSE_01_protection)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "lm", color = "blue", se = TRUE) +
  theme_minimal() +
  labs(title = "A2 vs FUSE 01 Protection",
       x = "A2",
       y = "FUSE 01 Protection")

plot_A1 <- plot_A1 + theme(aspect.ratio = 1)
plot_A2 <- plot_A2 + theme(aspect.ratio = 1)

combined_plot_FUSE_01 <- grid.arrange(plot_A1, plot_A2, ncol = 2)

# Now proceed with GAM analysis: FUSE 03
gam_data <- results_coords %>%
  dplyr::select(Species, A1, A2, FUSE_03_protection) %>%
  filter(!is.na(FUSE_03_protection))

gam_model <- gam(FUSE_03_protection ~ s(A1, A2), data = gam_data, method = "REML")
summary(gam_model)

# Make predictions and plot
plot_data$predicted_FUSE_03 <- predict(gam_model, newdata = plot_data, type = "response")

# Create the plots
gam_plot <- ggplot() +
  geom_point(data = plot_data, aes(x = A1, y = A2, color = predicted_FUSE_03), alpha = 0.5) +
  scale_color_viridis_c(name = "Predicted FUSE 03 Protection") +
  theme_minimal() +
  labs(title = "GAM Predictions: FUSE 03 Protection",
       x = "Trait Axis 1",
       y = "Trait Axis 2")

print(gam_plot)

# Create custom breaks at 10% intervals
custom_breaks <- seq(0, 100, by = 10)

# Custom colors for each 10% increment
custom_colors <- c(
  "#440154", # 0-10%
  "#414487", # 10-20%
  "#2A788E", # 20-30%
  "#22A884", # 30-40%
  "#7AD151", # 40-50%
  "#FDE725", # 50-60%
  "#FCA50A", # 60-70%
  "#F47B07", # 70-80%
  "#E85110", # 80-90%
  "#DC2F1F"  # 90-100%
)

gam_density_plot_FUSE_03 <- ggplot(plot_data, aes(x = A1, y = A2, z = predicted_FUSE_03*100)) +
  stat_summary_2d(fun = mean, bins = 50) +
  scale_fill_gradientn(
    name = "Protection (%)",
    colors = custom_colors,
    breaks = custom_breaks,
    limits = c(0, 100),
    oob = scales::squish
  ) +
  theme_minimal() +
  labs(title = "GAM Predictions: FUSE 03 Protection",
       x = "Trait Axis 1",
       y = "Trait Axis 2")

print(gam_density_plot_FUSE_03)

# Now proceed with GAM analysis: FUSE 01
gam_data <- results_coords %>%
  dplyr::select(Species, A1, A2, FUSE_01_protection) %>%
  filter(!is.na(FUSE_01_protection))

gam_model <- gam(FUSE_01_protection ~ s(A1, A2), data = gam_data, method = "REML")
summary(gam_model)

# Make predictions and plot
plot_data$predicted_FUSE_01 <- predict(gam_model, newdata = plot_data, type = "response")

# Create the plots
gam_plot <- ggplot() +
  geom_point(data = plot_data, aes(x = A1, y = A2, color = predicted_FUSE_01), alpha = 0.5) +
  scale_color_viridis_c(name = "Predicted FUSE 01 Protection", limits= c(0,1)) +
  theme_minimal() +
  labs(title = "GAM Predictions: FUSE 01 Protection",
       x = "Trait Axis 1",
       y = "Trait Axis 2")

print(gam_plot)

# Create custom breaks at 10% intervals
custom_breaks <- seq(0, 100, by = 10)

# Create custom colors for each 10% increment
custom_colors <- c(
  "#440154", # 0-10%
  "#414487", # 10-20%
  "#2A788E", # 20-30%
  "#22A884", # 30-40%
  "#7AD151", # 40-50%
  "#FDE725", # 50-60%
  "#FCA50A", # 60-70%
  "#F47B07", # 70-80%
  "#E85110", # 80-90%
  "#DC2F1F"  # 90-100%
)

gam_density_plot_FUSE_01 <- ggplot(plot_data, aes(x = A1, y = A2, z = predicted_FUSE_01*100)) +
  stat_summary_2d(fun = mean, bins = 50) +
  scale_fill_gradientn(
    name = "Protection (%)",
    colors = custom_colors,
    breaks = custom_breaks,
    limits = c(0, 100),
    oob = scales::squish
  ) +
  theme_minimal() +
  labs(title = "GAM Predictions: FUSE 01 Protection",
       x = "Trait Axis 1",
       y = "Trait Axis 2")

print(gam_density_plot_FUSE_01)

```

### Combine three FD spaces in a grid

```{r}
# Create breaks at 10% increments
custom_breaks <- seq(0, 70, by = 10)  # Now in percentages

# Same custom colors
custom_colors <- c(
  "#440154", # Dark purple
  "#414487", 
  "#2A788E", 
  "#22A884", 
  "#7AD151", 
  "#FDE725", 
  "#FCA50A", 
  "#F47B07", 
  "#E85110", 
  "#DC2F1F"  # Dark red
)

# Common theme to remove individual legends
no_legend_theme <- theme_minimal() +
  theme(legend.position = "none")

# Theme for the middle plot with modified legend
middle_plot_theme <- theme_minimal() +
  theme(
    legend.position = "right",
    legend.key.height = unit(1, "cm"),  # Make legend longer
    legend.key.width = unit(0.6, "cm"),   # Make legend wider
    legend.title = element_text(size = 12)
  )

# Update each plot with percentage values, no titles, and no individual legends
gam_density_plot_GAP_all_MPAs <- ggplot(plot_data, aes(x = A1, y = A2, z = predicted)) +
  stat_summary_2d(fun = mean, bins = 50) +
  scale_fill_gradientn(
    name = "Range protected (%)",
    colors = custom_colors,
    breaks = custom_breaks,
    limits = c(0, 70),
    oob = scales::squish
  ) +
  no_legend_theme +
  labs(x = "Trait Axis 1",
       y = "Trait Axis 2")

gam_density_plot_FUSE_01 <- ggplot(plot_data, aes(x = A1, y = A2, z = predicted_FUSE_01 * 100)) +
  stat_summary_2d(fun = mean, bins = 50) +
  scale_fill_gradientn(
    name = "Range protected (%)",
    colors = custom_colors,
    breaks = custom_breaks,
    limits = c(0, 70),
    oob = scales::squish
  ) +
  middle_plot_theme +  # Apply the modified theme with larger legend
  labs(x = "Trait Axis 1",
       y = "Trait Axis 2")

gam_density_plot_FUSE_03 <- ggplot(plot_data, aes(x = A1, y = A2, z = predicted_FUSE_03 * 100)) +
  stat_summary_2d(fun = mean, bins = 50) +
  scale_fill_gradientn(
    name = "",
    colors = custom_colors,
    breaks = custom_breaks,
    limits = c(0, 70),
    oob = scales::squish
  ) +
  no_legend_theme +
  labs(x = "Trait Axis 1",
       y = "Trait Axis 2")

# Combine plots
library(patchwork)

# Combine plots
combined_plot <- (gam_density_plot_GAP_all_MPAs / 
                 gam_density_plot_FUSE_01 / 
                 gam_density_plot_FUSE_03) +
  plot_annotation(tag_levels = 'A') +
  plot_layout(ncol = 1)

print(combined_plot)

# Save the combined plot
ggsave(here::here("combined_functional_spaces_with_predictions.png"), combined_plot, width = 8*0.9, height = 18*0.8, units = "in")
```

# Relate to phylogeny : GAP analysis results

Relate the percentage of species range overlapped by MPAs to the phylogenetic tree of species, with tests of phylogenetic signal and plots of trees with the variable mapped onto the tree.

```{r}
# Relate to phylogeny ----

# For percentage range in ALL MPAs 
library(phytools)
library(here)
library(dplyr)
library(purrr)
library(ape)
library(stringr)

# Load the list of trees
load(here::here("Data", "GAP analyses", "list_tree_sharks_p.Rdata"))

# Function to modify species names
modify_species_name <- function(name) {
  str_replace(name, " ", "_")
}

# Modify species names in the results dataframe
results_IUCN_filtered <- results_IUCN_filtered %>%
  mutate(species_modified = modify_species_name(species))

compute_phylo_signal <- function(tree, data) {
  # Ensure the data is in the same order as the tree tips and remove NAs
  matched_data <- data %>%
    filter(species_modified %in% tree$tip.label) %>%
    filter(!is.na(percentage_in_ALL_MPA)) %>%
    arrange(match(species_modified, tree$tip.label))
  
  n_species_after_matching <- nrow(matched_data)
  
  # Prune the tree to match the available data
  pruned_tree <- keep.tip(tree, matched_data$species_modified)
  
  n_tips_pruned_tree <- length(pruned_tree$tip.label)
  
  # Compute phylogenetic signal using Pagel's lambda, capturing any output
  signal <- tryCatch({
    captured_output <- capture.output({
      result <- phylosig(pruned_tree, matched_data$percentage_in_ALL_MPA, method = "lambda", test = TRUE)
    })
    result$captured_output <- captured_output
    result
  }, error = function(e) {
    error_message <- paste("Error in phylosig:", e$message)
    return(list(lambda = NA, P = NA, error = error_message, captured_output = NA))
  })
  
  # Return all information
  return(list(
    lambda = signal$lambda,
    p_value = signal$P,
    n_species = n_species_after_matching,
    n_tips_pruned_tree = n_tips_pruned_tree,
    error = if(!is.null(signal$error)) signal$error else NA,
    captured_output = paste(signal$captured_output, collapse = "\n")
  ))
}

# Apply the function to all trees: using the first two only for the moment to save time
results <- map_dfr(list_tree_sharks_p[1:2], ~compute_phylo_signal(.x, results_IUCN_filtered), .id = "tree")

# Now, create the kable separately
library(knitr)
library(dplyr)
library(kableExtra)

results %>%
  select(1:4) %>%
  kable(caption = "Phylogenetic Signal Results for all MPAs",
        col.names = c("Tree", "Lambda", "P-value", "Number of Species"),
        digits = 3,
        align = c('l', 'c', 'c', 'c')) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))

# Compute summary statistics
summary_stats <- results %>%
  summarise(
    mean_lambda = mean(lambda, na.rm = TRUE),
    median_lambda = median(lambda, na.rm = TRUE),
    sd_lambda = sd(lambda, na.rm = TRUE),
    mean_p = mean(p_value, na.rm = TRUE),
    median_p = median(p_value, na.rm = TRUE),
    sd_p = sd(p_value, na.rm = TRUE),
    mean_n_species = mean(n_species, na.rm = TRUE),
    min_n_species = min(n_species, na.rm = TRUE),
    max_n_species = max(n_species, na.rm = TRUE)
  )

#print(summary_stats)

# For percentage range in no-take MPAs 
library(phytools)
library(here)
library(dplyr)
library(purrr)
library(ape)
library(stringr)

# Load the list of trees
load(here::here("Data", "GAP analyses", "list_tree_sharks_p.Rdata"))

# Function to modify species names
modify_species_name <- function(name) {
  str_replace(name, " ", "_")
}

# Modify species names in the results dataframe
results_IUCN_filtered <- results_IUCN_filtered %>%
  mutate(species_modified = modify_species_name(species))

compute_phylo_signal <- function(tree, data) {
  # Ensure the data is in the same order as the tree tips and remove NAs
  matched_data <- data %>%
    filter(species_modified %in% tree$tip.label) %>%
    filter(!is.na(percentage_in_NT_MPA)) %>%
    arrange(match(species_modified, tree$tip.label))
  
  n_species_after_matching <- nrow(matched_data)
  
  # Prune the tree to match the available data
  pruned_tree <- keep.tip(tree, matched_data$species_modified)
  
  n_tips_pruned_tree <- length(pruned_tree$tip.label)
  
  # Compute phylogenetic signal using Pagel's lambda, capturing any output
  signal <- tryCatch({
    captured_output <- capture.output({
      result <- phylosig(pruned_tree, matched_data$percentage_in_NT_MPA, method = "lambda", test = TRUE)
    })
    result$captured_output <- captured_output
    result
  }, error = function(e) {
    error_message <- paste("Error in phylosig:", e$message)
    return(list(lambda = NA, P = NA, error = error_message, captured_output = NA))
  })
  
  # Return all information
  return(list(
    lambda = signal$lambda,
    p_value = signal$P,
    n_species = n_species_after_matching,
    n_tips_pruned_tree = n_tips_pruned_tree,
    error = if(!is.null(signal$error)) signal$error else NA,
    captured_output = paste(signal$captured_output, collapse = "\n")
  ))
}

# Apply the function to all trees: use only the first two trees for the moment to save time
results <- map_dfr(list_tree_sharks_p[1:2], ~compute_phylo_signal(.x, results_IUCN_filtered), .id = "tree")

# Now, create the kable separately
library(knitr)
library(dplyr)
library(kableExtra)

results %>%
  select(1:4) %>%
  kable(caption = "Phylogenetic Signal Results for no-take MPAs",
        col.names = c("Tree", "Lambda", "P-value", "Number of Species"),
        digits = 3,
        align = c('l', 'c', 'c', 'c')) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))

# Compute summary statistics
summary_stats <- results %>%
  summarise(
    mean_lambda = mean(lambda, na.rm = TRUE),
    median_lambda = median(lambda, na.rm = TRUE),
    sd_lambda = sd(lambda, na.rm = TRUE),
    mean_p = mean(p_value, na.rm = TRUE),
    median_p = median(p_value, na.rm = TRUE),
    sd_p = sd(p_value, na.rm = TRUE),
    mean_n_species = mean(n_species, na.rm = TRUE),
    min_n_species = min(n_species, na.rm = TRUE),
    max_n_species = max(n_species, na.rm = TRUE)
  )

#print(summary_stats)


#Plot the tree with color gradient on terminal branches 
library(ggtree)
library(ggplot2)
library(dplyr)
library(RColorBrewer)
library(tidytree)

# Function to get a color palette
get_color_palette <- function(n) {
  colorRampPalette(brewer.pal(9, "YlGnBu"))(n)  # Changed to YlGnBu
}

# All MPAs 
# Function to plot the circular tree
plot_circular_colored_tree <- function(tree, data) {
  # Ensure the data is in the same order as the tree tips and remove NAs
  matched_data <- data %>%
    filter(species_modified %in% tree$tip.label) %>%
    filter(!is.na(percentage_in_ALL_MPA)) %>%
    arrange(match(species_modified, tree$tip.label))
  
  # Print summary of percentage_in_ALL_MPA for debugging
  #print(summary(matched_data$percentage_in_ALL_MPA))
  
  # Prune the tree to match the available data
  pruned_tree <- ape::keep.tip(tree, matched_data$species_modified)
  
  # Create color palette
  n_colors <- 100
  color_palette <- get_color_palette(n_colors)
  
  # Convert tree to tidy format and add percentage data
  tree_data <- as_tibble(pruned_tree) %>%
    left_join(matched_data, by = c("label" = "species_modified"))
  
  # Plot the circular tree
  p <- ggtree(pruned_tree, layout="circular", aes(color=percentage_in_ALL_MPA), size =0.3) %<+% tree_data
  
  # Color the branches
  p <- p + 
    scale_color_gradientn(colours = color_palette, 
                          name = "% Range within all MPAs",
                          limits = c(0, 100),
                          na.value = "grey50") +
    theme(legend.position = "right")
  
  # Remove default labels and add a title
  p <- p + theme(plot.title = element_text(hjust = 0.5)) 
  
  return(p)
}

# Plot the first tree
tree_plot_ALL <- plot_circular_colored_tree(list_tree_sharks_p[[1]], results_IUCN_filtered)

# Display the plot
print(tree_plot_ALL)

# No-take MPAs 
# Function to plot the circular tree
plot_circular_colored_tree <- function(tree, data) {
  # Ensure the data is in the same order as the tree tips and remove NAs
  matched_data <- data %>%
    filter(species_modified %in% tree$tip.label) %>%
    filter(!is.na(percentage_in_NT_MPA)) %>%
    arrange(match(species_modified, tree$tip.label))
  
  # Print summary of percentage_in_ALL_MPA for debugging
  #print(summary(matched_data$percentage_in_NT_MPA))
  
  # Prune the tree to match the available data
  pruned_tree <- ape::keep.tip(tree, matched_data$species_modified)
  
  # Create color palette
  n_colors <- 100
  color_palette <- get_color_palette(n_colors)
  
  # Convert tree to tidy format and add percentage data
  tree_data <- as_tibble(pruned_tree) %>%
    left_join(matched_data, by = c("label" = "species_modified"))
  
  # Plot the circular tree
  p <- ggtree(pruned_tree, layout="circular", aes(color=percentage_in_NT_MPA), size =0.3) %<+% tree_data
  
  # Color the branches
  p <- p + 
    scale_color_gradientn(colours = color_palette, 
                          name = "% Range within no-take MPAs",
                          limits = c(0, 100),
                          na.value = "grey50") +
    theme(legend.position = "right")
  
  # Remove default labels and add a title
  p <- p + theme(plot.title = element_text(hjust = 0.5)) 
  
  return(p)
}

# Plot the first tree
tree_plot_NT <- plot_circular_colored_tree(list_tree_sharks_p[[1]], results_IUCN_filtered)

# Display the plot
print(tree_plot_NT)

#ggpubr::ggarrange(tree_plot_ALL, tree_plot_NT, common.legend = T, legend = "bottom")
```

**Key message:** There are significant phylogenetic signals with the percentage of MPA coverage for all MPAs (lambda= 0.12-0.17; \< 0.05), and for no-take MPAs, this relationship is almost significant (lambda = 0.04; 0.08 \> p \> 0.05). However, patterns are not obvious on the trees. Analyses were ran for two trees only but can be replicated to all 100 trees.

### Combine all trees in a single one : GAP analysis only

```{r}
library(tibble)
plot_combined_circular_tree <- function(tree, data) {
  library(ggplot2)
  library(ggtree)
  
  # Ensure the data is in the same order as the tree tips
  matched_data <- data %>%
    filter(species_modified %in% tree$tip.label) %>%
    arrange(match(species_modified, tree$tip.label))
  
  # Create a data frame specifically for the heatmap
  # Reordering columns to put no-take MPAs first
  heatmap_data <- matched_data %>%
    select(species_modified, percentage_in_NT_MPA, percentage_in_ALL_MPA) %>%  # Reordered columns
    # Convert to numeric explicitly to avoid any type issues
    mutate(
      percentage_in_NT_MPA = as.numeric(percentage_in_NT_MPA),
      percentage_in_ALL_MPA = as.numeric(percentage_in_ALL_MPA)
    )
  
  # Set row names manually
  heatmap_matrix <- as.matrix(heatmap_data[, -1])  # Remove species column and convert to matrix
  rownames(heatmap_matrix) <- heatmap_data$species_modified  # Set the row names
  
  # Prune the tree to match the available data
  pruned_tree <- ape::keep.tip(tree, rownames(heatmap_matrix))
  
  # Create color palette
  n_colors <- 100
  color_palette <- get_color_palette(n_colors)
  
  # Base circular tree plot with light grey for tree lines
  p <- ggtree(pruned_tree, layout="circular", size=0.3, color="lightgrey")
  
  # Add heatmap rings without column names
  p <- gheatmap(p, heatmap_matrix, 
                width=0.2,
                offset=0.1, 
                colnames=FALSE,  # No column names
                font.size=3) + 
    scale_fill_gradientn(
      colours=color_palette, 
      name="Range Coverage (%)",
      limits=c(0, 100),
      na.value="grey80",
      oob=scales::squish
    )
  
  # No title as requested
  p <- p + theme(
    plot.margin = margin(t=10, r=10, b=10, l=10, unit="pt")  # Keep some margin for readability
  )
  
  return(p)
}

#Call the function to create the plot
combined_tree_plot <- plot_combined_circular_tree(list_tree_sharks_p[[1]], results_IUCN_filtered)

# Display the plot
combined_tree_plot
# or
print(combined_tree_plot)

# Alternative with geom_fruit()
library(ggtree)
library(ggnewscale)
library(dplyr)
library(ggtreeExtra)

plot_dual_ring_tree <- function(tree, data) {
  # Make a copy of the data to avoid modifying the original
  plot_data <- data %>%
    filter(species_modified %in% tree$tip.label)
  
  # Check if we have any valid data
  if(all(is.na(plot_data$percentage_in_ALL_MPA)) && all(is.na(plot_data$percentage_in_NT_MPA))) {
    stop("No valid percentage data available for visualization")
  }
  
  # Convert percentage columns to numeric if they aren't already
  plot_data$percentage_in_ALL_MPA <- as.numeric(plot_data$percentage_in_ALL_MPA)
  plot_data$percentage_in_NT_MPA <- as.numeric(plot_data$percentage_in_NT_MPA)
  
  # Prune the tree to match the available data
  pruned_tree <- ape::keep.tip(tree, plot_data$species_modified)
  
  # Create color palette
  n_colors <- 100
  color_palette <- get_color_palette(n_colors)
  
  # Create the base tree
  p <- ggtree(pruned_tree, layout="circular", size=0.3)
  
  # Debug information
  cat("Number of species in tree:", length(pruned_tree$tip.label), "\n")
  cat("Number of species in data:", nrow(plot_data), "\n")
  cat("ALL MPA data range:", range(plot_data$percentage_in_ALL_MPA, na.rm=TRUE), "\n")
  cat("NT MPA data range:", range(plot_data$percentage_in_NT_MPA, na.rm=TRUE), "\n")
  
  # Add first ring for ALL MPAs (only if we have valid data)
  if(!all(is.na(plot_data$percentage_in_ALL_MPA))) {
    p <- p + 
      geom_fruit(
        data=plot_data,
        geom=geom_col,
        mapping=aes(y=species_modified, x=percentage_in_ALL_MPA, fill=percentage_in_ALL_MPA),
        orientation="y",
        offset=0.1,
        width=0.08,
        pwidth=0.3,
        axis.params=list(axis="x", text.size=2, vjust=0.5, hjust=1)
      ) + 
      scale_fill_gradientn(
        colors=color_palette,
        name="% Range in\nAll MPAs",
        limits=c(0, 100),
        na.value="grey80",
        oob=scales::squish
      )
  }
  
  # Add second ring for NT MPAs (only if we have valid data)
  if(!all(is.na(plot_data$percentage_in_NT_MPA))) {
    p <- p + 
      new_scale_fill() +
      geom_fruit(
        data=plot_data,
        geom=geom_col,
        mapping=aes(y=species_modified, x=percentage_in_NT_MPA, fill=percentage_in_NT_MPA),
        orientation="y",
        offset=0.25,
        width=0.08,
        pwidth=0.3,
        axis.params=list(axis="x", text.size=2, vjust=0.5, hjust=1)
      ) + 
      scale_fill_gradientn(
        colors=color_palette,
        name="% Range in\nNo-Take MPAs",
        limits=c(0, 100),
        na.value="grey80",
        oob=scales::squish
      )
  }
  
  # Add title
  p <- p + 
    ggtitle("Phylogenetic Distribution of MPA Coverage") +
    theme(plot.title = element_text(hjust=0.5, size=14))
  
  return(p)
}

# Plot the modified version
dual_ring_tree <- plot_dual_ring_tree(list_tree_sharks_p[[1]], results_IUCN_filtered)
```

## Relate to phylogeny : CAPTAIN results

Relate the protected fraction of species ranges to the phylogenetic tree of species, with tests of phylogenetic signal and plots of trees with the variable mapped onto the tree.

```{r}
library(phytools)
library(here)
library(dplyr)
library(purrr)
library(ape)
library(stringr)

# Load the list of trees
load(here::here("Data", "GAP analyses", "list_tree_sharks_p.Rdata"))

# Function to modify species names
modify_species_name <- function(name) {
  str_replace(name, " ", "_")
}

# Modify species names in the EDGE dataframes
combined_protection_EDGE_03 <- combined_protection_EDGE_03 %>%
  mutate(species_modified = modify_species_name(species_name))

combined_protection_EDGE_01 <- combined_protection_EDGE_01 %>%
  mutate(species_modified = modify_species_name(species_name))

# Function to compute phylogenetic signal for EDGE_03
compute_phylo_signal_03 <- function(tree, data) {
  # Match data and remove NAs
  matched_data <- data %>%
    filter(species_modified %in% tree$tip.label) %>%
    filter(!is.na(weighted_protection)) %>%
    arrange(match(species_modified, tree$tip.label))
  
  n_species_after_matching <- nrow(matched_data)
  
  # Prune tree
  pruned_tree <- keep.tip(tree, matched_data$species_modified)
  
  n_tips_pruned_tree <- length(pruned_tree$tip.label)
  
  # Compute phylogenetic signal
  signal <- tryCatch({
    captured_output <- capture.output({
      result <- phylosig(pruned_tree, matched_data$weighted_protection, method = "lambda", test = TRUE)
    })
    result$captured_output <- captured_output
    result
  }, error = function(e) {
    return(list(lambda = NA, P = NA, error = e$message, captured_output = NA))
  })
  
  return(list(
    lambda = signal$lambda,
    p_value = signal$P,
    n_species = n_species_after_matching,
    n_tips_pruned_tree = n_tips_pruned_tree,
    error = if(!is.null(signal$error)) signal$error else NA,
    captured_output = paste(signal$captured_output, collapse = "\n")
  ))
}

# Apply function to trees for EDGE_03
results_03 <- map_dfr(list_tree_sharks_p[1:2], ~compute_phylo_signal_03(.x, combined_protection_EDGE_03), .id = "tree")

# Function to format p-values (vectorized version)
format_p_value <- function(p) {
  sapply(p, function(x) {
    if (is.na(x)) return(NA)
    if (x < 0.001) return("p < 0.001")
    if (x < 0.01) return(sprintf("p = %.3f", x))
    return(sprintf("p = %.3f", x))
  })
}

# Create table for EDGE_03 results with formatted p-values
results_03 %>%
  dplyr::select(1:4) %>%
  mutate(p_value = format_p_value(p_value)) %>%
  kable(caption = "Phylogenetic Signal Results for EDGE_03 Protection",
        col.names = c("Tree", "Lambda", "P-value", "Number of Species"),
        digits = 3,
        align = c('l', 'c', 'c', 'c')) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))

# Repeat for EDGE_01
results_01 <- map_dfr(list_tree_sharks_p[1:2], ~compute_phylo_signal_03(.x, combined_protection_EDGE_01), .id = "tree")

results_01 %>%
  dplyr::select(1:4) %>%
  mutate(p_value = format_p_value(p_value)) %>%
  kable(caption = "Phylogenetic Signal Results for EDGE_03 Protection",
        col.names = c("Tree", "Lambda", "P-value", "Number of Species"),
        digits = 3,
        align = c('l', 'c', 'c', 'c')) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))

# Plot circular trees
library(ggtree)
library(ggplot2)
library(RColorBrewer)
library(tidytree)

# Function to get color palette
get_color_palette <- function(n) {
  colorRampPalette(brewer.pal(9, "YlGnBu"))(n)
}

# Function to plot circular tree
plot_circular_colored_tree_EDGE <- function(tree, data) {
  matched_data <- data %>%
    filter(species_modified %in% tree$tip.label) %>%
    filter(!is.na(weighted_protection)) %>%
    arrange(match(species_modified, tree$tip.label))
  
  pruned_tree <- ape::keep.tip(tree, matched_data$species_modified)
  
  n_colors <- 100
  color_palette <- get_color_palette(n_colors)
  
  tree_data <- as_tibble(pruned_tree) %>%
    left_join(matched_data, by = c("label" = "species_modified"))
  
  p <- ggtree(pruned_tree, layout="circular", aes(color=weighted_protection), size=0.3) %<+% tree_data
  
  p <- p + 
    scale_color_gradientn(colours = color_palette, 
                         name = "Weighted Protection",
                         na.value = "grey50", limits = c(0,1)) +
    theme(legend.position = "right",
          plot.title = element_text(hjust = 0.5))
  
  return(p)
}

# Plot trees for both EDGE_03 and EDGE_01
tree_plot_03 <- plot_circular_colored_tree_EDGE(list_tree_sharks_p[[1]], combined_protection_EDGE_03)
print(tree_plot_03)

tree_plot_01 <- plot_circular_colored_tree_EDGE(list_tree_sharks_p[[1]], combined_protection_EDGE_01)
print(tree_plot_01)

#Identify clades with higher prioritisation 
# Modified function with improved visualization
plot_and_analyze_clades <- function(tree, data, title = "") {
  matched_data <- data %>%
    filter(species_modified %in% tree$tip.label) %>%
    filter(!is.na(weighted_protection)) %>%
    arrange(match(species_modified, tree$tip.label))
  
  pruned_tree <- ape::keep.tip(tree, matched_data$species_modified)
  
  # Calculate mean protection value for each genus
  genus_data <- matched_data %>%
    mutate(genus = str_extract(species_modified, "^[^_]+")) %>%
    group_by(genus) %>%
    summarize(
      mean_protection = mean(weighted_protection),
      n_species = n()
    ) %>%
    filter(mean_protection > quantile(mean_protection, 0.75)) %>%
    arrange(desc(mean_protection))
  
  # Create tree plot without grey borders
  p <- ggtree(pruned_tree, layout="circular", size=0.2) 
  
  # Add the data to the tree without borders
  p <- p %<+% matched_data + 
    geom_tippoint(aes(color=weighted_protection), size=2, shape=16) +  # shape=16 gives solid dots without borders
    scale_color_gradientn(
      colours = colorRampPalette(brewer.pal(9, "YlOrRd"))(100),
      name = "Protection Priority",
      limits = c(0, 1)
    ) +
    ggtitle(title) +
    theme(
      plot.title = element_text(hjust = 0.5, size = 14),
      legend.position = "right",
      panel.background = element_blank(),
      plot.background = element_blank()
    )
  
  # Highlight high-priority genera with more transparent highlights
  top_genera <- genus_data$genus[1:5]
  for(genus in top_genera) {
    tips <- matched_data %>%
      filter(str_detect(species_modified, paste0("^", genus))) %>%
      pull(species_modified)
    
    if(length(tips) > 0) {
      p <- p + geom_hilight(node = MRCA(p, tips), fill = "blue", alpha = 0.1)
    }
  }
  
  return(list(
    plot = p,
    high_priority_genera = genus_data
  ))
}

# Create plots for both scenarios
analysis_03 <- plot_and_analyze_clades(
  list_tree_sharks_p[[1]], 
  combined_protection_EDGE_03, 
  "EDGE Protection Priority (0.3 budget)"
)

analysis_01 <- plot_and_analyze_clades(
  list_tree_sharks_p[[1]], 
  combined_protection_EDGE_01, 
  "EDGE Protection Priority (0.1 budget)"
)

# Display combined plot
grid.arrange(
  analysis_03$plot, 
  analysis_01$plot, 
  ncol = 2
)

# Print results
print("Top priority genera (EDGE 0.3):")
print(analysis_03$high_priority_genera %>% head(10))
print("\nTop priority genera (EDGE 0.1):")
print(analysis_01$high_priority_genera %>% head(10))

```

### Combine four trees in a grid

```{r}
# Then combine them using patchwork:
library(patchwork)
combined_plot <- (tree_plot_NT + tree_plot_ALL) /
  (tree_plot_01 + tree_plot_03) + 
  plot_annotation(tag_levels = 'A')

# Save the combined plot
ggsave(here::here("combined_phylogenetic_trees.png"), combined_plot, 
       width = 12, height = 8, units = "in")

```

### Combine all trees in a single one : GAP analysis and EDGE 2 values -\> heatmap approach

```{r}
plot_combined_circular_tree <- function(tree, data, edge_data_01, edge_data_03) {
  library(ggplot2)
  library(ggtree)
  library(dplyr)
  
  # Ensure all datasets have common species
  common_species <- Reduce(intersect, list(
    data$species_modified[data$species_modified %in% tree$tip.label],
    edge_data_01$species_modified[edge_data_01$species_modified %in% tree$tip.label & !is.na(edge_data_01$weighted_protection)],
    edge_data_03$species_modified[edge_data_03$species_modified %in% tree$tip.label & !is.na(edge_data_03$weighted_protection)]
  ))
  
  # Filter and arrange all datasets
  matched_data <- data %>%
    filter(species_modified %in% common_species) %>%
    arrange(match(species_modified, common_species))
  
  matched_data_01 <- edge_data_01 %>%
    filter(species_modified %in% common_species) %>%
    arrange(match(species_modified, common_species))
  
  matched_data_03 <- edge_data_03 %>%
    filter(species_modified %in% common_species) %>%
    arrange(match(species_modified, common_species))
  
  # Create a dataframe for MPA percentages
  mpa_data <- matched_data %>%
    select(species_modified, percentage_in_NT_MPA, percentage_in_ALL_MPA) %>%
    mutate(
      percentage_in_NT_MPA = as.numeric(percentage_in_NT_MPA),
      percentage_in_ALL_MPA = as.numeric(percentage_in_ALL_MPA)
    )
  
  # Create a separate dataframe for EDGE weighted protection, 
  # converting from proportion (0-1) to percentage (0-100)
  edge_data <- data.frame(
    species_modified = matched_data_01$species_modified,
    weighted_protection_01 = matched_data_01$weighted_protection * 100,  # Convert to percentage
    weighted_protection_03 = matched_data_03$weighted_protection * 100   # Convert to percentage
  )
  
  # Set row names manually and create matrices
  mpa_matrix <- as.matrix(mpa_data[, -1])
  rownames(mpa_matrix) <- mpa_data$species_modified
  
  edge_matrix <- as.matrix(edge_data[, -1]) 
  rownames(edge_matrix) <- edge_data$species_modified
  
  # Combine into one matrix with desired ring order
  combined_matrix <- cbind(
    "NTake MPA" = mpa_matrix[, "percentage_in_NT_MPA"],
    "All MPA" = mpa_matrix[, "percentage_in_ALL_MPA"],
    "EDGE 01" = edge_matrix[, "weighted_protection_01"],
    "EDGE 03" = edge_matrix[, "weighted_protection_03"]
  )
  
  # Prune the tree to match the available data
  pruned_tree <- ape::keep.tip(tree, rownames(combined_matrix))
  
  # Create color palette
  n_colors <- 100
  color_palette <- get_color_palette(n_colors)
  
  # Base circular tree plot with light grey for tree lines
  p <- ggtree(pruned_tree, layout="circular", size=0.3, color="lightgrey")
  
  # Add heatmap rings without column names
  p <- gheatmap(p, combined_matrix, 
                width=0.4,  # Wider to accommodate 4 rings
                offset=0.1, 
                colnames=FALSE,
                font.size=3) + 
    scale_fill_gradientn(
      colours=color_palette, 
      name="Range protected (%)",  # Updated legend title
      limits=c(0, 100),
      na.value="grey80",
      oob=scales::squish
    )
  
  # Keep clean layout
  p <- p + theme(
    plot.margin = margin(t=10, r=10, b=10, l=10, unit="pt")
  )
  
  return(p)
}

combined_tree_plot <- plot_combined_circular_tree(
  list_tree_sharks_p[[1]], 
  results_IUCN_filtered,
  combined_protection_EDGE_01,
  combined_protection_EDGE_03
)

# Display the plot
combined_tree_plot

# Save the plot as PNG
ggsave(
  here::here("combined_tree_plot_heatmap.png"),  # Filename (include path if needed)
  plot = combined_tree_plot,
  width = 10,                # Width in inches
  height = 10,               # Height in inches
  dpi = 300                  # Resolution (dots per inch)
)
```

# Relate to FUSE and EDGE2

Relate the percentage of species range overlapped by MPAs to FUSE and EDGE2

```{r}
library(jsonlite)
library(here)
library(ggplot2)
library(dplyr)
library(purrr)
library(patchwork)
library(knitr)
library(kableExtra)

# Read the JSON file
data <- fromJSON(here("Data", "shark_conservation_metrics_no_freshwater.json"))

# Function to process data and create plot
process_and_plot <- function(metric_name) {
  # Merge and process data
  combined_data <- data[[metric_name]]$info %>%
    left_join(results_coords, by = "Species") %>%
    mutate(across(where(is.list), unlist),
           across(where(is.character), as.factor),
           !!metric_name := pmin(pmax(!!sym(metric_name), 0), 1))
  
  # Create plot
  plot <- ggplot(combined_data, aes_string(x = metric_name, y = "percentage_in_ALL_MPA")) +
    geom_point(alpha = 0.6) +
    geom_smooth(method = "lm", color = "red", se = TRUE) +
    theme_minimal() +
    labs(title = paste(metric_name, "vs % Range Protected"),
         x = metric_name,
         y = "% Range Protected") +
    scale_x_continuous(limits = c(0, 1), breaks = seq(0, 1, 0.2)) +
    scale_y_continuous(limits = c(0, 100), breaks = seq(0, 100, 20)) +
    theme(aspect.ratio = 1)
  
  # Calculate correlation
  cor_test <- cor.test(combined_data[[metric_name]], combined_data$percentage_in_ALL_MPA, use = "complete.obs")
  
  return(list(plot = plot, cor_test = cor_test))
}

# Process and plot for EDGE2 and FUSE
edge2_results <- process_and_plot("EDGE2") 
fuse_results <- process_and_plot("FUSE") 

# Combine plots in a grid with 2 columns
combined_plot <- edge2_results$plot + fuse_results$plot +
  plot_layout(ncol = 2) +
  plot_annotation(
    title = NULL,
    theme = theme(plot.title = element_text(hjust = 0.5, size = 16))
  )

# Print the combined plot
print(combined_plot)

# Create a data frame with correlation test results
correlation_results <- data.frame(
  Metric = c("EDGE2", "FUSE"),
  Correlation = c(edge2_results$cor_test$estimate, fuse_results$cor_test$estimate),
  P_value = c(edge2_results$cor_test$p.value, fuse_results$cor_test$p.value)
)

# Create and print the kable table
kable_table <- kable(correlation_results, 
                     col.names = c("Metric", "Correlation", "P-value"),
                     digits = c(0, 3, 4),
                     caption = "Correlation Test Results") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
                full_width = FALSE)

kable_table
```

**Key message:** There is significant negative relationship between EDGE2 and FUSE with the % of range protected. Species with high FUSE or high EDGE2 tend to be less protected than those with low EDGE2 or FUSE.

# Relate to Biogeographical Realms, Ecoregions and Nations


```{r}
#Realms 
# Load required libraries
library(sf)
library(terra)
library(dplyr)
library(ggplot2)
library(here)
library(forcats)  # For factor manipulation

# Load continental_projected_NT
continental_projected_NT <- readRDS(here("Data", "continental_projected_NT.rds"))

# Load MEOW ecosystems shapefile
meow_ecos <- st_read(here("Data", "Shapefiles", "meow_ecos", "meow_ecos.shp"), quiet = TRUE)

# Inspect the MEOW data to understand its structure
print(names(meow_ecos))
print(head(meow_ecos))

# Step 1: Transform MEOW to match the CRS of the point data
meow_projected <- st_transform(meow_ecos, st_crs(continental_projected_NT))

# Step 2: Convert to terra objects
points_vect <- terra::vect(continental_projected_NT)
meow_vect <- terra::vect(meow_projected)

# Step 3: Use terra's intersect function for MEOW ecosystems
meow_intersect <- terra::intersect(points_vect, meow_vect)

# Step 4: Extract the results to a data frame
meow_df <- as.data.frame(meow_intersect)

# Calculate median SES per REALM
realm_summary <- meow_df %>%
  group_by(REALM) %>%
  summarise(
    median_SES = median(mean_SES, na.rm = TRUE),
    n = n(),
    .groups = "drop"
  ) %>%
  arrange(desc(median_SES))

# Print the realms in order
print(realm_summary)

# Create a new factor with proper ordering
ordered_realms <- realm_summary$REALM

# Update the dataframe with the properly ordered factor
meow_df$REALM_ordered <- factor(
  meow_df$REALM, 
  levels = ordered_realms,
  ordered = TRUE
)

# Create the boxplot with properly ordered y-axis and no whiskers
ggplot(meow_df, aes(x = mean_SES, y = REALM_ordered)) +
  geom_boxplot(outlier.shape = NA, coef = 0) +  # No whiskers
  theme_bw() +
  labs(
    title = "Distribution of Mean SES Values by Biogeographical Realm",
    subtitle = "Ordered by Median Value (Lowest to Highest)",
    y = "Biogeographical Realm",
    x = "Mean SES"
  ) +
  theme(
    axis.text.y = element_text(size = 10),
    panel.grid.major.y = element_blank()
  )

# Save the results
ggsave(here("Outputs", "meow_realm_ses_boxplot_horizontal.png"), width = 10, height = 6)
saveRDS(realm_summary, here("Data", "meow_realm_ses_summary.rds"))
saveRDS(meow_df, here("Data", "meow_ses_data.rds"))

#Ecoregions
# Load MEOW ecosystems shapefile
meow_ecos <- st_read(here("Data", "Shapefiles", "meow_ecos", "meow_ecos.shp"), quiet = TRUE)

# Transform MEOW to match the CRS of the point data
meow_projected <- st_transform(meow_ecos, st_crs(continental_projected_NT))

# Convert to terra objects
meow_vect <- terra::vect(meow_projected)

# Use terra's intersect function for MEOW ecosystems
meow_intersect <- terra::intersect(points_vect, meow_vect)

# Extract the results to a data frame
meow_df <- as.data.frame(meow_intersect)

# Calculate median SES per ECOREGION
ecoregion_summary <- meow_df %>%
  group_by(ECOREGION) %>%
  summarise(
    median_SES = median(mean_SES, na.rm = TRUE),
    n = n(),
    .groups = "drop"
  ) %>%
  # Filter out regions with very few points if needed
  # filter(n >= 5) %>%
  arrange(desc(median_SES))

# Print top and bottom few to check
print(head(ecoregion_summary, 10))
print(tail(ecoregion_summary, 10))

# Create a new factor with proper ordering
ordered_ecoregions <- ecoregion_summary$ECOREGION

# Update the dataframe with the properly ordered factor
meow_df$ECOREGION_ordered <- factor(
  meow_df$ECOREGION, 
  levels = ordered_ecoregions,
  ordered = TRUE
)

# Create the full boxplot with properly ordered y-axis and no whiskers
ggplot(meow_df, aes(x = mean_SES, y = ECOREGION_ordered)) +
  geom_boxplot(outlier.shape = NA, coef = 0) +  # No whiskers
  theme_bw() +
  labs(
    title = "Distribution of Mean SES Values by MEOW Ecoregion",
    subtitle = "Ordered by Median Value (Highest to Lowest)",
    y = "MEOW Ecoregion",
    x = "Mean SES"
  ) +
  theme(
    axis.text.y = element_text(size = 7),  # Smaller text for more ecoregions
    panel.grid.major.y = element_blank()
  )

# Create the top 20 version
top_20_ecoregions <- head(ordered_ecoregions, 20)

# Filter data for top 20
ecoregion_top20 <- meow_df %>% 
  filter(ECOREGION %in% top_20_ecoregions)

# Recreate the factor specifically for the top 20 (for proper ordering)
ecoregion_top20$ECOREGION_ordered <- factor(
  ecoregion_top20$ECOREGION,
  levels = top_20_ecoregions,
  ordered = TRUE
)

# Create the top 20 plot with properly ordered y-axis and no whiskers
ggplot(ecoregion_top20, aes(x = mean_SES, y = ECOREGION_ordered)) +
  geom_boxplot(outlier.shape = NA, coef = 0) +  # No whiskers
  theme_bw() +
  labs(
    title = "Distribution of Mean SES Values by MEOW Ecoregion (Top 20)",
    subtitle = "Ordered by Median Value (Highest to Lowest)",
    y = "MEOW Ecoregion",
    x = "Mean SES"
  ) +
  theme(
    axis.text.y = element_text(size = 9),
    panel.grid.major.y = element_blank()
  )

# Save the results
ggsave(here("Plots", "meow_ecoregion_ses_boxplot_top20_horizontal.png"), width = 10, height = 8)
saveRDS(meow_df, here("Data", "meow_ecoregion_ses_data.rds"))

# EEZs 

# Load required libraries
library(sf)
library(terra)
library(dplyr)
library(ggplot2)
library(here)
library(forcats)  # For factor manipulation

# Load continental_projected_NT
continental_projected_NT <- readRDS(here("Data", "continental_projected_NT.rds"))

# Load EEZ shapefile
eez <- st_read(here("Data", "World_EEZ_v12_20231025", "eez_v12.shp"), quiet = TRUE)

# Step 1: Transform EEZ to match the CRS of the point data
eez_projected <- st_transform(eez, st_crs(continental_projected_NT))

# Step 2: Convert to terra objects
points_vect <- terra::vect(continental_projected_NT)
eez_vect <- terra::vect(eez_projected)

# Step 3: Use terra's intersect function
intersect_result <- terra::intersect(points_vect, eez_vect)

# Step 4: Extract the results to a data frame
intersect_df <- as.data.frame(intersect_result)

# Step 5: Calculate median SES per sovereign territory
eez_summary <- intersect_df %>%
  group_by(SOVEREIGN1) %>%
  summarise(
    median_SES = median(mean_SES, na.rm = TRUE),
    n = n(),  # Count number of points
    .groups = "drop"
  ) %>%
  # Filter out territories with very few points if needed
  # filter(n >= 5) %>%
  arrange(desc(median_SES))  # Order by descending median SES

# Print top and bottom few to check
print(head(eez_summary, 10))
print(tail(eez_summary, 10))

# Step 6: Create a new factor with proper ordering
# Make sure the levels are in the correct order (highest median SES first)
ordered_sovereigns <- eez_summary$SOVEREIGN1

# Update the dataframe with the properly ordered factor
intersect_df$SOVEREIGN1_ordered <- factor(
  intersect_df$SOVEREIGN1, 
  levels = ordered_sovereigns,  # Use the ordered list of sovereigns
  ordered = TRUE  # Make it an ordered factor
)

# Step 7: Create the full boxplot with properly ordered y-axis
ggplot(intersect_df, aes(x = mean_SES, y = SOVEREIGN1_ordered)) +
  geom_boxplot(outlier.shape = NA, coef = 0) +  # coef = 0 removes whiskers
  theme_bw() +
  labs(
    title = "Distribution of Mean SES Values by Sovereign Territory",
    subtitle = "Ordered by Median Value (Highest to Lowest)",
    y = "Sovereign Territory",
    x = "Mean SES"
  ) +
  theme(
    axis.text.y = element_text(size = 8),
    panel.grid.major.y = element_blank()
  )

# Step 8: Create the top 20 version
top_20_sovereigns <- head(ordered_sovereigns, 20)

# Filter data for top 20
top20_data <- intersect_df %>% 
  filter(SOVEREIGN1 %in% top_20_sovereigns)

# Recreate the factor specifically for the top 20 (for proper ordering)
top20_data$SOVEREIGN1_ordered <- factor(
  top20_data$SOVEREIGN1,
  levels = top_20_sovereigns,
  ordered = TRUE
)

# Create the top 20 plot with properly ordered y-axis
ggplot(top20_data, aes(x = mean_SES, y = SOVEREIGN1_ordered)) +
  geom_boxplot(outlier.shape = NA, coef = 0) +  # coef = 0 removes whiskers
  theme_bw() +
  labs(
    title = "Distribution of Mean SES Values by Sovereign Territory (Top 20)",
    subtitle = "Ordered by Median Value (Lowest to Highest)",
    y = "Sovereign Territory",
    x = "Mean SES"
  ) +
  theme(
    axis.text.y = element_text(size = 9),
    panel.grid.major.y = element_blank()
  )

# Save the results
ggsave(here("Plots", "eez_ses_boxplot_top20_horizontal.png"), width = 10, height = 8)
saveRDS(intersect_df, here("Data", "eez_ses_data.rds"))
```